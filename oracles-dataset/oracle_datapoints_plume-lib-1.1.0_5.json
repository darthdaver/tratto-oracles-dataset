[ {
  "id" : 10429,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */",
  "methodSourceCode" : "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException{\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "read", "java.io", "InputStreamReader", "public int read(CharBuffer arg0) throws IOException" ], [ "getEncoding", "java.io", "InputStreamReader", "public String getEncoding()" ], [ "ready", "java.io", "InputStreamReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10430,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws FileNotFoundException if the file is not found",
  "methodJavadoc" : "    /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */",
  "methodSourceCode" : "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException{\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "read", "java.io", "InputStreamReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "ready", "java.io", "InputStreamReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read(CharBuffer arg0) throws IOException" ], [ "getEncoding", "java.io", "InputStreamReader", "public String getEncoding()" ], [ "read", "java.io", "InputStreamReader", "public int read() throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10434,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException{\n    return fileReader(file, null);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "length", "java.io", "File", "public long length()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "toString", "java.io", "File", "public String toString()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "getName", "java.io", "File", "public String getName()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "read", "java.io", "InputStreamReader", "public int read() throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read(CharBuffer arg0) throws IOException" ], [ "ready", "java.io", "InputStreamReader", "public boolean ready() throws IOException" ], [ "getEncoding", "java.io", "InputStreamReader", "public String getEncoding()" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10438,
  "oracle" : "file.exists() == false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws FileNotFoundException if the file cannot be found",
  "methodJavadoc" : "    /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException{\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ], [ "charsetName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "toString", "java.io", "File", "public String toString()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "getName", "java.io", "File", "public String getName()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "list", "java.io", "File", "public String[] list()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "length", "java.io", "File", "public long length()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "read", "java.io", "InputStreamReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "ready", "java.io", "InputStreamReader", "public boolean ready() throws IOException" ], [ "getEncoding", "java.io", "InputStreamReader", "public String getEncoding()" ], [ "read", "java.io", "InputStreamReader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10439,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException{\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ], [ "charsetName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "length", "java.io", "File", "public long length()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "getName", "java.io", "File", "public String getName()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "toString", "java.io", "File", "public String toString()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "length", "java.lang", "String", "public int length()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "getEncoding", "java.io", "InputStreamReader", "public String getEncoding()" ], [ "read", "java.io", "InputStreamReader", "public int read() throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read(CharBuffer arg0) throws IOException" ], [ "ready", "java.io", "InputStreamReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "InputStreamReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10443,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException{\n    return bufferedFileReader(new File(filename));\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "length", "java.lang", "String", "public int length()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10447,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException{\n    return (bufferedFileReader(file, null));\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "toString", "java.io", "File", "public String toString()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "getName", "java.io", "File", "public String getName()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "length", "java.io", "File", "public long length()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "list", "java.io", "File", "public String[] list()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10449,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@param charsetName the character set to use when reading the file",
  "methodJavadoc" : "    /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException{\n    return bufferedFileReader(new File(filename), charsetName);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ], [ "charsetName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10451,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws FileNotFoundException if the file cannot be found",
  "methodJavadoc" : "    /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException{\n    return bufferedFileReader(new File(filename), charsetName);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ], [ "charsetName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10452,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException{\n    return bufferedFileReader(new File(filename), charsetName);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ], [ "charsetName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10456,
  "oracle" : "file.exists() == false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws FileNotFoundException if the file cannot be found",
  "methodJavadoc" : "    /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException{\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ], [ "charsetName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "getName", "java.io", "File", "public String getName()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "toString", "java.io", "File", "public String toString()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "length", "java.io", "File", "public long length()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "list", "java.io", "File", "public String[] list()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10460,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws FileNotFoundException if the file cannot be found",
  "methodJavadoc" : "    /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException{\n    return lineNumberFileReader(new File(filename));\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "read", "java.io", "LineNumberReader", "public int read() throws IOException" ], [ "getLineNumber", "java.io", "LineNumberReader", "public int getLineNumber()" ], [ "read", "java.io", "LineNumberReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "readLine", "java.io", "LineNumberReader", "public String readLine() throws IOException" ], [ "skip", "java.io", "LineNumberReader", "public long skip(long arg0) throws IOException" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10461,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException{\n    return lineNumberFileReader(new File(filename));\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "length", "java.lang", "String", "public int length()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "readLine", "java.io", "LineNumberReader", "public String readLine() throws IOException" ], [ "read", "java.io", "LineNumberReader", "public int read() throws IOException" ], [ "skip", "java.io", "LineNumberReader", "public long skip(long arg0) throws IOException" ], [ "getLineNumber", "java.io", "LineNumberReader", "public int getLineNumber()" ], [ "read", "java.io", "LineNumberReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10464,
  "oracle" : "file.exists() == false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws FileNotFoundException if the file cannot be found",
  "methodJavadoc" : "    /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException{\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "getName", "java.io", "File", "public String getName()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "length", "java.io", "File", "public long length()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "toString", "java.io", "File", "public String toString()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "getLineNumber", "java.io", "LineNumberReader", "public int getLineNumber()" ], [ "read", "java.io", "LineNumberReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "readLine", "java.io", "LineNumberReader", "public String readLine() throws IOException" ], [ "skip", "java.io", "LineNumberReader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "LineNumberReader", "public int read() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10465,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException{\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "toString", "java.io", "File", "public String toString()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "length", "java.io", "File", "public long length()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "getName", "java.io", "File", "public String getName()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "readLine", "java.io", "LineNumberReader", "public String readLine() throws IOException" ], [ "read", "java.io", "LineNumberReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "skip", "java.io", "LineNumberReader", "public long skip(long arg0) throws IOException" ], [ "read", "java.io", "LineNumberReader", "public int read() throws IOException" ], [ "getLineNumber", "java.io", "LineNumberReader", "public int getLineNumber()" ], [ "read", "java.io", "BufferedReader", "public int read() throws IOException" ], [ "ready", "java.io", "BufferedReader", "public boolean ready() throws IOException" ], [ "read", "java.io", "BufferedReader", "public int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "BufferedReader", "public boolean markSupported()" ], [ "readLine", "java.io", "BufferedReader", "public String readLine() throws IOException" ], [ "skip", "java.io", "BufferedReader", "public long skip(long arg0) throws IOException" ], [ "lines", "java.io", "BufferedReader", "public Stream<String> lines()" ], [ "readLine", "java.io", "BufferedReader", "String readLine(boolean arg0, boolean[] arg1) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10468,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble writing the file",
  "methodJavadoc" : "    /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */",
  "methodSourceCode" : "public static BufferedWriter bufferedFileWriter(String filename) throws IOException{\n    return bufferedFileWriter(filename, false);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "append", "java.io", "Writer", "public Writer append(char arg0) throws IOException" ], [ "append", "java.io", "Writer", "public Writer append(CharSequence arg0) throws IOException" ], [ "append", "java.io", "Writer", "public Writer append(CharSequence arg0, int arg1, int arg2) throws IOException" ], [ "append", "java.lang", "Appendable", "public abstract Appendable append(CharSequence arg0) throws IOException" ], [ "append", "java.lang", "Appendable", "public abstract Appendable append(CharSequence arg0, int arg1, int arg2) throws IOException" ], [ "append", "java.lang", "Appendable", "public abstract Appendable append(char arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "lock", "java.io", "Writer", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10471,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@return a BufferedOutputStream for filename",
  "methodJavadoc" : "    /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */",
  "methodSourceCode" : "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException{\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ], [ "append", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "buf", "java.io", "BufferedOutputStream", "protected byte[] buf;" ], [ "count", "java.io", "BufferedOutputStream", "protected int count;" ], [ "out", "java.io", "FilterOutputStream", "protected OutputStream out;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10472,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble writing the file",
  "methodJavadoc" : "    /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */",
  "methodSourceCode" : "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException{\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1.4", "double" ], [ "\".gz\"", "String" ], [ "\"gzip\"", "String" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ], [ "append", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "buf", "java.io", "BufferedOutputStream", "protected byte[] buf;" ], [ "count", "java.io", "BufferedOutputStream", "protected int count;" ], [ "out", "java.io", "FilterOutputStream", "protected OutputStream out;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10491,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static long count_lines(String filename) throws IOException{\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10494,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static String inferLineSeparator(String filename) throws IOException{\n    return inferLineSeparator(new File(filename));\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10497,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble reading the file",
  "methodJavadoc" : "    /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */",
  "methodSourceCode" : "public static String inferLineSeparator(File file) throws IOException{\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "file", "java.io", "File" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "length", "java.io", "File", "public long length()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "toString", "java.io", "File", "public String toString()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "getName", "java.io", "File", "public String getName()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10508,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException If a file could not be created",
  "methodJavadoc" : "    /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */",
  "methodSourceCode" : "public static File createTempDir(String prefix, String suffix) throws IOException{\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "\"myPrefix\"", "String" ], [ "\"mySuffix\"", "String" ], [ "\".tmp\"", "String" ] ],
  "tokensMethodArguments" : [ [ "prefix", "java.lang", "String" ], [ "suffix", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "length", "java.lang", "String", "public int length()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "toString", "java.io", "File", "public String toString()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "getName", "java.io", "File", "public String getName()" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "length", "java.io", "File", "public long length()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10509,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws SecurityException If a security manager exists and its\n SecurityManager.checkWrite(java.lang.String) method does not allow a\n file to be created",
  "methodJavadoc" : "    /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */",
  "methodSourceCode" : "public static File createTempDir(String prefix, String suffix) throws IOException{\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "\"myPrefix\"", "String" ], [ "\"mySuffix\"", "String" ], [ "\".tmp\"", "String" ] ],
  "tokensMethodArguments" : [ [ "prefix", "java.lang", "String" ], [ "suffix", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "length", "java.lang", "String", "public int length()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "toString", "java.io", "File", "public String toString()" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "getName", "java.io", "File", "public String getName()" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "length", "java.io", "File", "public long length()" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "list", "java.io", "File", "public String[] list()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10522,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@throws IOException if there is trouble writing the file",
  "methodJavadoc" : "    /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */",
  "methodSourceCode" : "public static void writeObject(Object o, File file) throws IOException{\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "o", "java.lang", "Object" ], [ "file", "java.io", "File" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getPrefixLength", "java.io", "File", "int getPrefixLength()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FileFilter arg0)" ], [ "delete", "java.io", "File", "public boolean delete()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0, boolean arg1)" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0)" ], [ "toURL", "java.io", "File", "public URL toURL() throws MalformedURLException" ], [ "isFile", "java.io", "File", "public boolean isFile()" ], [ "toURI", "java.io", "File", "public URI toURI()" ], [ "getName", "java.io", "File", "public String getName()" ], [ "lastModified", "java.io", "File", "public long lastModified()" ], [ "getPath", "java.io", "File", "public String getPath()" ], [ "getCanonicalFile", "java.io", "File", "public File getCanonicalFile() throws IOException" ], [ "getTotalSpace", "java.io", "File", "public long getTotalSpace()" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0)" ], [ "canRead", "java.io", "File", "public boolean canRead()" ], [ "hashCode", "java.io", "File", "public int hashCode()" ], [ "createNewFile", "java.io", "File", "public boolean createNewFile() throws IOException" ], [ "setWritable", "java.io", "File", "public boolean setWritable(boolean arg0, boolean arg1)" ], [ "toPath", "java.io", "File", "public Path toPath()" ], [ "toString", "java.io", "File", "public String toString()" ], [ "canWrite", "java.io", "File", "public boolean canWrite()" ], [ "getFreeSpace", "java.io", "File", "public long getFreeSpace()" ], [ "setReadable", "java.io", "File", "public boolean setReadable(boolean arg0, boolean arg1)" ], [ "mkdirs", "java.io", "File", "public boolean mkdirs()" ], [ "mkdir", "java.io", "File", "public boolean mkdir()" ], [ "listFiles", "java.io", "File", "public File[] listFiles()" ], [ "isHidden", "java.io", "File", "public boolean isHidden()" ], [ "isInvalid", "java.io", "File", "final boolean isInvalid()" ], [ "list", "java.io", "File", "public String[] list(FilenameFilter arg0)" ], [ "canExecute", "java.io", "File", "public boolean canExecute()" ], [ "getUsableSpace", "java.io", "File", "public long getUsableSpace()" ], [ "setExecutable", "java.io", "File", "public boolean setExecutable(boolean arg0)" ], [ "length", "java.io", "File", "public long length()" ], [ "getCanonicalPath", "java.io", "File", "public String getCanonicalPath() throws IOException" ], [ "getParentFile", "java.io", "File", "public File getParentFile()" ], [ "isDirectory", "java.io", "File", "public boolean isDirectory()" ], [ "getAbsoluteFile", "java.io", "File", "public File getAbsoluteFile()" ], [ "getAbsolutePath", "java.io", "File", "public String getAbsolutePath()" ], [ "isAbsolute", "java.io", "File", "public boolean isAbsolute()" ], [ "equals", "java.io", "File", "public boolean equals(Object arg0)" ], [ "compareTo", "java.io", "File", "public int compareTo(File arg0)" ], [ "renameTo", "java.io", "File", "public boolean renameTo(File arg0)" ], [ "setLastModified", "java.io", "File", "public boolean setLastModified(long arg0)" ], [ "exists", "java.io", "File", "public boolean exists()" ], [ "listFiles", "java.io", "File", "public File[] listFiles(FilenameFilter arg0)" ], [ "list", "java.io", "File", "public String[] list()" ], [ "getParent", "java.io", "File", "public String getParent()" ], [ "setReadOnly", "java.io", "File", "public boolean setReadOnly()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]