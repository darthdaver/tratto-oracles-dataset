[ {
  "id" : 10235,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "OptionsDoclet",
  "javadocTag" : "@param option the command-line option",
  "methodJavadoc" : "    /**\n   * Given a command-line option of this doclet, returns the number of\n   * arguments you must specify on the command line for the given option.\n   * Returns 0 if the argument is not recognized.  This method is\n   * automatically invoked.\n   *\n   * @param option the command-line option\n   * @return the number of command-line arguments needed when using the option\n   * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n   */",
  "methodSourceCode" : "public static int optionLength(String option){\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}",
  "classJavadoc" : "/**\n * Generates HTML documentation of command-line options.  Works with the\n * {@link plume.Options} class.\n * <p>\n *\n * <b>Usage</b> <p>\n * This doclet is typically invoked with:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet [doclet options] [java files]</pre>\n * <p>\n *\n * <b>Doclet Options</b> <p>\n * The following doclet options are supported:\n * <ul>\n * <li> <b>-docfile</b> <i>file</i> When specified, the output of this doclet\n * is the result of replacing everything between the two lines\n * <pre>&lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n * and\n * <pre>&lt;!-- end options doc --&gt;</pre>\n * in <i>file</i> with the options documentation.  This can be used for\n * inserting option documentation into an existing manual.  The existing\n * docfile is not modified; output goes to the <code>-outfile</code>\n * argument, or to standard out.\n *\n * <li> <b>-outfile</b> <i>file</i> The destination for the output (the default\n * is standard out).  If both <code>-outfile</code> and <code>-docfile</code>\n * are specified, they must be different. When <code>-d</code> is used, the\n * output is written to a file with the given name relative to that destination\n * directory.\n *\n * <li> <b>-d</b> <i>directory</i> The destination directory for the output file.\n * Only used if <code>-outfile</code> is used, in which case, the file is\n * written in this directory. Otherwise, this option is ignored.\n *\n * <li> <b>-i</b> Specifies that the docfile should be edited in-place.  This\n * option can only be used if the <code>-docfile</code> option is used, and\n * may not be used at the same time as the <code>-outfile</code> option.\n *\n * <li> <b>-format</b> <i>format</i> This option sets the output format of this\n * doclet.  Currently, the following values for <i>format</i> are supported:\n * <ul>\n *   <li> <b>javadoc</b> When this format is specified, the output of this\n *   doclet is formatted as a Javadoc comment.  This is useful for including\n *   option documentation inside Java source code.  When this format is used\n *   with the <code>-docfile</code> option, the generated documentation is\n *   inserted between the lines\n *   <pre>* &lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n *   and\n *   <pre>* &lt;!-- end options doc --&gt;</pre>\n *   using the same indentation.  Inline <code>@link</code> and\n *   <code>@see</code> tags in the Javadoc input are left untouched.\n *\n *   <li> <b>html</b> This format outputs HTML for general-purpose use, meaning\n *   inline <code>@link</code> and <code>@see</code> tags in the Javadoc input\n *   are suitably replaced.  This is the default output format and does not\n *   need to be specified explicitly.\n * </ul>\n *\n * <li> <b>-classdoc</b> When specified, the output of this doclet includes the\n * class documentation of the first class specified on the command-line.\n *\n * <li> <b>-singledash</b> When specified, <code>use_single_dash(true)</code> is\n * called on the underlying instance of Options used to generate documentation.\n * See {@link plume.Options#use_single_dash(boolean)}.\n * </ul>\n * <p>\n *\n * <b>Examples</b> <p>\n * To update the Javarifier HTML manual with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile javarifier.html src/javarifier/Main.java</pre>\n * <p>\n *\n * To update the class Javadoc for plume.Lookup with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile Lookup.java -format javadoc Lookup.java</pre>\n * <p>\n *\n * For a more extensive example, see file <code>java/Makefile</code> in\n * plume-lib itself.\n * <p>\n *\n * <b>Requirements</b> <p>\n * Classes passed to OptionsDoclet that have <code>@</code>{@link Option} annotations on\n * non-static fields should have a nullary (no-argument) constructor.  The\n * nullary constructor may be private or public.  This is required because an\n * object instance is needed to get the default value of a non-static field.  It\n * is cleaner to require a nullary constructor instead of trying to guess\n * arguments to pass to another constructor. <p>\n *\n * <b>Hiding default value strings</b> <p>\n * By default, the documentation generated by OptionsDoclet includes a default\n * value string for each option in square brackets after the option's\n * description, similar to the usage messages generated by {@link\n * plume.Options#usage(String...)}.  The {@link plume.Option#noDocDefault}\n * field in the <code>@Option</code> annotation can be set to <code>true</code>\n * to omit the default value string from the generated documentation for that\n * option. <p>\n *\n * Omitting the generated default value string is useful for options that have\n * system-dependent defaults.  Such options are not an issue for usage messages\n * that are generated at runtime.  However, system dependent defaults do pose\n * a problem for static documentation, which is rarely regenerated and meant to\n * apply to all users.  Consider the following <code>@Option</code>-annotated\n * field:\n * <pre>\n * &#64;Option(value=\"&lt;timezone&gt; Set the time zone\")\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * The default value for <code>timezone</code> depends on the system's timezone\n * setting.  HTML documentation of this option generated in Chicago would not\n * apply to a user in New York.  To work around this problem, the\n * default value should be hidden; instead the Javadoc for this field\n * should indicate a special default as follows.\n * <pre>\n * &#47;**\n *  * &lt;other stuff...&gt;  This option defaults to the system timezone.\n *  *&#47;\n * &#64;Option(value=\"&lt;timezone&gt; Set the timezone\", noDocDefault=true)\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * This keeps the documentation system-agnostic. <p>\n *\n * <b>Caveats</b> <p>\n * The generated HTML documentation includes unpublicized option groups but not\n * <code>@Unpublicized</code> options.  Option groups which contain only\n * <code>@Unpublicized</code> options are not included in the output at all. <p>\n *\n * <b>Troubleshooting</b> <p>\n * If you get an error such as \"<code>ARGH! @Option</code>\", then you are using a\n * buggy version of gjdoc, the GNU Classpath implementation of Javadoc.\n * To avoid the problem, upgrade or use a different Javadoc implementation.\n *\n * @see plume.Option\n * @see plume.Options\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n */",
  "classSourceCode" : "// The five files\n//   Option.java\n//   OptionGroup.java\n//   Options.java\n//   Unpublicized.java\n//   OptionsDoclet.java\n// together comprise the implementation of command-line processing.\n\npackage plume;\n\nimport com.sun.javadoc.ClassDoc;\nimport com.sun.javadoc.Doc;\nimport com.sun.javadoc.DocErrorReporter;\nimport com.sun.javadoc.FieldDoc;\nimport com.sun.javadoc.RootDoc;\nimport com.sun.javadoc.SeeTag;\nimport com.sun.javadoc.Tag;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Formatter;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/*>>>\nimport org.checkerframework.checker.formatter.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n/**\n * Generates HTML documentation of command-line options.  Works with the\n * {@link plume.Options} class.\n * <p>\n *\n * <b>Usage</b> <p>\n * This doclet is typically invoked with:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet [doclet options] [java files]</pre>\n * <p>\n *\n * <b>Doclet Options</b> <p>\n * The following doclet options are supported:\n * <ul>\n * <li> <b>-docfile</b> <i>file</i> When specified, the output of this doclet\n * is the result of replacing everything between the two lines\n * <pre>&lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n * and\n * <pre>&lt;!-- end options doc --&gt;</pre>\n * in <i>file</i> with the options documentation.  This can be used for\n * inserting option documentation into an existing manual.  The existing\n * docfile is not modified; output goes to the <code>-outfile</code>\n * argument, or to standard out.\n *\n * <li> <b>-outfile</b> <i>file</i> The destination for the output (the default\n * is standard out).  If both <code>-outfile</code> and <code>-docfile</code>\n * are specified, they must be different. When <code>-d</code> is used, the\n * output is written to a file with the given name relative to that destination\n * directory.\n *\n * <li> <b>-d</b> <i>directory</i> The destination directory for the output file.\n * Only used if <code>-outfile</code> is used, in which case, the file is\n * written in this directory. Otherwise, this option is ignored.\n *\n * <li> <b>-i</b> Specifies that the docfile should be edited in-place.  This\n * option can only be used if the <code>-docfile</code> option is used, and\n * may not be used at the same time as the <code>-outfile</code> option.\n *\n * <li> <b>-format</b> <i>format</i> This option sets the output format of this\n * doclet.  Currently, the following values for <i>format</i> are supported:\n * <ul>\n *   <li> <b>javadoc</b> When this format is specified, the output of this\n *   doclet is formatted as a Javadoc comment.  This is useful for including\n *   option documentation inside Java source code.  When this format is used\n *   with the <code>-docfile</code> option, the generated documentation is\n *   inserted between the lines\n *   <pre>* &lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n *   and\n *   <pre>* &lt;!-- end options doc --&gt;</pre>\n *   using the same indentation.  Inline <code>@link</code> and\n *   <code>@see</code> tags in the Javadoc input are left untouched.\n *\n *   <li> <b>html</b> This format outputs HTML for general-purpose use, meaning\n *   inline <code>@link</code> and <code>@see</code> tags in the Javadoc input\n *   are suitably replaced.  This is the default output format and does not\n *   need to be specified explicitly.\n * </ul>\n *\n * <li> <b>-classdoc</b> When specified, the output of this doclet includes the\n * class documentation of the first class specified on the command-line.\n *\n * <li> <b>-singledash</b> When specified, <code>use_single_dash(true)</code> is\n * called on the underlying instance of Options used to generate documentation.\n * See {@link plume.Options#use_single_dash(boolean)}.\n * </ul>\n * <p>\n *\n * <b>Examples</b> <p>\n * To update the Javarifier HTML manual with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile javarifier.html src/javarifier/Main.java</pre>\n * <p>\n *\n * To update the class Javadoc for plume.Lookup with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile Lookup.java -format javadoc Lookup.java</pre>\n * <p>\n *\n * For a more extensive example, see file <code>java/Makefile</code> in\n * plume-lib itself.\n * <p>\n *\n * <b>Requirements</b> <p>\n * Classes passed to OptionsDoclet that have <code>@</code>{@link Option} annotations on\n * non-static fields should have a nullary (no-argument) constructor.  The\n * nullary constructor may be private or public.  This is required because an\n * object instance is needed to get the default value of a non-static field.  It\n * is cleaner to require a nullary constructor instead of trying to guess\n * arguments to pass to another constructor. <p>\n *\n * <b>Hiding default value strings</b> <p>\n * By default, the documentation generated by OptionsDoclet includes a default\n * value string for each option in square brackets after the option's\n * description, similar to the usage messages generated by {@link\n * plume.Options#usage(String...)}.  The {@link plume.Option#noDocDefault}\n * field in the <code>@Option</code> annotation can be set to <code>true</code>\n * to omit the default value string from the generated documentation for that\n * option. <p>\n *\n * Omitting the generated default value string is useful for options that have\n * system-dependent defaults.  Such options are not an issue for usage messages\n * that are generated at runtime.  However, system dependent defaults do pose\n * a problem for static documentation, which is rarely regenerated and meant to\n * apply to all users.  Consider the following <code>@Option</code>-annotated\n * field:\n * <pre>\n * &#64;Option(value=\"&lt;timezone&gt; Set the time zone\")\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * The default value for <code>timezone</code> depends on the system's timezone\n * setting.  HTML documentation of this option generated in Chicago would not\n * apply to a user in New York.  To work around this problem, the\n * default value should be hidden; instead the Javadoc for this field\n * should indicate a special default as follows.\n * <pre>\n * &#47;**\n *  * &lt;other stuff...&gt;  This option defaults to the system timezone.\n *  *&#47;\n * &#64;Option(value=\"&lt;timezone&gt; Set the timezone\", noDocDefault=true)\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * This keeps the documentation system-agnostic. <p>\n *\n * <b>Caveats</b> <p>\n * The generated HTML documentation includes unpublicized option groups but not\n * <code>@Unpublicized</code> options.  Option groups which contain only\n * <code>@Unpublicized</code> options are not included in the output at all. <p>\n *\n * <b>Troubleshooting</b> <p>\n * If you get an error such as \"<code>ARGH! @Option</code>\", then you are using a\n * buggy version of gjdoc, the GNU Classpath implementation of Javadoc.\n * To avoid the problem, upgrade or use a different Javadoc implementation.\n *\n * @see plume.Option\n * @see plume.Options\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n */\n\n// This doesn't itself use plume.Options for its command-line option\n// processing because a Doclet is required to implement the optionLength\n// and validOptions methods.\npublic class OptionsDoclet {\n\n  private static String eol = System.getProperty(\"line.separator\");\n\n  private final static /*@Format({})*/ String USAGE =\n      \"Provided by Options doclet:%n\"\n          + \"-docfile <file>        Specify file into which options documentation is inserted%n\"\n          + \"-outfile <file>        Specify destination for resulting output%n\"\n          + \"-d <directory>         Destination directory for -outfile%n\"\n          + \"-i                     Edit the docfile in-place%n\"\n          + \"-format javadoc        Format output as a Javadoc comment%n\"\n          + \"-classdoc              Include 'main' class documentation in output%n\"\n          + \"-singledash            Use single dashes for long options (see plume.Options)%n\"\n          + \"See the OptionsDoclet documentation for more details.%n\";\n\n  private static final String LIST_HELP =\n      \"<code>[+]</code> marked option can be specified multiple times\";\n\n  private String startDelim = \"<!-- start options doc (DO NOT EDIT BY HAND) -->\";\n  private String endDelim = \"<!-- end options doc -->\";\n\n  private /*@Nullable*/ File docFile = null;\n  private /*@Nullable*/ File outFile = null;\n\n  /** If true, then edit docFile in place (and docFile is non-null). */\n  private boolean inPlace = false;\n  /** If true, then output format is Javadoc. */\n  private boolean formatJavadoc = false;\n  private boolean includeClassDoc = false;\n\n  private RootDoc root;\n  private Options options;\n\n  public OptionsDoclet(RootDoc root, Options options) {\n    this.root = root;\n    this.options = options;\n  }\n\n  // Doclet-specific methods\n\n  /**\n   * Entry point for the doclet.\n   * @param root the root document\n   * @return true if processing completed without an error\n   */\n  public static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n      // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n      // returns a fully qualified name.  I do not know a good way to convert\n      // between these two name formats.  For now, we simply ignore inner\n      // classes.  This limitation can be removed when we figure out a better\n      // way to go from ClassDoc to Class<?>.\n      if (doc.containingClass() != null) {\n        continue;\n      }\n\n      Class<?> clazz;\n      try {\n        @SuppressWarnings(\"signature\") // Javadoc source code is not yet annotated\n        /*@BinaryNameForNonArray*/ String className = doc.qualifiedName();\n        clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n      } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return false;\n      }\n\n      if (needsInstantiation(clazz)) {\n        try {\n          Constructor<?> c = clazz.getDeclaredConstructor();\n          c.setAccessible(true);\n          objs.add(c.newInstance(new Object[0]));\n        } catch (Exception e) {\n          e.printStackTrace();\n          return false;\n        }\n      } else {\n        objs.add(clazz);\n      }\n    }\n\n    if (objs.isEmpty()) {\n      System.out.println(\"Error: no classes found\");\n      return false;\n    }\n\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n      System.out.println(\"Error: no @Option-annotated fields found\");\n      return false;\n    }\n\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n      o.write();\n    } catch (Exception e) {\n      e.printStackTrace();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Given a command-line option of this doclet, returns the number of\n   * arguments you must specify on the command line for the given option.\n   * Returns 0 if the argument is not recognized.  This method is\n   * automatically invoked.\n   *\n   * @param option the command-line option\n   * @return the number of command-line arguments needed when using the option\n   * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n   */\n  public static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n      System.out.printf(USAGE);\n      return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n      return 1;\n    }\n    if (option.equals(\"-docfile\")\n        || option.equals(\"-outfile\")\n        || option.equals(\"-format\")\n        || option.equals(\"-d\")) {\n      return 2;\n    }\n    return 0;\n  }\n\n  /**\n   * Tests the validity of command-line arguments passed to this doclet.\n   * Returns true if the option usage is valid, and false otherwise.  This\n   * method is automatically invoked.\n   *\n   * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n   * @param reporter where to report errors\n   * @return true iff the command-line options are valid\n   * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n   */\n  public static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        if (hasDocFile) {\n          reporter.printError(\"-docfile option specified twice\");\n          return false;\n        }\n        File f = new File(os[1]);\n        if (!f.exists()) {\n          reporter.printError(\"-docfile file not found: \" + os[1]);\n          return false;\n        }\n        docFile = os[1];\n        hasDocFile = true;\n      }\n      if (opt.equals(\"-outfile\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-outfile option specified twice\");\n          return false;\n        }\n        if (inPlace) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        outFile = os[1];\n        hasOutFile = true;\n      }\n      if (opt.equals(\"-i\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        inPlace = true;\n      }\n      if (opt.equals(\"-format\")) {\n        if (hasFormat) {\n          reporter.printError(\"-format option specified twice\");\n          return false;\n        }\n        if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n          reporter.printError(\"unrecognized output format: \" + os[1]);\n          return false;\n        }\n        hasFormat = true;\n      }\n      if (opt.equals(\"-d\")) {\n        if (hasDestDir) {\n          reporter.printError(\"-d specified twice\");\n          return false;\n        }\n        hasDestDir = true;\n      }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n      reporter.printError(\"docfile must be different from outfile\");\n      return false;\n    }\n    if (inPlace && docFile == null) {\n      reporter.printError(\"-i supplied but -docfile was not\");\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Set the options for this class based on command-line arguments given by\n   * RootDoc.options().\n   * @param options the command-line options to parse: a list of 1- or 2-element arrays\n   */\n  public void setOptions(String[][] options) {\n    String outFilename = null;\n    File destDir = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        this.docFile = new File(os[1]);\n      } else if (opt.equals(\"-d\")) {\n        destDir = new File(os[1]);\n      } else if (opt.equals(\"-outfile\")) {\n        outFilename = os[1];\n      } else if (opt.equals(\"-i\")) {\n        this.inPlace = true;\n      } else if (opt.equals(\"-format\")) {\n        if (os[1].equals(\"javadoc\")) {\n          setFormatJavadoc(true);\n        }\n      } else if (opt.equals(\"-classdoc\")) {\n        this.includeClassDoc = true;\n      } else if (opt.equals(\"-singledash\")) {\n        setUseSingleDash(true);\n      }\n    }\n    if (outFilename != null) {\n      if (destDir != null) {\n        this.outFile = new File(destDir, outFilename);\n      } else {\n        this.outFile = new File(outFilename);\n      }\n    }\n  }\n\n  /**\n   * Determine if a class needs to be instantiated in order to work properly\n   * with {@link Options}.\n   */\n  private static boolean needsInstantiation(Class<?> clazz) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.isAnnotationPresent(Option.class) && !Modifier.isStatic(f.getModifiers())) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // File IO methods\n\n  /**\n   * Write the output of this doclet to the correct file.\n   * @throws Exception if there is trouble\n   */\n  public void write() throws Exception {\n    PrintWriter out;\n    String output = output();\n\n    if (outFile != null) {\n      out = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));\n    } else if (inPlace) {\n      assert docFile != null\n          : \"@AssumeAssertion(nullness): dependent: docFile is non-null if inPlace is true\";\n      out = new PrintWriter(new BufferedWriter(new FileWriter(docFile)));\n    } else {\n      out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    }\n\n    out.println(output);\n    out.flush();\n    out.close();\n  }\n\n  /**\n   * Get the final output of this doclet.  The string returned by this method\n   * is the output seen by the user.\n   * @return the user-visible doclet output\n   * @throws Exception if there is trouble\n   */\n  public String output() throws Exception {\n    if (docFile == null) {\n      if (formatJavadoc) {\n        return optionsToJavadoc(0);\n      } else {\n        return optionsToHtml();\n      }\n    }\n\n    return newDocFileText();\n  }\n\n  /**\n   * Get the result of inserting the options documentation into the docfile.\n   */\n  /*@RequiresNonNull(\"docFile\")*/\n  private String newDocFileText() throws Exception {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    BufferedReader doc = new BufferedReader(new FileReader(docFile));\n    String docline;\n    boolean replacing = false;\n    boolean replaced_once = false;\n\n    while ((docline = doc.readLine()) != null) {\n      if (replacing) {\n        if (docline.trim().equals(endDelim)) {\n          replacing = false;\n        } else {\n          continue;\n        }\n      }\n\n      b.append(docline);\n\n      if (!replaced_once && docline.trim().equals(startDelim)) {\n        if (formatJavadoc) {\n          b.append(optionsToJavadoc(docline.indexOf('*')));\n        } else {\n          b.append(optionsToHtml());\n        }\n        replaced_once = true;\n        replacing = true;\n      }\n    }\n\n    doc.close();\n    return b.toString();\n  }\n\n  // HTML and Javadoc processing methods\n\n  /**\n   * Process each option and add in the Javadoc info.\n   */\n  public void processJavadoc() {\n    for (Options.OptionInfo oi : options.getOptions()) {\n      ClassDoc opt_doc = root.classNamed(oi.get_declaring_class().getName());\n      if (opt_doc != null) {\n        String nameWithUnderscores = oi.long_name.replace('-', '_');\n        for (FieldDoc fd : opt_doc.fields()) {\n          if (fd.name().equals(nameWithUnderscores)) {\n            // If Javadoc for field is unavailable, then use the @Option\n            // description in the documentation.\n            if (fd.getRawCommentText().length() == 0) {\n              // Input is a string rather than a Javadoc (HTML) comment so we\n              // must escape it.\n              oi.jdoc = StringEscapeUtils.escapeHtml4(oi.description);\n            } else if (formatJavadoc) {\n              oi.jdoc = fd.commentText();\n            } else {\n              oi.jdoc = javadocToHtml(fd);\n            }\n            break;\n          }\n        }\n      }\n      if (oi.base_type.isEnum()) {\n        processEnumJavadoc(oi);\n      }\n    }\n  }\n\n  /**\n   * Initializes {@link Options.OptionInfo.enum_jdoc} for the given\n   * <code>OptionInfo</code>.\n   */\n  private void processEnumJavadoc(Options.OptionInfo oi) {\n    Enum<?>[] constants = (Enum<?>[]) oi.base_type.getEnumConstants();\n    if (constants == null) {\n      return;\n    }\n\n    oi.enum_jdoc = new LinkedHashMap<String, String>();\n\n    for (Enum<?> constant : constants) {\n      assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n      oi.enum_jdoc.put(constant.name(), \"\");\n    }\n\n    ClassDoc enum_doc = root.classNamed(oi.base_type.getName());\n    if (enum_doc == null) {\n      return;\n    }\n\n    assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n    for (String name : oi.enum_jdoc.keySet()) {\n      for (FieldDoc fd : enum_doc.fields()) {\n        if (fd.name().equals(name)) {\n          if (formatJavadoc) {\n            oi.enum_jdoc.put(name, fd.commentText());\n          } else {\n            oi.enum_jdoc.put(name, javadocToHtml(fd));\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the HTML documentation for the underlying options instance.\n   * @return the HTML documentation for the underlying options instance\n   */\n  public String optionsToHtml() {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n\n    if (includeClassDoc && root.classes().length > 0) {\n      b.append(OptionsDoclet.javadocToHtml(root.classes()[0]));\n      b.append(\"<p>Command line options:</p>\");\n    }\n\n    b.append(\"<ul>\");\n    if (!options.isUsingGroups()) {\n      b.append(optionListToHtml(options.getOptions(), 2));\n    } else {\n      for (Options.OptionGroupInfo gi : options.getOptionGroups()) {\n        // Do not include groups without publicized options in output\n        if (!gi.any_publicized()) {\n          continue;\n        }\n\n        b.append(\n            \"  <li id=\\\"optiongroup:\"\n                + gi.name.replace(\" \", \"-\").replace(\"/\", \"-\")\n                + \"\\\">\"\n                + gi.name);\n        b.append(\"    <ul>\");\n        b.append(optionListToHtml(gi.optionList, 6));\n        b.append(\"    </ul>\");\n        b.append(\"  </li>\");\n      }\n    }\n    b.append(\"</ul>\");\n\n    for (Options.OptionInfo oi : options.getOptions()) {\n      if (oi.list != null && !oi.unpublicized) {\n        b.append(LIST_HELP);\n        break;\n      }\n    }\n\n    return b.toString();\n  }\n\n  /**\n   * Get the HTML documentation for the underlying options instance, formatted\n   * as a Javadoc comment.\n   * @param padding the padding to add in the Javadoc output\n   * @return the HTML documentation for the underlying options instance\n   */\n  public String optionsToJavadoc(int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    Scanner s = new Scanner(optionsToHtml());\n\n    while (s.hasNextLine()) {\n      StringBuilder bb = new StringBuilder();\n      bb.append(StringUtils.repeat(\" \", padding)).append(\"* \").append(s.nextLine());\n      b.append(bb);\n    }\n\n    return b.toString();\n  }\n\n  /**\n   * Get the HTML describing many options, formatted as an HTML list.\n   */\n  private String optionListToHtml(List<Options.OptionInfo> opt_list, int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    for (Options.OptionInfo oi : opt_list) {\n      if (oi.unpublicized) {\n        continue;\n      }\n      StringBuilder bb = new StringBuilder();\n      String optHtml = optionToHtml(oi, padding);\n      bb.append(StringUtils.repeat(\" \", padding));\n      bb.append(\"<li id=\\\"option:\" + oi.long_name + \"\\\">\").append(optHtml).append(\"</li>\");\n      b.append(bb);\n    }\n    return b.toString();\n  }\n\n  /**\n   * Get the line of HTML describing an Option.\n   * @param oi the option to describe\n   * @return HTML describing oi\n   */\n  public String optionToHtml(Options.OptionInfo oi, int padding) {\n    StringBuilder b = new StringBuilder();\n    Formatter f = new Formatter(b);\n    if (oi.short_name != null) {\n      f.format(\"<b>-%s</b> \", oi.short_name);\n    }\n    for (String a : oi.aliases) {\n      f.format(\"<b>%s</b> \", a);\n    }\n    String prefix = getUseSingleDash() ? \"-\" : \"--\";\n    f.format(\"<b>%s%s=</b><i>%s</i>\", prefix, oi.long_name, oi.type_name);\n    if (oi.list != null) {\n      b.append(\" <code>[+]</code>\");\n    }\n    f.format(\".%n \");\n    f.format(\"%s\", StringUtils.repeat(\" \", padding));\n\n    String jdoc = ((oi.jdoc == null) ? \"\" : oi.jdoc);\n    if (oi.no_doc_default || oi.default_str == null) {\n      f.format(\"%s\", jdoc);\n    } else {\n      String default_str = \"default \" + oi.default_str;\n      // The default string must be HTML-escaped since it comes from a string\n      // rather than a Javadoc comment.\n      String suffix = \"\";\n      if (jdoc.endsWith(\"</p>\")) {\n        suffix = \"</p>\";\n        jdoc = jdoc.substring(0, jdoc.length() - suffix.length());\n      }\n      f.format(\"%s [%s]%s\", jdoc, StringEscapeUtils.escapeHtml4(default_str), suffix);\n    }\n    if (oi.base_type.isEnum()) {\n      b.append(\"<ul>\");\n      assert oi.enum_jdoc != null\n          : \"@AssumeAssertion(nullness): dependent: non-null if oi.base_type is an enum\";\n      for (Map.Entry<String, String> entry : oi.enum_jdoc.entrySet()) {\n        b.append(\"<li><b>\").append(entry.getKey()).append(\"</b>\");\n        if (entry.getValue().length() != 0) {\n          b.append(\" \").append(entry.getValue());\n        }\n        b.append(\"</li>\");\n      }\n      b.append(\"</ul>\");\n    }\n    return b.toString();\n  }\n\n  /**\n   * Replace the @link tags and block @see tags in a Javadoc comment with\n   * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n   * comment while still being presentable. <p>\n   *\n   * This is only a temporary solution.  Ideally, @link/@see tags would be\n   * converted to HTML links that point to actual documentation.\n   *\n   * @param doc a Javadoc comment to convert to HTML\n   * @return HTML version of doc\n   */\n  public static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n      if (tag instanceof SeeTag) {\n        b.append(\"<code>\" + tag.text() + \"</code>\");\n      } else {\n        b.append(tag.text());\n      }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n      b.append(\" See: \");\n      {\n        StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n        for (SeeTag tag : seetags) {\n          bb.append(\"<code>\" + tag.text() + \"</code>\");\n        }\n        b.append(bb);\n      }\n      b.append(\".\");\n    }\n    return b.toString();\n  }\n\n  // Getters and Setters\n\n  public boolean getFormatJavadoc() {\n    return formatJavadoc;\n  }\n\n  public void setFormatJavadoc(boolean val) {\n    if (val && !formatJavadoc) {\n      startDelim = \"* \" + startDelim;\n      endDelim = \"* \" + endDelim;\n    } else if (!val && formatJavadoc) {\n      startDelim = StringUtils.removeStart(\"* \", startDelim);\n      endDelim = StringUtils.removeStart(\"* \", endDelim);\n    }\n    this.formatJavadoc = val;\n  }\n\n  public boolean getUseSingleDash() {\n    return options.isUsingSingleDash();\n  }\n\n  public void setUseSingleDash(boolean val) {\n    options.use_single_dash(true);\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "8", "int" ], [ "\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\"", "String" ] ],
  "tokensMethodArguments" : [ [ "option", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "optionsToJavadoc", "plume", "OptionsDoclet", "public String optionsToJavadoc(int padding)" ], [ "output", "plume", "OptionsDoclet", "public String output() throws Exception" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getFormatJavadoc", "plume", "OptionsDoclet", "public boolean getFormatJavadoc()" ], [ "getUseSingleDash", "plume", "OptionsDoclet", "public boolean getUseSingleDash()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "optionToHtml", "plume", "OptionsDoclet", "public String optionToHtml(Options.OptionInfo oi, int padding)" ], [ "optionsToHtml", "plume", "OptionsDoclet", "public String optionsToHtml()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "length", "java.lang", "String", "public int length()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10240,
  "oracle" : "Arrays.stream(options).allMatch(jdVar -> jdVar.length <= 2);",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "OptionsDoclet",
  "javadocTag" : "@param options the command-line options to parse: a list of 1- or 2-element arrays",
  "methodJavadoc" : "    /**\n   * Set the options for this class based on command-line arguments given by\n   * RootDoc.options().\n   * @param options the command-line options to parse: a list of 1- or 2-element arrays\n   */",
  "methodSourceCode" : "public void setOptions(String[][] options){\n    String outFilename = null;\n    File destDir = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            this.docFile = new File(os[1]);\n        } else if (opt.equals(\"-d\")) {\n            destDir = new File(os[1]);\n        } else if (opt.equals(\"-outfile\")) {\n            outFilename = os[1];\n        } else if (opt.equals(\"-i\")) {\n            this.inPlace = true;\n        } else if (opt.equals(\"-format\")) {\n            if (os[1].equals(\"javadoc\")) {\n                setFormatJavadoc(true);\n            }\n        } else if (opt.equals(\"-classdoc\")) {\n            this.includeClassDoc = true;\n        } else if (opt.equals(\"-singledash\")) {\n            setUseSingleDash(true);\n        }\n    }\n    if (outFilename != null) {\n        if (destDir != null) {\n            this.outFile = new File(destDir, outFilename);\n        } else {\n            this.outFile = new File(outFilename);\n        }\n    }\n}",
  "classJavadoc" : "/**\n * Generates HTML documentation of command-line options.  Works with the\n * {@link plume.Options} class.\n * <p>\n *\n * <b>Usage</b> <p>\n * This doclet is typically invoked with:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet [doclet options] [java files]</pre>\n * <p>\n *\n * <b>Doclet Options</b> <p>\n * The following doclet options are supported:\n * <ul>\n * <li> <b>-docfile</b> <i>file</i> When specified, the output of this doclet\n * is the result of replacing everything between the two lines\n * <pre>&lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n * and\n * <pre>&lt;!-- end options doc --&gt;</pre>\n * in <i>file</i> with the options documentation.  This can be used for\n * inserting option documentation into an existing manual.  The existing\n * docfile is not modified; output goes to the <code>-outfile</code>\n * argument, or to standard out.\n *\n * <li> <b>-outfile</b> <i>file</i> The destination for the output (the default\n * is standard out).  If both <code>-outfile</code> and <code>-docfile</code>\n * are specified, they must be different. When <code>-d</code> is used, the\n * output is written to a file with the given name relative to that destination\n * directory.\n *\n * <li> <b>-d</b> <i>directory</i> The destination directory for the output file.\n * Only used if <code>-outfile</code> is used, in which case, the file is\n * written in this directory. Otherwise, this option is ignored.\n *\n * <li> <b>-i</b> Specifies that the docfile should be edited in-place.  This\n * option can only be used if the <code>-docfile</code> option is used, and\n * may not be used at the same time as the <code>-outfile</code> option.\n *\n * <li> <b>-format</b> <i>format</i> This option sets the output format of this\n * doclet.  Currently, the following values for <i>format</i> are supported:\n * <ul>\n *   <li> <b>javadoc</b> When this format is specified, the output of this\n *   doclet is formatted as a Javadoc comment.  This is useful for including\n *   option documentation inside Java source code.  When this format is used\n *   with the <code>-docfile</code> option, the generated documentation is\n *   inserted between the lines\n *   <pre>* &lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n *   and\n *   <pre>* &lt;!-- end options doc --&gt;</pre>\n *   using the same indentation.  Inline <code>@link</code> and\n *   <code>@see</code> tags in the Javadoc input are left untouched.\n *\n *   <li> <b>html</b> This format outputs HTML for general-purpose use, meaning\n *   inline <code>@link</code> and <code>@see</code> tags in the Javadoc input\n *   are suitably replaced.  This is the default output format and does not\n *   need to be specified explicitly.\n * </ul>\n *\n * <li> <b>-classdoc</b> When specified, the output of this doclet includes the\n * class documentation of the first class specified on the command-line.\n *\n * <li> <b>-singledash</b> When specified, <code>use_single_dash(true)</code> is\n * called on the underlying instance of Options used to generate documentation.\n * See {@link plume.Options#use_single_dash(boolean)}.\n * </ul>\n * <p>\n *\n * <b>Examples</b> <p>\n * To update the Javarifier HTML manual with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile javarifier.html src/javarifier/Main.java</pre>\n * <p>\n *\n * To update the class Javadoc for plume.Lookup with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile Lookup.java -format javadoc Lookup.java</pre>\n * <p>\n *\n * For a more extensive example, see file <code>java/Makefile</code> in\n * plume-lib itself.\n * <p>\n *\n * <b>Requirements</b> <p>\n * Classes passed to OptionsDoclet that have <code>@</code>{@link Option} annotations on\n * non-static fields should have a nullary (no-argument) constructor.  The\n * nullary constructor may be private or public.  This is required because an\n * object instance is needed to get the default value of a non-static field.  It\n * is cleaner to require a nullary constructor instead of trying to guess\n * arguments to pass to another constructor. <p>\n *\n * <b>Hiding default value strings</b> <p>\n * By default, the documentation generated by OptionsDoclet includes a default\n * value string for each option in square brackets after the option's\n * description, similar to the usage messages generated by {@link\n * plume.Options#usage(String...)}.  The {@link plume.Option#noDocDefault}\n * field in the <code>@Option</code> annotation can be set to <code>true</code>\n * to omit the default value string from the generated documentation for that\n * option. <p>\n *\n * Omitting the generated default value string is useful for options that have\n * system-dependent defaults.  Such options are not an issue for usage messages\n * that are generated at runtime.  However, system dependent defaults do pose\n * a problem for static documentation, which is rarely regenerated and meant to\n * apply to all users.  Consider the following <code>@Option</code>-annotated\n * field:\n * <pre>\n * &#64;Option(value=\"&lt;timezone&gt; Set the time zone\")\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * The default value for <code>timezone</code> depends on the system's timezone\n * setting.  HTML documentation of this option generated in Chicago would not\n * apply to a user in New York.  To work around this problem, the\n * default value should be hidden; instead the Javadoc for this field\n * should indicate a special default as follows.\n * <pre>\n * &#47;**\n *  * &lt;other stuff...&gt;  This option defaults to the system timezone.\n *  *&#47;\n * &#64;Option(value=\"&lt;timezone&gt; Set the timezone\", noDocDefault=true)\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * This keeps the documentation system-agnostic. <p>\n *\n * <b>Caveats</b> <p>\n * The generated HTML documentation includes unpublicized option groups but not\n * <code>@Unpublicized</code> options.  Option groups which contain only\n * <code>@Unpublicized</code> options are not included in the output at all. <p>\n *\n * <b>Troubleshooting</b> <p>\n * If you get an error such as \"<code>ARGH! @Option</code>\", then you are using a\n * buggy version of gjdoc, the GNU Classpath implementation of Javadoc.\n * To avoid the problem, upgrade or use a different Javadoc implementation.\n *\n * @see plume.Option\n * @see plume.Options\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n */",
  "classSourceCode" : "// The five files\n//   Option.java\n//   OptionGroup.java\n//   Options.java\n//   Unpublicized.java\n//   OptionsDoclet.java\n// together comprise the implementation of command-line processing.\n\npackage plume;\n\nimport com.sun.javadoc.ClassDoc;\nimport com.sun.javadoc.Doc;\nimport com.sun.javadoc.DocErrorReporter;\nimport com.sun.javadoc.FieldDoc;\nimport com.sun.javadoc.RootDoc;\nimport com.sun.javadoc.SeeTag;\nimport com.sun.javadoc.Tag;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Formatter;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/*>>>\nimport org.checkerframework.checker.formatter.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n/**\n * Generates HTML documentation of command-line options.  Works with the\n * {@link plume.Options} class.\n * <p>\n *\n * <b>Usage</b> <p>\n * This doclet is typically invoked with:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet [doclet options] [java files]</pre>\n * <p>\n *\n * <b>Doclet Options</b> <p>\n * The following doclet options are supported:\n * <ul>\n * <li> <b>-docfile</b> <i>file</i> When specified, the output of this doclet\n * is the result of replacing everything between the two lines\n * <pre>&lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n * and\n * <pre>&lt;!-- end options doc --&gt;</pre>\n * in <i>file</i> with the options documentation.  This can be used for\n * inserting option documentation into an existing manual.  The existing\n * docfile is not modified; output goes to the <code>-outfile</code>\n * argument, or to standard out.\n *\n * <li> <b>-outfile</b> <i>file</i> The destination for the output (the default\n * is standard out).  If both <code>-outfile</code> and <code>-docfile</code>\n * are specified, they must be different. When <code>-d</code> is used, the\n * output is written to a file with the given name relative to that destination\n * directory.\n *\n * <li> <b>-d</b> <i>directory</i> The destination directory for the output file.\n * Only used if <code>-outfile</code> is used, in which case, the file is\n * written in this directory. Otherwise, this option is ignored.\n *\n * <li> <b>-i</b> Specifies that the docfile should be edited in-place.  This\n * option can only be used if the <code>-docfile</code> option is used, and\n * may not be used at the same time as the <code>-outfile</code> option.\n *\n * <li> <b>-format</b> <i>format</i> This option sets the output format of this\n * doclet.  Currently, the following values for <i>format</i> are supported:\n * <ul>\n *   <li> <b>javadoc</b> When this format is specified, the output of this\n *   doclet is formatted as a Javadoc comment.  This is useful for including\n *   option documentation inside Java source code.  When this format is used\n *   with the <code>-docfile</code> option, the generated documentation is\n *   inserted between the lines\n *   <pre>* &lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n *   and\n *   <pre>* &lt;!-- end options doc --&gt;</pre>\n *   using the same indentation.  Inline <code>@link</code> and\n *   <code>@see</code> tags in the Javadoc input are left untouched.\n *\n *   <li> <b>html</b> This format outputs HTML for general-purpose use, meaning\n *   inline <code>@link</code> and <code>@see</code> tags in the Javadoc input\n *   are suitably replaced.  This is the default output format and does not\n *   need to be specified explicitly.\n * </ul>\n *\n * <li> <b>-classdoc</b> When specified, the output of this doclet includes the\n * class documentation of the first class specified on the command-line.\n *\n * <li> <b>-singledash</b> When specified, <code>use_single_dash(true)</code> is\n * called on the underlying instance of Options used to generate documentation.\n * See {@link plume.Options#use_single_dash(boolean)}.\n * </ul>\n * <p>\n *\n * <b>Examples</b> <p>\n * To update the Javarifier HTML manual with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile javarifier.html src/javarifier/Main.java</pre>\n * <p>\n *\n * To update the class Javadoc for plume.Lookup with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile Lookup.java -format javadoc Lookup.java</pre>\n * <p>\n *\n * For a more extensive example, see file <code>java/Makefile</code> in\n * plume-lib itself.\n * <p>\n *\n * <b>Requirements</b> <p>\n * Classes passed to OptionsDoclet that have <code>@</code>{@link Option} annotations on\n * non-static fields should have a nullary (no-argument) constructor.  The\n * nullary constructor may be private or public.  This is required because an\n * object instance is needed to get the default value of a non-static field.  It\n * is cleaner to require a nullary constructor instead of trying to guess\n * arguments to pass to another constructor. <p>\n *\n * <b>Hiding default value strings</b> <p>\n * By default, the documentation generated by OptionsDoclet includes a default\n * value string for each option in square brackets after the option's\n * description, similar to the usage messages generated by {@link\n * plume.Options#usage(String...)}.  The {@link plume.Option#noDocDefault}\n * field in the <code>@Option</code> annotation can be set to <code>true</code>\n * to omit the default value string from the generated documentation for that\n * option. <p>\n *\n * Omitting the generated default value string is useful for options that have\n * system-dependent defaults.  Such options are not an issue for usage messages\n * that are generated at runtime.  However, system dependent defaults do pose\n * a problem for static documentation, which is rarely regenerated and meant to\n * apply to all users.  Consider the following <code>@Option</code>-annotated\n * field:\n * <pre>\n * &#64;Option(value=\"&lt;timezone&gt; Set the time zone\")\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * The default value for <code>timezone</code> depends on the system's timezone\n * setting.  HTML documentation of this option generated in Chicago would not\n * apply to a user in New York.  To work around this problem, the\n * default value should be hidden; instead the Javadoc for this field\n * should indicate a special default as follows.\n * <pre>\n * &#47;**\n *  * &lt;other stuff...&gt;  This option defaults to the system timezone.\n *  *&#47;\n * &#64;Option(value=\"&lt;timezone&gt; Set the timezone\", noDocDefault=true)\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * This keeps the documentation system-agnostic. <p>\n *\n * <b>Caveats</b> <p>\n * The generated HTML documentation includes unpublicized option groups but not\n * <code>@Unpublicized</code> options.  Option groups which contain only\n * <code>@Unpublicized</code> options are not included in the output at all. <p>\n *\n * <b>Troubleshooting</b> <p>\n * If you get an error such as \"<code>ARGH! @Option</code>\", then you are using a\n * buggy version of gjdoc, the GNU Classpath implementation of Javadoc.\n * To avoid the problem, upgrade or use a different Javadoc implementation.\n *\n * @see plume.Option\n * @see plume.Options\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n */\n\n// This doesn't itself use plume.Options for its command-line option\n// processing because a Doclet is required to implement the optionLength\n// and validOptions methods.\npublic class OptionsDoclet {\n\n  private static String eol = System.getProperty(\"line.separator\");\n\n  private final static /*@Format({})*/ String USAGE =\n      \"Provided by Options doclet:%n\"\n          + \"-docfile <file>        Specify file into which options documentation is inserted%n\"\n          + \"-outfile <file>        Specify destination for resulting output%n\"\n          + \"-d <directory>         Destination directory for -outfile%n\"\n          + \"-i                     Edit the docfile in-place%n\"\n          + \"-format javadoc        Format output as a Javadoc comment%n\"\n          + \"-classdoc              Include 'main' class documentation in output%n\"\n          + \"-singledash            Use single dashes for long options (see plume.Options)%n\"\n          + \"See the OptionsDoclet documentation for more details.%n\";\n\n  private static final String LIST_HELP =\n      \"<code>[+]</code> marked option can be specified multiple times\";\n\n  private String startDelim = \"<!-- start options doc (DO NOT EDIT BY HAND) -->\";\n  private String endDelim = \"<!-- end options doc -->\";\n\n  private /*@Nullable*/ File docFile = null;\n  private /*@Nullable*/ File outFile = null;\n\n  /** If true, then edit docFile in place (and docFile is non-null). */\n  private boolean inPlace = false;\n  /** If true, then output format is Javadoc. */\n  private boolean formatJavadoc = false;\n  private boolean includeClassDoc = false;\n\n  private RootDoc root;\n  private Options options;\n\n  public OptionsDoclet(RootDoc root, Options options) {\n    this.root = root;\n    this.options = options;\n  }\n\n  // Doclet-specific methods\n\n  /**\n   * Entry point for the doclet.\n   * @param root the root document\n   * @return true if processing completed without an error\n   */\n  public static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n      // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n      // returns a fully qualified name.  I do not know a good way to convert\n      // between these two name formats.  For now, we simply ignore inner\n      // classes.  This limitation can be removed when we figure out a better\n      // way to go from ClassDoc to Class<?>.\n      if (doc.containingClass() != null) {\n        continue;\n      }\n\n      Class<?> clazz;\n      try {\n        @SuppressWarnings(\"signature\") // Javadoc source code is not yet annotated\n        /*@BinaryNameForNonArray*/ String className = doc.qualifiedName();\n        clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n      } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return false;\n      }\n\n      if (needsInstantiation(clazz)) {\n        try {\n          Constructor<?> c = clazz.getDeclaredConstructor();\n          c.setAccessible(true);\n          objs.add(c.newInstance(new Object[0]));\n        } catch (Exception e) {\n          e.printStackTrace();\n          return false;\n        }\n      } else {\n        objs.add(clazz);\n      }\n    }\n\n    if (objs.isEmpty()) {\n      System.out.println(\"Error: no classes found\");\n      return false;\n    }\n\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n      System.out.println(\"Error: no @Option-annotated fields found\");\n      return false;\n    }\n\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n      o.write();\n    } catch (Exception e) {\n      e.printStackTrace();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Given a command-line option of this doclet, returns the number of\n   * arguments you must specify on the command line for the given option.\n   * Returns 0 if the argument is not recognized.  This method is\n   * automatically invoked.\n   *\n   * @param option the command-line option\n   * @return the number of command-line arguments needed when using the option\n   * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n   */\n  public static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n      System.out.printf(USAGE);\n      return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n      return 1;\n    }\n    if (option.equals(\"-docfile\")\n        || option.equals(\"-outfile\")\n        || option.equals(\"-format\")\n        || option.equals(\"-d\")) {\n      return 2;\n    }\n    return 0;\n  }\n\n  /**\n   * Tests the validity of command-line arguments passed to this doclet.\n   * Returns true if the option usage is valid, and false otherwise.  This\n   * method is automatically invoked.\n   *\n   * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n   * @param reporter where to report errors\n   * @return true iff the command-line options are valid\n   * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n   */\n  public static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        if (hasDocFile) {\n          reporter.printError(\"-docfile option specified twice\");\n          return false;\n        }\n        File f = new File(os[1]);\n        if (!f.exists()) {\n          reporter.printError(\"-docfile file not found: \" + os[1]);\n          return false;\n        }\n        docFile = os[1];\n        hasDocFile = true;\n      }\n      if (opt.equals(\"-outfile\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-outfile option specified twice\");\n          return false;\n        }\n        if (inPlace) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        outFile = os[1];\n        hasOutFile = true;\n      }\n      if (opt.equals(\"-i\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        inPlace = true;\n      }\n      if (opt.equals(\"-format\")) {\n        if (hasFormat) {\n          reporter.printError(\"-format option specified twice\");\n          return false;\n        }\n        if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n          reporter.printError(\"unrecognized output format: \" + os[1]);\n          return false;\n        }\n        hasFormat = true;\n      }\n      if (opt.equals(\"-d\")) {\n        if (hasDestDir) {\n          reporter.printError(\"-d specified twice\");\n          return false;\n        }\n        hasDestDir = true;\n      }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n      reporter.printError(\"docfile must be different from outfile\");\n      return false;\n    }\n    if (inPlace && docFile == null) {\n      reporter.printError(\"-i supplied but -docfile was not\");\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Set the options for this class based on command-line arguments given by\n   * RootDoc.options().\n   * @param options the command-line options to parse: a list of 1- or 2-element arrays\n   */\n  public void setOptions(String[][] options) {\n    String outFilename = null;\n    File destDir = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        this.docFile = new File(os[1]);\n      } else if (opt.equals(\"-d\")) {\n        destDir = new File(os[1]);\n      } else if (opt.equals(\"-outfile\")) {\n        outFilename = os[1];\n      } else if (opt.equals(\"-i\")) {\n        this.inPlace = true;\n      } else if (opt.equals(\"-format\")) {\n        if (os[1].equals(\"javadoc\")) {\n          setFormatJavadoc(true);\n        }\n      } else if (opt.equals(\"-classdoc\")) {\n        this.includeClassDoc = true;\n      } else if (opt.equals(\"-singledash\")) {\n        setUseSingleDash(true);\n      }\n    }\n    if (outFilename != null) {\n      if (destDir != null) {\n        this.outFile = new File(destDir, outFilename);\n      } else {\n        this.outFile = new File(outFilename);\n      }\n    }\n  }\n\n  /**\n   * Determine if a class needs to be instantiated in order to work properly\n   * with {@link Options}.\n   */\n  private static boolean needsInstantiation(Class<?> clazz) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.isAnnotationPresent(Option.class) && !Modifier.isStatic(f.getModifiers())) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // File IO methods\n\n  /**\n   * Write the output of this doclet to the correct file.\n   * @throws Exception if there is trouble\n   */\n  public void write() throws Exception {\n    PrintWriter out;\n    String output = output();\n\n    if (outFile != null) {\n      out = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));\n    } else if (inPlace) {\n      assert docFile != null\n          : \"@AssumeAssertion(nullness): dependent: docFile is non-null if inPlace is true\";\n      out = new PrintWriter(new BufferedWriter(new FileWriter(docFile)));\n    } else {\n      out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    }\n\n    out.println(output);\n    out.flush();\n    out.close();\n  }\n\n  /**\n   * Get the final output of this doclet.  The string returned by this method\n   * is the output seen by the user.\n   * @return the user-visible doclet output\n   * @throws Exception if there is trouble\n   */\n  public String output() throws Exception {\n    if (docFile == null) {\n      if (formatJavadoc) {\n        return optionsToJavadoc(0);\n      } else {\n        return optionsToHtml();\n      }\n    }\n\n    return newDocFileText();\n  }\n\n  /**\n   * Get the result of inserting the options documentation into the docfile.\n   */\n  /*@RequiresNonNull(\"docFile\")*/\n  private String newDocFileText() throws Exception {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    BufferedReader doc = new BufferedReader(new FileReader(docFile));\n    String docline;\n    boolean replacing = false;\n    boolean replaced_once = false;\n\n    while ((docline = doc.readLine()) != null) {\n      if (replacing) {\n        if (docline.trim().equals(endDelim)) {\n          replacing = false;\n        } else {\n          continue;\n        }\n      }\n\n      b.append(docline);\n\n      if (!replaced_once && docline.trim().equals(startDelim)) {\n        if (formatJavadoc) {\n          b.append(optionsToJavadoc(docline.indexOf('*')));\n        } else {\n          b.append(optionsToHtml());\n        }\n        replaced_once = true;\n        replacing = true;\n      }\n    }\n\n    doc.close();\n    return b.toString();\n  }\n\n  // HTML and Javadoc processing methods\n\n  /**\n   * Process each option and add in the Javadoc info.\n   */\n  public void processJavadoc() {\n    for (Options.OptionInfo oi : options.getOptions()) {\n      ClassDoc opt_doc = root.classNamed(oi.get_declaring_class().getName());\n      if (opt_doc != null) {\n        String nameWithUnderscores = oi.long_name.replace('-', '_');\n        for (FieldDoc fd : opt_doc.fields()) {\n          if (fd.name().equals(nameWithUnderscores)) {\n            // If Javadoc for field is unavailable, then use the @Option\n            // description in the documentation.\n            if (fd.getRawCommentText().length() == 0) {\n              // Input is a string rather than a Javadoc (HTML) comment so we\n              // must escape it.\n              oi.jdoc = StringEscapeUtils.escapeHtml4(oi.description);\n            } else if (formatJavadoc) {\n              oi.jdoc = fd.commentText();\n            } else {\n              oi.jdoc = javadocToHtml(fd);\n            }\n            break;\n          }\n        }\n      }\n      if (oi.base_type.isEnum()) {\n        processEnumJavadoc(oi);\n      }\n    }\n  }\n\n  /**\n   * Initializes {@link Options.OptionInfo.enum_jdoc} for the given\n   * <code>OptionInfo</code>.\n   */\n  private void processEnumJavadoc(Options.OptionInfo oi) {\n    Enum<?>[] constants = (Enum<?>[]) oi.base_type.getEnumConstants();\n    if (constants == null) {\n      return;\n    }\n\n    oi.enum_jdoc = new LinkedHashMap<String, String>();\n\n    for (Enum<?> constant : constants) {\n      assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n      oi.enum_jdoc.put(constant.name(), \"\");\n    }\n\n    ClassDoc enum_doc = root.classNamed(oi.base_type.getName());\n    if (enum_doc == null) {\n      return;\n    }\n\n    assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n    for (String name : oi.enum_jdoc.keySet()) {\n      for (FieldDoc fd : enum_doc.fields()) {\n        if (fd.name().equals(name)) {\n          if (formatJavadoc) {\n            oi.enum_jdoc.put(name, fd.commentText());\n          } else {\n            oi.enum_jdoc.put(name, javadocToHtml(fd));\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the HTML documentation for the underlying options instance.\n   * @return the HTML documentation for the underlying options instance\n   */\n  public String optionsToHtml() {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n\n    if (includeClassDoc && root.classes().length > 0) {\n      b.append(OptionsDoclet.javadocToHtml(root.classes()[0]));\n      b.append(\"<p>Command line options:</p>\");\n    }\n\n    b.append(\"<ul>\");\n    if (!options.isUsingGroups()) {\n      b.append(optionListToHtml(options.getOptions(), 2));\n    } else {\n      for (Options.OptionGroupInfo gi : options.getOptionGroups()) {\n        // Do not include groups without publicized options in output\n        if (!gi.any_publicized()) {\n          continue;\n        }\n\n        b.append(\n            \"  <li id=\\\"optiongroup:\"\n                + gi.name.replace(\" \", \"-\").replace(\"/\", \"-\")\n                + \"\\\">\"\n                + gi.name);\n        b.append(\"    <ul>\");\n        b.append(optionListToHtml(gi.optionList, 6));\n        b.append(\"    </ul>\");\n        b.append(\"  </li>\");\n      }\n    }\n    b.append(\"</ul>\");\n\n    for (Options.OptionInfo oi : options.getOptions()) {\n      if (oi.list != null && !oi.unpublicized) {\n        b.append(LIST_HELP);\n        break;\n      }\n    }\n\n    return b.toString();\n  }\n\n  /**\n   * Get the HTML documentation for the underlying options instance, formatted\n   * as a Javadoc comment.\n   * @param padding the padding to add in the Javadoc output\n   * @return the HTML documentation for the underlying options instance\n   */\n  public String optionsToJavadoc(int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    Scanner s = new Scanner(optionsToHtml());\n\n    while (s.hasNextLine()) {\n      StringBuilder bb = new StringBuilder();\n      bb.append(StringUtils.repeat(\" \", padding)).append(\"* \").append(s.nextLine());\n      b.append(bb);\n    }\n\n    return b.toString();\n  }\n\n  /**\n   * Get the HTML describing many options, formatted as an HTML list.\n   */\n  private String optionListToHtml(List<Options.OptionInfo> opt_list, int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    for (Options.OptionInfo oi : opt_list) {\n      if (oi.unpublicized) {\n        continue;\n      }\n      StringBuilder bb = new StringBuilder();\n      String optHtml = optionToHtml(oi, padding);\n      bb.append(StringUtils.repeat(\" \", padding));\n      bb.append(\"<li id=\\\"option:\" + oi.long_name + \"\\\">\").append(optHtml).append(\"</li>\");\n      b.append(bb);\n    }\n    return b.toString();\n  }\n\n  /**\n   * Get the line of HTML describing an Option.\n   * @param oi the option to describe\n   * @return HTML describing oi\n   */\n  public String optionToHtml(Options.OptionInfo oi, int padding) {\n    StringBuilder b = new StringBuilder();\n    Formatter f = new Formatter(b);\n    if (oi.short_name != null) {\n      f.format(\"<b>-%s</b> \", oi.short_name);\n    }\n    for (String a : oi.aliases) {\n      f.format(\"<b>%s</b> \", a);\n    }\n    String prefix = getUseSingleDash() ? \"-\" : \"--\";\n    f.format(\"<b>%s%s=</b><i>%s</i>\", prefix, oi.long_name, oi.type_name);\n    if (oi.list != null) {\n      b.append(\" <code>[+]</code>\");\n    }\n    f.format(\".%n \");\n    f.format(\"%s\", StringUtils.repeat(\" \", padding));\n\n    String jdoc = ((oi.jdoc == null) ? \"\" : oi.jdoc);\n    if (oi.no_doc_default || oi.default_str == null) {\n      f.format(\"%s\", jdoc);\n    } else {\n      String default_str = \"default \" + oi.default_str;\n      // The default string must be HTML-escaped since it comes from a string\n      // rather than a Javadoc comment.\n      String suffix = \"\";\n      if (jdoc.endsWith(\"</p>\")) {\n        suffix = \"</p>\";\n        jdoc = jdoc.substring(0, jdoc.length() - suffix.length());\n      }\n      f.format(\"%s [%s]%s\", jdoc, StringEscapeUtils.escapeHtml4(default_str), suffix);\n    }\n    if (oi.base_type.isEnum()) {\n      b.append(\"<ul>\");\n      assert oi.enum_jdoc != null\n          : \"@AssumeAssertion(nullness): dependent: non-null if oi.base_type is an enum\";\n      for (Map.Entry<String, String> entry : oi.enum_jdoc.entrySet()) {\n        b.append(\"<li><b>\").append(entry.getKey()).append(\"</b>\");\n        if (entry.getValue().length() != 0) {\n          b.append(\" \").append(entry.getValue());\n        }\n        b.append(\"</li>\");\n      }\n      b.append(\"</ul>\");\n    }\n    return b.toString();\n  }\n\n  /**\n   * Replace the @link tags and block @see tags in a Javadoc comment with\n   * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n   * comment while still being presentable. <p>\n   *\n   * This is only a temporary solution.  Ideally, @link/@see tags would be\n   * converted to HTML links that point to actual documentation.\n   *\n   * @param doc a Javadoc comment to convert to HTML\n   * @return HTML version of doc\n   */\n  public static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n      if (tag instanceof SeeTag) {\n        b.append(\"<code>\" + tag.text() + \"</code>\");\n      } else {\n        b.append(tag.text());\n      }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n      b.append(\" See: \");\n      {\n        StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n        for (SeeTag tag : seetags) {\n          bb.append(\"<code>\" + tag.text() + \"</code>\");\n        }\n        b.append(bb);\n      }\n      b.append(\".\");\n    }\n    return b.toString();\n  }\n\n  // Getters and Setters\n\n  public boolean getFormatJavadoc() {\n    return formatJavadoc;\n  }\n\n  public void setFormatJavadoc(boolean val) {\n    if (val && !formatJavadoc) {\n      startDelim = \"* \" + startDelim;\n      endDelim = \"* \" + endDelim;\n    } else if (!val && formatJavadoc) {\n      startDelim = StringUtils.removeStart(\"* \", startDelim);\n      endDelim = StringUtils.removeStart(\"* \", endDelim);\n    }\n    this.formatJavadoc = val;\n  }\n\n  public boolean getUseSingleDash() {\n    return options.isUsingSingleDash();\n  }\n\n  public void setUseSingleDash(boolean val) {\n    options.use_single_dash(true);\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "options", "", "String[][]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "output", "plume", "OptionsDoclet", "public String output() throws Exception" ], [ "optionsToJavadoc", "plume", "OptionsDoclet", "public String optionsToJavadoc(int padding)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "optionToHtml", "plume", "OptionsDoclet", "public String optionToHtml(Options.OptionInfo oi, int padding)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getFormatJavadoc", "plume", "OptionsDoclet", "public boolean getFormatJavadoc()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getUseSingleDash", "plume", "OptionsDoclet", "public boolean getUseSingleDash()" ], [ "optionsToHtml", "plume", "OptionsDoclet", "public String optionsToHtml()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "", "java.lang.String[][]", "public boolean equals(Object);" ], [ "toString", "", "java.lang.String[][]", "public String toString()" ], [ "hashCode", "", "java.lang.String[][]", "public native int hashCode()" ], [ "getClass", "", "java.lang.String[][]", "public final native Class getClass();" ], [ "clone", "", "java.lang.String[][]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "java.lang", "String[][]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10241,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "OptionsDoclet",
  "javadocTag" : "@throws Exception if there is trouble",
  "methodJavadoc" : "    /**\n   * Write the output of this doclet to the correct file.\n   * @throws Exception if there is trouble\n   */",
  "methodSourceCode" : "public void write() throws Exception{\n    PrintWriter out;\n    String output = output();\n    if (outFile != null) {\n        out = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));\n    } else if (inPlace) {\n        assert docFile != null : \"@AssumeAssertion(nullness): dependent: docFile is non-null if inPlace is true\";\n        out = new PrintWriter(new BufferedWriter(new FileWriter(docFile)));\n    } else {\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    }\n    out.println(output);\n    out.flush();\n    out.close();\n}",
  "classJavadoc" : "/**\n * Generates HTML documentation of command-line options.  Works with the\n * {@link plume.Options} class.\n * <p>\n *\n * <b>Usage</b> <p>\n * This doclet is typically invoked with:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet [doclet options] [java files]</pre>\n * <p>\n *\n * <b>Doclet Options</b> <p>\n * The following doclet options are supported:\n * <ul>\n * <li> <b>-docfile</b> <i>file</i> When specified, the output of this doclet\n * is the result of replacing everything between the two lines\n * <pre>&lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n * and\n * <pre>&lt;!-- end options doc --&gt;</pre>\n * in <i>file</i> with the options documentation.  This can be used for\n * inserting option documentation into an existing manual.  The existing\n * docfile is not modified; output goes to the <code>-outfile</code>\n * argument, or to standard out.\n *\n * <li> <b>-outfile</b> <i>file</i> The destination for the output (the default\n * is standard out).  If both <code>-outfile</code> and <code>-docfile</code>\n * are specified, they must be different. When <code>-d</code> is used, the\n * output is written to a file with the given name relative to that destination\n * directory.\n *\n * <li> <b>-d</b> <i>directory</i> The destination directory for the output file.\n * Only used if <code>-outfile</code> is used, in which case, the file is\n * written in this directory. Otherwise, this option is ignored.\n *\n * <li> <b>-i</b> Specifies that the docfile should be edited in-place.  This\n * option can only be used if the <code>-docfile</code> option is used, and\n * may not be used at the same time as the <code>-outfile</code> option.\n *\n * <li> <b>-format</b> <i>format</i> This option sets the output format of this\n * doclet.  Currently, the following values for <i>format</i> are supported:\n * <ul>\n *   <li> <b>javadoc</b> When this format is specified, the output of this\n *   doclet is formatted as a Javadoc comment.  This is useful for including\n *   option documentation inside Java source code.  When this format is used\n *   with the <code>-docfile</code> option, the generated documentation is\n *   inserted between the lines\n *   <pre>* &lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n *   and\n *   <pre>* &lt;!-- end options doc --&gt;</pre>\n *   using the same indentation.  Inline <code>@link</code> and\n *   <code>@see</code> tags in the Javadoc input are left untouched.\n *\n *   <li> <b>html</b> This format outputs HTML for general-purpose use, meaning\n *   inline <code>@link</code> and <code>@see</code> tags in the Javadoc input\n *   are suitably replaced.  This is the default output format and does not\n *   need to be specified explicitly.\n * </ul>\n *\n * <li> <b>-classdoc</b> When specified, the output of this doclet includes the\n * class documentation of the first class specified on the command-line.\n *\n * <li> <b>-singledash</b> When specified, <code>use_single_dash(true)</code> is\n * called on the underlying instance of Options used to generate documentation.\n * See {@link plume.Options#use_single_dash(boolean)}.\n * </ul>\n * <p>\n *\n * <b>Examples</b> <p>\n * To update the Javarifier HTML manual with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile javarifier.html src/javarifier/Main.java</pre>\n * <p>\n *\n * To update the class Javadoc for plume.Lookup with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile Lookup.java -format javadoc Lookup.java</pre>\n * <p>\n *\n * For a more extensive example, see file <code>java/Makefile</code> in\n * plume-lib itself.\n * <p>\n *\n * <b>Requirements</b> <p>\n * Classes passed to OptionsDoclet that have <code>@</code>{@link Option} annotations on\n * non-static fields should have a nullary (no-argument) constructor.  The\n * nullary constructor may be private or public.  This is required because an\n * object instance is needed to get the default value of a non-static field.  It\n * is cleaner to require a nullary constructor instead of trying to guess\n * arguments to pass to another constructor. <p>\n *\n * <b>Hiding default value strings</b> <p>\n * By default, the documentation generated by OptionsDoclet includes a default\n * value string for each option in square brackets after the option's\n * description, similar to the usage messages generated by {@link\n * plume.Options#usage(String...)}.  The {@link plume.Option#noDocDefault}\n * field in the <code>@Option</code> annotation can be set to <code>true</code>\n * to omit the default value string from the generated documentation for that\n * option. <p>\n *\n * Omitting the generated default value string is useful for options that have\n * system-dependent defaults.  Such options are not an issue for usage messages\n * that are generated at runtime.  However, system dependent defaults do pose\n * a problem for static documentation, which is rarely regenerated and meant to\n * apply to all users.  Consider the following <code>@Option</code>-annotated\n * field:\n * <pre>\n * &#64;Option(value=\"&lt;timezone&gt; Set the time zone\")\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * The default value for <code>timezone</code> depends on the system's timezone\n * setting.  HTML documentation of this option generated in Chicago would not\n * apply to a user in New York.  To work around this problem, the\n * default value should be hidden; instead the Javadoc for this field\n * should indicate a special default as follows.\n * <pre>\n * &#47;**\n *  * &lt;other stuff...&gt;  This option defaults to the system timezone.\n *  *&#47;\n * &#64;Option(value=\"&lt;timezone&gt; Set the timezone\", noDocDefault=true)\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * This keeps the documentation system-agnostic. <p>\n *\n * <b>Caveats</b> <p>\n * The generated HTML documentation includes unpublicized option groups but not\n * <code>@Unpublicized</code> options.  Option groups which contain only\n * <code>@Unpublicized</code> options are not included in the output at all. <p>\n *\n * <b>Troubleshooting</b> <p>\n * If you get an error such as \"<code>ARGH! @Option</code>\", then you are using a\n * buggy version of gjdoc, the GNU Classpath implementation of Javadoc.\n * To avoid the problem, upgrade or use a different Javadoc implementation.\n *\n * @see plume.Option\n * @see plume.Options\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n */",
  "classSourceCode" : "// The five files\n//   Option.java\n//   OptionGroup.java\n//   Options.java\n//   Unpublicized.java\n//   OptionsDoclet.java\n// together comprise the implementation of command-line processing.\n\npackage plume;\n\nimport com.sun.javadoc.ClassDoc;\nimport com.sun.javadoc.Doc;\nimport com.sun.javadoc.DocErrorReporter;\nimport com.sun.javadoc.FieldDoc;\nimport com.sun.javadoc.RootDoc;\nimport com.sun.javadoc.SeeTag;\nimport com.sun.javadoc.Tag;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Formatter;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/*>>>\nimport org.checkerframework.checker.formatter.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n/**\n * Generates HTML documentation of command-line options.  Works with the\n * {@link plume.Options} class.\n * <p>\n *\n * <b>Usage</b> <p>\n * This doclet is typically invoked with:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet [doclet options] [java files]</pre>\n * <p>\n *\n * <b>Doclet Options</b> <p>\n * The following doclet options are supported:\n * <ul>\n * <li> <b>-docfile</b> <i>file</i> When specified, the output of this doclet\n * is the result of replacing everything between the two lines\n * <pre>&lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n * and\n * <pre>&lt;!-- end options doc --&gt;</pre>\n * in <i>file</i> with the options documentation.  This can be used for\n * inserting option documentation into an existing manual.  The existing\n * docfile is not modified; output goes to the <code>-outfile</code>\n * argument, or to standard out.\n *\n * <li> <b>-outfile</b> <i>file</i> The destination for the output (the default\n * is standard out).  If both <code>-outfile</code> and <code>-docfile</code>\n * are specified, they must be different. When <code>-d</code> is used, the\n * output is written to a file with the given name relative to that destination\n * directory.\n *\n * <li> <b>-d</b> <i>directory</i> The destination directory for the output file.\n * Only used if <code>-outfile</code> is used, in which case, the file is\n * written in this directory. Otherwise, this option is ignored.\n *\n * <li> <b>-i</b> Specifies that the docfile should be edited in-place.  This\n * option can only be used if the <code>-docfile</code> option is used, and\n * may not be used at the same time as the <code>-outfile</code> option.\n *\n * <li> <b>-format</b> <i>format</i> This option sets the output format of this\n * doclet.  Currently, the following values for <i>format</i> are supported:\n * <ul>\n *   <li> <b>javadoc</b> When this format is specified, the output of this\n *   doclet is formatted as a Javadoc comment.  This is useful for including\n *   option documentation inside Java source code.  When this format is used\n *   with the <code>-docfile</code> option, the generated documentation is\n *   inserted between the lines\n *   <pre>* &lt;!-- start options doc (DO NOT EDIT BY HAND) --&gt;</pre>\n *   and\n *   <pre>* &lt;!-- end options doc --&gt;</pre>\n *   using the same indentation.  Inline <code>@link</code> and\n *   <code>@see</code> tags in the Javadoc input are left untouched.\n *\n *   <li> <b>html</b> This format outputs HTML for general-purpose use, meaning\n *   inline <code>@link</code> and <code>@see</code> tags in the Javadoc input\n *   are suitably replaced.  This is the default output format and does not\n *   need to be specified explicitly.\n * </ul>\n *\n * <li> <b>-classdoc</b> When specified, the output of this doclet includes the\n * class documentation of the first class specified on the command-line.\n *\n * <li> <b>-singledash</b> When specified, <code>use_single_dash(true)</code> is\n * called on the underlying instance of Options used to generate documentation.\n * See {@link plume.Options#use_single_dash(boolean)}.\n * </ul>\n * <p>\n *\n * <b>Examples</b> <p>\n * To update the Javarifier HTML manual with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile javarifier.html src/javarifier/Main.java</pre>\n * <p>\n *\n * To update the class Javadoc for plume.Lookup with option documentation run:\n * <pre>javadoc -quiet -doclet plume.OptionsDoclet -i -docfile Lookup.java -format javadoc Lookup.java</pre>\n * <p>\n *\n * For a more extensive example, see file <code>java/Makefile</code> in\n * plume-lib itself.\n * <p>\n *\n * <b>Requirements</b> <p>\n * Classes passed to OptionsDoclet that have <code>@</code>{@link Option} annotations on\n * non-static fields should have a nullary (no-argument) constructor.  The\n * nullary constructor may be private or public.  This is required because an\n * object instance is needed to get the default value of a non-static field.  It\n * is cleaner to require a nullary constructor instead of trying to guess\n * arguments to pass to another constructor. <p>\n *\n * <b>Hiding default value strings</b> <p>\n * By default, the documentation generated by OptionsDoclet includes a default\n * value string for each option in square brackets after the option's\n * description, similar to the usage messages generated by {@link\n * plume.Options#usage(String...)}.  The {@link plume.Option#noDocDefault}\n * field in the <code>@Option</code> annotation can be set to <code>true</code>\n * to omit the default value string from the generated documentation for that\n * option. <p>\n *\n * Omitting the generated default value string is useful for options that have\n * system-dependent defaults.  Such options are not an issue for usage messages\n * that are generated at runtime.  However, system dependent defaults do pose\n * a problem for static documentation, which is rarely regenerated and meant to\n * apply to all users.  Consider the following <code>@Option</code>-annotated\n * field:\n * <pre>\n * &#64;Option(value=\"&lt;timezone&gt; Set the time zone\")\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * The default value for <code>timezone</code> depends on the system's timezone\n * setting.  HTML documentation of this option generated in Chicago would not\n * apply to a user in New York.  To work around this problem, the\n * default value should be hidden; instead the Javadoc for this field\n * should indicate a special default as follows.\n * <pre>\n * &#47;**\n *  * &lt;other stuff...&gt;  This option defaults to the system timezone.\n *  *&#47;\n * &#64;Option(value=\"&lt;timezone&gt; Set the timezone\", noDocDefault=true)\n * public static String timezone = TimeZone.getDefault().getID();</pre>\n * This keeps the documentation system-agnostic. <p>\n *\n * <b>Caveats</b> <p>\n * The generated HTML documentation includes unpublicized option groups but not\n * <code>@Unpublicized</code> options.  Option groups which contain only\n * <code>@Unpublicized</code> options are not included in the output at all. <p>\n *\n * <b>Troubleshooting</b> <p>\n * If you get an error such as \"<code>ARGH! @Option</code>\", then you are using a\n * buggy version of gjdoc, the GNU Classpath implementation of Javadoc.\n * To avoid the problem, upgrade or use a different Javadoc implementation.\n *\n * @see plume.Option\n * @see plume.Options\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n */\n\n// This doesn't itself use plume.Options for its command-line option\n// processing because a Doclet is required to implement the optionLength\n// and validOptions methods.\npublic class OptionsDoclet {\n\n  private static String eol = System.getProperty(\"line.separator\");\n\n  private final static /*@Format({})*/ String USAGE =\n      \"Provided by Options doclet:%n\"\n          + \"-docfile <file>        Specify file into which options documentation is inserted%n\"\n          + \"-outfile <file>        Specify destination for resulting output%n\"\n          + \"-d <directory>         Destination directory for -outfile%n\"\n          + \"-i                     Edit the docfile in-place%n\"\n          + \"-format javadoc        Format output as a Javadoc comment%n\"\n          + \"-classdoc              Include 'main' class documentation in output%n\"\n          + \"-singledash            Use single dashes for long options (see plume.Options)%n\"\n          + \"See the OptionsDoclet documentation for more details.%n\";\n\n  private static final String LIST_HELP =\n      \"<code>[+]</code> marked option can be specified multiple times\";\n\n  private String startDelim = \"<!-- start options doc (DO NOT EDIT BY HAND) -->\";\n  private String endDelim = \"<!-- end options doc -->\";\n\n  private /*@Nullable*/ File docFile = null;\n  private /*@Nullable*/ File outFile = null;\n\n  /** If true, then edit docFile in place (and docFile is non-null). */\n  private boolean inPlace = false;\n  /** If true, then output format is Javadoc. */\n  private boolean formatJavadoc = false;\n  private boolean includeClassDoc = false;\n\n  private RootDoc root;\n  private Options options;\n\n  public OptionsDoclet(RootDoc root, Options options) {\n    this.root = root;\n    this.options = options;\n  }\n\n  // Doclet-specific methods\n\n  /**\n   * Entry point for the doclet.\n   * @param root the root document\n   * @return true if processing completed without an error\n   */\n  public static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n      // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n      // returns a fully qualified name.  I do not know a good way to convert\n      // between these two name formats.  For now, we simply ignore inner\n      // classes.  This limitation can be removed when we figure out a better\n      // way to go from ClassDoc to Class<?>.\n      if (doc.containingClass() != null) {\n        continue;\n      }\n\n      Class<?> clazz;\n      try {\n        @SuppressWarnings(\"signature\") // Javadoc source code is not yet annotated\n        /*@BinaryNameForNonArray*/ String className = doc.qualifiedName();\n        clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n      } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return false;\n      }\n\n      if (needsInstantiation(clazz)) {\n        try {\n          Constructor<?> c = clazz.getDeclaredConstructor();\n          c.setAccessible(true);\n          objs.add(c.newInstance(new Object[0]));\n        } catch (Exception e) {\n          e.printStackTrace();\n          return false;\n        }\n      } else {\n        objs.add(clazz);\n      }\n    }\n\n    if (objs.isEmpty()) {\n      System.out.println(\"Error: no classes found\");\n      return false;\n    }\n\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n      System.out.println(\"Error: no @Option-annotated fields found\");\n      return false;\n    }\n\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n      o.write();\n    } catch (Exception e) {\n      e.printStackTrace();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Given a command-line option of this doclet, returns the number of\n   * arguments you must specify on the command line for the given option.\n   * Returns 0 if the argument is not recognized.  This method is\n   * automatically invoked.\n   *\n   * @param option the command-line option\n   * @return the number of command-line arguments needed when using the option\n   * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n   */\n  public static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n      System.out.printf(USAGE);\n      return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n      return 1;\n    }\n    if (option.equals(\"-docfile\")\n        || option.equals(\"-outfile\")\n        || option.equals(\"-format\")\n        || option.equals(\"-d\")) {\n      return 2;\n    }\n    return 0;\n  }\n\n  /**\n   * Tests the validity of command-line arguments passed to this doclet.\n   * Returns true if the option usage is valid, and false otherwise.  This\n   * method is automatically invoked.\n   *\n   * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n   * @param reporter where to report errors\n   * @return true iff the command-line options are valid\n   * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n   */\n  public static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        if (hasDocFile) {\n          reporter.printError(\"-docfile option specified twice\");\n          return false;\n        }\n        File f = new File(os[1]);\n        if (!f.exists()) {\n          reporter.printError(\"-docfile file not found: \" + os[1]);\n          return false;\n        }\n        docFile = os[1];\n        hasDocFile = true;\n      }\n      if (opt.equals(\"-outfile\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-outfile option specified twice\");\n          return false;\n        }\n        if (inPlace) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        outFile = os[1];\n        hasOutFile = true;\n      }\n      if (opt.equals(\"-i\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        inPlace = true;\n      }\n      if (opt.equals(\"-format\")) {\n        if (hasFormat) {\n          reporter.printError(\"-format option specified twice\");\n          return false;\n        }\n        if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n          reporter.printError(\"unrecognized output format: \" + os[1]);\n          return false;\n        }\n        hasFormat = true;\n      }\n      if (opt.equals(\"-d\")) {\n        if (hasDestDir) {\n          reporter.printError(\"-d specified twice\");\n          return false;\n        }\n        hasDestDir = true;\n      }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n      reporter.printError(\"docfile must be different from outfile\");\n      return false;\n    }\n    if (inPlace && docFile == null) {\n      reporter.printError(\"-i supplied but -docfile was not\");\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Set the options for this class based on command-line arguments given by\n   * RootDoc.options().\n   * @param options the command-line options to parse: a list of 1- or 2-element arrays\n   */\n  public void setOptions(String[][] options) {\n    String outFilename = null;\n    File destDir = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        this.docFile = new File(os[1]);\n      } else if (opt.equals(\"-d\")) {\n        destDir = new File(os[1]);\n      } else if (opt.equals(\"-outfile\")) {\n        outFilename = os[1];\n      } else if (opt.equals(\"-i\")) {\n        this.inPlace = true;\n      } else if (opt.equals(\"-format\")) {\n        if (os[1].equals(\"javadoc\")) {\n          setFormatJavadoc(true);\n        }\n      } else if (opt.equals(\"-classdoc\")) {\n        this.includeClassDoc = true;\n      } else if (opt.equals(\"-singledash\")) {\n        setUseSingleDash(true);\n      }\n    }\n    if (outFilename != null) {\n      if (destDir != null) {\n        this.outFile = new File(destDir, outFilename);\n      } else {\n        this.outFile = new File(outFilename);\n      }\n    }\n  }\n\n  /**\n   * Determine if a class needs to be instantiated in order to work properly\n   * with {@link Options}.\n   */\n  private static boolean needsInstantiation(Class<?> clazz) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.isAnnotationPresent(Option.class) && !Modifier.isStatic(f.getModifiers())) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // File IO methods\n\n  /**\n   * Write the output of this doclet to the correct file.\n   * @throws Exception if there is trouble\n   */\n  public void write() throws Exception {\n    PrintWriter out;\n    String output = output();\n\n    if (outFile != null) {\n      out = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));\n    } else if (inPlace) {\n      assert docFile != null\n          : \"@AssumeAssertion(nullness): dependent: docFile is non-null if inPlace is true\";\n      out = new PrintWriter(new BufferedWriter(new FileWriter(docFile)));\n    } else {\n      out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    }\n\n    out.println(output);\n    out.flush();\n    out.close();\n  }\n\n  /**\n   * Get the final output of this doclet.  The string returned by this method\n   * is the output seen by the user.\n   * @return the user-visible doclet output\n   * @throws Exception if there is trouble\n   */\n  public String output() throws Exception {\n    if (docFile == null) {\n      if (formatJavadoc) {\n        return optionsToJavadoc(0);\n      } else {\n        return optionsToHtml();\n      }\n    }\n\n    return newDocFileText();\n  }\n\n  /**\n   * Get the result of inserting the options documentation into the docfile.\n   */\n  /*@RequiresNonNull(\"docFile\")*/\n  private String newDocFileText() throws Exception {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    BufferedReader doc = new BufferedReader(new FileReader(docFile));\n    String docline;\n    boolean replacing = false;\n    boolean replaced_once = false;\n\n    while ((docline = doc.readLine()) != null) {\n      if (replacing) {\n        if (docline.trim().equals(endDelim)) {\n          replacing = false;\n        } else {\n          continue;\n        }\n      }\n\n      b.append(docline);\n\n      if (!replaced_once && docline.trim().equals(startDelim)) {\n        if (formatJavadoc) {\n          b.append(optionsToJavadoc(docline.indexOf('*')));\n        } else {\n          b.append(optionsToHtml());\n        }\n        replaced_once = true;\n        replacing = true;\n      }\n    }\n\n    doc.close();\n    return b.toString();\n  }\n\n  // HTML and Javadoc processing methods\n\n  /**\n   * Process each option and add in the Javadoc info.\n   */\n  public void processJavadoc() {\n    for (Options.OptionInfo oi : options.getOptions()) {\n      ClassDoc opt_doc = root.classNamed(oi.get_declaring_class().getName());\n      if (opt_doc != null) {\n        String nameWithUnderscores = oi.long_name.replace('-', '_');\n        for (FieldDoc fd : opt_doc.fields()) {\n          if (fd.name().equals(nameWithUnderscores)) {\n            // If Javadoc for field is unavailable, then use the @Option\n            // description in the documentation.\n            if (fd.getRawCommentText().length() == 0) {\n              // Input is a string rather than a Javadoc (HTML) comment so we\n              // must escape it.\n              oi.jdoc = StringEscapeUtils.escapeHtml4(oi.description);\n            } else if (formatJavadoc) {\n              oi.jdoc = fd.commentText();\n            } else {\n              oi.jdoc = javadocToHtml(fd);\n            }\n            break;\n          }\n        }\n      }\n      if (oi.base_type.isEnum()) {\n        processEnumJavadoc(oi);\n      }\n    }\n  }\n\n  /**\n   * Initializes {@link Options.OptionInfo.enum_jdoc} for the given\n   * <code>OptionInfo</code>.\n   */\n  private void processEnumJavadoc(Options.OptionInfo oi) {\n    Enum<?>[] constants = (Enum<?>[]) oi.base_type.getEnumConstants();\n    if (constants == null) {\n      return;\n    }\n\n    oi.enum_jdoc = new LinkedHashMap<String, String>();\n\n    for (Enum<?> constant : constants) {\n      assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n      oi.enum_jdoc.put(constant.name(), \"\");\n    }\n\n    ClassDoc enum_doc = root.classNamed(oi.base_type.getName());\n    if (enum_doc == null) {\n      return;\n    }\n\n    assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n    for (String name : oi.enum_jdoc.keySet()) {\n      for (FieldDoc fd : enum_doc.fields()) {\n        if (fd.name().equals(name)) {\n          if (formatJavadoc) {\n            oi.enum_jdoc.put(name, fd.commentText());\n          } else {\n            oi.enum_jdoc.put(name, javadocToHtml(fd));\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the HTML documentation for the underlying options instance.\n   * @return the HTML documentation for the underlying options instance\n   */\n  public String optionsToHtml() {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n\n    if (includeClassDoc && root.classes().length > 0) {\n      b.append(OptionsDoclet.javadocToHtml(root.classes()[0]));\n      b.append(\"<p>Command line options:</p>\");\n    }\n\n    b.append(\"<ul>\");\n    if (!options.isUsingGroups()) {\n      b.append(optionListToHtml(options.getOptions(), 2));\n    } else {\n      for (Options.OptionGroupInfo gi : options.getOptionGroups()) {\n        // Do not include groups without publicized options in output\n        if (!gi.any_publicized()) {\n          continue;\n        }\n\n        b.append(\n            \"  <li id=\\\"optiongroup:\"\n                + gi.name.replace(\" \", \"-\").replace(\"/\", \"-\")\n                + \"\\\">\"\n                + gi.name);\n        b.append(\"    <ul>\");\n        b.append(optionListToHtml(gi.optionList, 6));\n        b.append(\"    </ul>\");\n        b.append(\"  </li>\");\n      }\n    }\n    b.append(\"</ul>\");\n\n    for (Options.OptionInfo oi : options.getOptions()) {\n      if (oi.list != null && !oi.unpublicized) {\n        b.append(LIST_HELP);\n        break;\n      }\n    }\n\n    return b.toString();\n  }\n\n  /**\n   * Get the HTML documentation for the underlying options instance, formatted\n   * as a Javadoc comment.\n   * @param padding the padding to add in the Javadoc output\n   * @return the HTML documentation for the underlying options instance\n   */\n  public String optionsToJavadoc(int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    Scanner s = new Scanner(optionsToHtml());\n\n    while (s.hasNextLine()) {\n      StringBuilder bb = new StringBuilder();\n      bb.append(StringUtils.repeat(\" \", padding)).append(\"* \").append(s.nextLine());\n      b.append(bb);\n    }\n\n    return b.toString();\n  }\n\n  /**\n   * Get the HTML describing many options, formatted as an HTML list.\n   */\n  private String optionListToHtml(List<Options.OptionInfo> opt_list, int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    for (Options.OptionInfo oi : opt_list) {\n      if (oi.unpublicized) {\n        continue;\n      }\n      StringBuilder bb = new StringBuilder();\n      String optHtml = optionToHtml(oi, padding);\n      bb.append(StringUtils.repeat(\" \", padding));\n      bb.append(\"<li id=\\\"option:\" + oi.long_name + \"\\\">\").append(optHtml).append(\"</li>\");\n      b.append(bb);\n    }\n    return b.toString();\n  }\n\n  /**\n   * Get the line of HTML describing an Option.\n   * @param oi the option to describe\n   * @return HTML describing oi\n   */\n  public String optionToHtml(Options.OptionInfo oi, int padding) {\n    StringBuilder b = new StringBuilder();\n    Formatter f = new Formatter(b);\n    if (oi.short_name != null) {\n      f.format(\"<b>-%s</b> \", oi.short_name);\n    }\n    for (String a : oi.aliases) {\n      f.format(\"<b>%s</b> \", a);\n    }\n    String prefix = getUseSingleDash() ? \"-\" : \"--\";\n    f.format(\"<b>%s%s=</b><i>%s</i>\", prefix, oi.long_name, oi.type_name);\n    if (oi.list != null) {\n      b.append(\" <code>[+]</code>\");\n    }\n    f.format(\".%n \");\n    f.format(\"%s\", StringUtils.repeat(\" \", padding));\n\n    String jdoc = ((oi.jdoc == null) ? \"\" : oi.jdoc);\n    if (oi.no_doc_default || oi.default_str == null) {\n      f.format(\"%s\", jdoc);\n    } else {\n      String default_str = \"default \" + oi.default_str;\n      // The default string must be HTML-escaped since it comes from a string\n      // rather than a Javadoc comment.\n      String suffix = \"\";\n      if (jdoc.endsWith(\"</p>\")) {\n        suffix = \"</p>\";\n        jdoc = jdoc.substring(0, jdoc.length() - suffix.length());\n      }\n      f.format(\"%s [%s]%s\", jdoc, StringEscapeUtils.escapeHtml4(default_str), suffix);\n    }\n    if (oi.base_type.isEnum()) {\n      b.append(\"<ul>\");\n      assert oi.enum_jdoc != null\n          : \"@AssumeAssertion(nullness): dependent: non-null if oi.base_type is an enum\";\n      for (Map.Entry<String, String> entry : oi.enum_jdoc.entrySet()) {\n        b.append(\"<li><b>\").append(entry.getKey()).append(\"</b>\");\n        if (entry.getValue().length() != 0) {\n          b.append(\" \").append(entry.getValue());\n        }\n        b.append(\"</li>\");\n      }\n      b.append(\"</ul>\");\n    }\n    return b.toString();\n  }\n\n  /**\n   * Replace the @link tags and block @see tags in a Javadoc comment with\n   * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n   * comment while still being presentable. <p>\n   *\n   * This is only a temporary solution.  Ideally, @link/@see tags would be\n   * converted to HTML links that point to actual documentation.\n   *\n   * @param doc a Javadoc comment to convert to HTML\n   * @return HTML version of doc\n   */\n  public static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n      if (tag instanceof SeeTag) {\n        b.append(\"<code>\" + tag.text() + \"</code>\");\n      } else {\n        b.append(tag.text());\n      }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n      b.append(\" See: \");\n      {\n        StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n        for (SeeTag tag : seetags) {\n          bb.append(\"<code>\" + tag.text() + \"</code>\");\n        }\n        b.append(bb);\n      }\n      b.append(\".\");\n    }\n    return b.toString();\n  }\n\n  // Getters and Setters\n\n  public boolean getFormatJavadoc() {\n    return formatJavadoc;\n  }\n\n  public void setFormatJavadoc(boolean val) {\n    if (val && !formatJavadoc) {\n      startDelim = \"* \" + startDelim;\n      endDelim = \"* \" + endDelim;\n    } else if (!val && formatJavadoc) {\n      startDelim = StringUtils.removeStart(\"* \", startDelim);\n      endDelim = StringUtils.removeStart(\"* \", endDelim);\n    }\n    this.formatJavadoc = val;\n  }\n\n  public boolean getUseSingleDash() {\n    return options.isUsingSingleDash();\n  }\n\n  public void setUseSingleDash(boolean val) {\n    options.use_single_dash(true);\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "optionsToHtml", "plume", "OptionsDoclet", "public String optionsToHtml()" ], [ "getFormatJavadoc", "plume", "OptionsDoclet", "public boolean getFormatJavadoc()" ], [ "output", "plume", "OptionsDoclet", "public String output() throws Exception" ], [ "getUseSingleDash", "plume", "OptionsDoclet", "public boolean getUseSingleDash()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "optionToHtml", "plume", "OptionsDoclet", "public String optionToHtml(Options.OptionInfo oi, int padding)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "optionsToJavadoc", "plume", "OptionsDoclet", "public String optionsToJavadoc(int padding)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10273,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "TimeLimitProcess",
  "javadocTag" : "@return the timeout time in msecs",
  "methodJavadoc" : "    /**\n   * Return the timeout time in msecs.\n   * @return the timeout time in msecs\n   */",
  "methodSourceCode" : "public long timeout_msecs(){\n    return (timeLimit);\n}",
  "classJavadoc" : "/**\n * TimeLimitProcess is a subclass of Process such that the process is\n * killed if it runs for more than the specified number of milliseconds.\n * Wall clock seconds, not CPU seconds, are measured.\n * The process should already be started when TimeLimitProcess is invoked.\n * Typical use:\n * <pre>\n *   ProcessBuilder pb = ...;\n *   TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);</pre>\n *\n * <b>Note</b>: If a Java process is destroyed (e.g., because it times\n * out), then its output is unreadable:  Java code trying to read its\n * output stream fails.  Here are two ways to get around this problem:\n *\n * <ul>\n * <li>\n * The client of TimeLimitProcess can send the process output to a file (or\n * ByteArrayOutputStream, etc.), which can be read after the process\n * terminates.  This is easy to do in Java 7, for example via\n * ProcessBuilder.redirectOutput(tempFile).  There does not appear to be an\n * easy way to do it in Java 6.\n * </li>\n * <li>\n * This class provides a workaround, in which it busy-waits reading the\n * standard and error outputs and stores them away.  Use\n * ...\n * </li>\n * </ul>\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport org.apache.commons.io.IOUtils;\n\n/*>>>\nimport org.checkerframework.checker.initialization.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\n*/\n\n/**\n * TimeLimitProcess is a subclass of Process such that the process is\n * killed if it runs for more than the specified number of milliseconds.\n * Wall clock seconds, not CPU seconds, are measured.\n * The process should already be started when TimeLimitProcess is invoked.\n * Typical use:\n * <pre>\n *   ProcessBuilder pb = ...;\n *   TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);</pre>\n *\n * <b>Note</b>: If a Java process is destroyed (e.g., because it times\n * out), then its output is unreadable:  Java code trying to read its\n * output stream fails.  Here are two ways to get around this problem:\n *\n * <ul>\n * <li>\n * The client of TimeLimitProcess can send the process output to a file (or\n * ByteArrayOutputStream, etc.), which can be read after the process\n * terminates.  This is easy to do in Java 7, for example via\n * ProcessBuilder.redirectOutput(tempFile).  There does not appear to be an\n * easy way to do it in Java 6.\n * </li>\n * <li>\n * This class provides a workaround, in which it busy-waits reading the\n * standard and error outputs and stores them away.  Use\n * ...\n * </li>\n * </ul>\n */\npublic class TimeLimitProcess extends Process {\n\n  private Process p;\n  private long timeLimit;\n  private boolean timed_out = false;\n  // can make public for testing\n  private /*@MonotonicNonNull*/ StringWriter cached_stdout;\n  private /*@MonotonicNonNull*/ StringWriter cached_stderr;\n\n  private Timer timer;\n\n  private static boolean debug = false;\n\n  /**\n   * Creates a TimeLimitProcess with the given time limit, in wall clock\n   * milliseconds.\n   * @param p non-null Process to limit the execution of\n   * @param timeLimit in milliseconds\n   */\n  public TimeLimitProcess(Process p, long timeLimit) {\n    this(p, timeLimit, false);\n  }\n\n  /**\n   * Creates a TimeLimitProcess with the given time limit, in wall clock\n   * milliseconds.\n   * @param p non-null Process to limit the execution of\n   * @param timeLimit in milliseconds\n   * @param cacheStdout\n   * If true, causes the TimeLimitProcess to consume the standard output of the\n   * underlying process, and to cache it.  After the process terminates (on\n   * its own or by being timed out), the output is available via the\n   * cached_stdout method.  This is necessary because when a Java process\n   * is terminated, its standard output is no longer available.\n   */\n  public TimeLimitProcess(Process p, long timeLimit, boolean cacheStdout) {\n    this.p = p;\n    timer = new Timer(true);\n    this.timeLimit = timeLimit;\n    if (debug) {\n      System.out.printf(\n          \"new timelimit process, timeLimit=%s, cacheStdout=%s%n\", timeLimit, cacheStdout);\n    }\n    @SuppressWarnings({\n      \"rawness\",\n      \"initialization\"\n    }) // tptt won't do anything with this until this is fully initialized; can FBC avoid the @SuppressWarnings?\n    /*@Initialized*/ TPTimerTask tptt = new TPTimerTask(this, timeLimit);\n    timer.schedule(tptt, timeLimit);\n    if (cacheStdout) {\n      cached_stdout = new StringWriter();\n      cached_stderr = new StringWriter();\n      new StdoutStreamReaderThread().start();\n      new StderrStreamReaderThread().start();\n    }\n  }\n\n  /**\n   * Returns true if the process has timed out (has run for more than the\n   * timeLimit msecs specified in the constructor).\n   * @return true iff the process has timed out\n   */\n  public boolean timed_out() {\n    return (timed_out);\n  }\n\n  /**\n   * Return the timeout time in msecs.\n   * @return the timeout time in msecs\n   */\n  public long timeout_msecs() {\n    return (timeLimit);\n  }\n\n  // /**\n  //  * Returns the standard output of the process, if the cacheStdout\n  //  * parameter was \"true\" when the constructor was invoked.\n  //  * Only for debugging.\n  //  */\n  // public String cached_stdout() {\n  //   if (cached_stdout == null) {\n  //     throw new Error(\"called cached_stdout() without previously calling cache_stdout()\");\n  //   }\n  //   return cached_stdout.toString();\n  // }\n\n  /**\n   * Kills the subprocess.\n   * @see Process#destroy()\n   */\n  public void destroy() {\n    p.destroy();\n  }\n\n  /**\n   * Return the exit value for the subprocess.\n   * @return the exit value for the subprocess\n   * @see Process#getErrorStream()\n   */\n  public int exitValue() {\n    // I'm not sure whether this is necessary; the Process.destroy()\n    // documentation doesn't specify the effect on the exit value.\n    if ((p.exitValue() == 0) && timed_out) {\n      return 255;\n    } else {\n      return p.exitValue();\n    }\n  }\n\n  /**\n   * Gets the error stream connected to the error output of the subprocess.\n   * @return the error stream\n   * @see Process#getErrorStream()\n   */\n  public InputStream getErrorStream() {\n    if (cached_stderr == null) {\n      @SuppressWarnings(\"nullness\") // non-null because we didn't redirect the error stream\n      /*@NonNull*/ InputStream errorStream = p.getErrorStream();\n      return errorStream;\n    } else {\n      // Convert a String to an InputStream\n      String text = cached_stderr.toString();\n      try {\n        InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n        return is;\n      } catch (UnsupportedEncodingException e) {\n        throw new Error(e);\n      }\n    }\n  }\n\n  /**\n   * Gets an input stream connected to the output of the subprocess.\n   * @return the input stream\n   * @see Process#getInputStream()\n   */\n  public InputStream getInputStream() {\n    if (cached_stdout == null) {\n      @SuppressWarnings(\"nullness\") // non-null because we didn't redirect the input stream\n      /*@NonNull*/ InputStream inputStream = p.getInputStream();\n      return inputStream;\n    } else {\n      return stringToInputStream(cached_stdout.toString());\n    }\n  }\n\n  // Convert a String to an InputStream\n  private InputStream stringToInputStream(String text) {\n    try {\n      InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n      return is;\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(e);\n    }\n  }\n\n  /**\n   * Gets the output stream connected to the input of the subprocess.\n   * @return the output stream\n   * @see Process#getOutputStream()\n   */\n  @SuppressWarnings(\"nullness\") // non-null because we didn't redirect the output stream\n  public OutputStream getOutputStream() {\n    return p.getOutputStream();\n  }\n\n  /**\n   * Causes the current thread to wait, if necessary, until the process represented by this Process object has terminated.\n   * @return the exit value of the subprocess\n   * @see Process#waitFor()\n   */\n  public int waitFor() throws InterruptedException {\n    return p.waitFor();\n  }\n\n  /**\n   * @return true if the process if finished, false otherwise\n   */\n  public boolean finished() {\n    try {\n      // Process.exitValue() throws an exception if the process is not\n      // finished.\n      p.exitValue();\n      return true;\n    } catch (IllegalThreadStateException ie) {\n      return false;\n    }\n  }\n\n  /**\n   * This TimerTask destroys the process that is passed to it.\n   */\n  private static class TPTimerTask extends TimerTask {\n    TimeLimitProcess tp;\n    long timeLimit;\n\n    public TPTimerTask(TimeLimitProcess tp, long timeLimit) {\n      this.tp = tp;\n      this.timeLimit = timeLimit;\n    }\n\n    public void run() {\n      // If exitValue is queried while the process is still running,\n      // the IllegalThreadStateException will be thrown.  If that\n      // happens, we kill the process and note that so callers can\n      // tell that a timeout occurred.\n      try {\n        int exit = tp.p.exitValue();\n        if (debug) {\n          System.out.println();\n          System.out.println(\"Process exited with status \" + exit);\n          System.out.println();\n        }\n      } catch (IllegalThreadStateException ie) {\n        tp.p.destroy();\n        tp.timed_out = true;\n        if (debug) {\n          System.out.println(\n              \"Terminated process after timelimit of \" + timeLimit + \" msecs expired\");\n          System.out.println();\n        }\n      }\n      this.cancel();\n    }\n  }\n\n  // I'm not sure how to generalize the below two classes into one -- my\n  // attempt failed.\n\n  private class StdoutStreamReaderThread extends Thread {\n    @SuppressWarnings(\n        \"nullness\") // checker bug: NonNullOnEntry cannot access a variable in an enclosing class\n    /*@RequiresNonNull(\"cached_stdout\")*/\n    public void run() {\n      // This thread will block as the process produces output.  That's OK,\n      // because the blocking is happening in a separate thread.\n      try {\n        IOUtils.copy(p.getInputStream(), cached_stdout, Charset.defaultCharset());\n      } catch (IOException e) {\n        // assume the best\n      }\n    }\n  }\n\n  private class StderrStreamReaderThread extends Thread {\n    @SuppressWarnings(\n        \"nullness\") // checker bug: NonNullOnEntry cannot access a variable in an enclosing class\n    /*@RequiresNonNull(\"cached_stderr\")*/\n    public void run() {\n      // This thread will block as the process produces output.  That's OK,\n      // because the blocking is happening in a separate thread.\n      try {\n        IOUtils.copy(p.getErrorStream(), cached_stderr, Charset.defaultCharset());\n      } catch (IOException e) {\n        // assume the best\n      }\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "waitFor", "java.lang", "Process", "public boolean waitFor(long arg0, TimeUnit arg1) throws InterruptedException" ], [ "children", "java.lang", "Process", "public Stream<ProcessHandle> children()" ], [ "outputWriter", "java.lang", "Process", "public final BufferedWriter outputWriter(Charset arg0)" ], [ "waitFor", "plume", "TimeLimitProcess", "public int waitFor() throws InterruptedException" ], [ "supportsNormalTermination", "java.lang", "Process", "public boolean supportsNormalTermination()" ], [ "getInputStream", "plume", "TimeLimitProcess", "public InputStream getInputStream()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "exitValue", "plume", "TimeLimitProcess", "public int exitValue()" ], [ "getOutputStream", "plume", "TimeLimitProcess", "public OutputStream getOutputStream()" ], [ "errorReader", "java.lang", "Process", "public final BufferedReader errorReader(Charset arg0)" ], [ "pid", "java.lang", "Process", "public long pid()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "finished", "plume", "TimeLimitProcess", "public boolean finished()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "timed_out", "plume", "TimeLimitProcess", "public boolean timed_out()" ], [ "getErrorStream", "plume", "TimeLimitProcess", "public InputStream getErrorStream()" ], [ "info", "java.lang", "Process", "public ProcessHandle.Info info()" ], [ "inputReader", "java.lang", "Process", "public final BufferedReader inputReader(Charset arg0)" ], [ "destroyForcibly", "java.lang", "Process", "public Process destroyForcibly()" ], [ "outputWriter", "java.lang", "Process", "public final BufferedWriter outputWriter()" ], [ "toHandle", "java.lang", "Process", "public ProcessHandle toHandle()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "timeout_msecs", "plume", "TimeLimitProcess", "public long timeout_msecs()" ], [ "inputReader", "java.lang", "Process", "public final BufferedReader inputReader()" ], [ "errorReader", "java.lang", "Process", "public final BufferedReader errorReader()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "descendants", "java.lang", "Process", "public Stream<ProcessHandle> descendants()" ], [ "onExit", "java.lang", "Process", "public CompletableFuture<Process> onExit()" ], [ "isAlive", "java.lang", "Process", "public boolean isAlive()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10277,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "TimeLimitProcess",
  "javadocTag" : "@return the output stream",
  "methodJavadoc" : "    /**\n   * Gets the output stream connected to the input of the subprocess.\n   * @return the output stream\n   * @see Process#getOutputStream()\n   */",
  "methodSourceCode" : "public OutputStream getOutputStream(){\n    return p.getOutputStream();\n}",
  "classJavadoc" : "/**\n * TimeLimitProcess is a subclass of Process such that the process is\n * killed if it runs for more than the specified number of milliseconds.\n * Wall clock seconds, not CPU seconds, are measured.\n * The process should already be started when TimeLimitProcess is invoked.\n * Typical use:\n * <pre>\n *   ProcessBuilder pb = ...;\n *   TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);</pre>\n *\n * <b>Note</b>: If a Java process is destroyed (e.g., because it times\n * out), then its output is unreadable:  Java code trying to read its\n * output stream fails.  Here are two ways to get around this problem:\n *\n * <ul>\n * <li>\n * The client of TimeLimitProcess can send the process output to a file (or\n * ByteArrayOutputStream, etc.), which can be read after the process\n * terminates.  This is easy to do in Java 7, for example via\n * ProcessBuilder.redirectOutput(tempFile).  There does not appear to be an\n * easy way to do it in Java 6.\n * </li>\n * <li>\n * This class provides a workaround, in which it busy-waits reading the\n * standard and error outputs and stores them away.  Use\n * ...\n * </li>\n * </ul>\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport org.apache.commons.io.IOUtils;\n\n/*>>>\nimport org.checkerframework.checker.initialization.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\n*/\n\n/**\n * TimeLimitProcess is a subclass of Process such that the process is\n * killed if it runs for more than the specified number of milliseconds.\n * Wall clock seconds, not CPU seconds, are measured.\n * The process should already be started when TimeLimitProcess is invoked.\n * Typical use:\n * <pre>\n *   ProcessBuilder pb = ...;\n *   TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);</pre>\n *\n * <b>Note</b>: If a Java process is destroyed (e.g., because it times\n * out), then its output is unreadable:  Java code trying to read its\n * output stream fails.  Here are two ways to get around this problem:\n *\n * <ul>\n * <li>\n * The client of TimeLimitProcess can send the process output to a file (or\n * ByteArrayOutputStream, etc.), which can be read after the process\n * terminates.  This is easy to do in Java 7, for example via\n * ProcessBuilder.redirectOutput(tempFile).  There does not appear to be an\n * easy way to do it in Java 6.\n * </li>\n * <li>\n * This class provides a workaround, in which it busy-waits reading the\n * standard and error outputs and stores them away.  Use\n * ...\n * </li>\n * </ul>\n */\npublic class TimeLimitProcess extends Process {\n\n  private Process p;\n  private long timeLimit;\n  private boolean timed_out = false;\n  // can make public for testing\n  private /*@MonotonicNonNull*/ StringWriter cached_stdout;\n  private /*@MonotonicNonNull*/ StringWriter cached_stderr;\n\n  private Timer timer;\n\n  private static boolean debug = false;\n\n  /**\n   * Creates a TimeLimitProcess with the given time limit, in wall clock\n   * milliseconds.\n   * @param p non-null Process to limit the execution of\n   * @param timeLimit in milliseconds\n   */\n  public TimeLimitProcess(Process p, long timeLimit) {\n    this(p, timeLimit, false);\n  }\n\n  /**\n   * Creates a TimeLimitProcess with the given time limit, in wall clock\n   * milliseconds.\n   * @param p non-null Process to limit the execution of\n   * @param timeLimit in milliseconds\n   * @param cacheStdout\n   * If true, causes the TimeLimitProcess to consume the standard output of the\n   * underlying process, and to cache it.  After the process terminates (on\n   * its own or by being timed out), the output is available via the\n   * cached_stdout method.  This is necessary because when a Java process\n   * is terminated, its standard output is no longer available.\n   */\n  public TimeLimitProcess(Process p, long timeLimit, boolean cacheStdout) {\n    this.p = p;\n    timer = new Timer(true);\n    this.timeLimit = timeLimit;\n    if (debug) {\n      System.out.printf(\n          \"new timelimit process, timeLimit=%s, cacheStdout=%s%n\", timeLimit, cacheStdout);\n    }\n    @SuppressWarnings({\n      \"rawness\",\n      \"initialization\"\n    }) // tptt won't do anything with this until this is fully initialized; can FBC avoid the @SuppressWarnings?\n    /*@Initialized*/ TPTimerTask tptt = new TPTimerTask(this, timeLimit);\n    timer.schedule(tptt, timeLimit);\n    if (cacheStdout) {\n      cached_stdout = new StringWriter();\n      cached_stderr = new StringWriter();\n      new StdoutStreamReaderThread().start();\n      new StderrStreamReaderThread().start();\n    }\n  }\n\n  /**\n   * Returns true if the process has timed out (has run for more than the\n   * timeLimit msecs specified in the constructor).\n   * @return true iff the process has timed out\n   */\n  public boolean timed_out() {\n    return (timed_out);\n  }\n\n  /**\n   * Return the timeout time in msecs.\n   * @return the timeout time in msecs\n   */\n  public long timeout_msecs() {\n    return (timeLimit);\n  }\n\n  // /**\n  //  * Returns the standard output of the process, if the cacheStdout\n  //  * parameter was \"true\" when the constructor was invoked.\n  //  * Only for debugging.\n  //  */\n  // public String cached_stdout() {\n  //   if (cached_stdout == null) {\n  //     throw new Error(\"called cached_stdout() without previously calling cache_stdout()\");\n  //   }\n  //   return cached_stdout.toString();\n  // }\n\n  /**\n   * Kills the subprocess.\n   * @see Process#destroy()\n   */\n  public void destroy() {\n    p.destroy();\n  }\n\n  /**\n   * Return the exit value for the subprocess.\n   * @return the exit value for the subprocess\n   * @see Process#getErrorStream()\n   */\n  public int exitValue() {\n    // I'm not sure whether this is necessary; the Process.destroy()\n    // documentation doesn't specify the effect on the exit value.\n    if ((p.exitValue() == 0) && timed_out) {\n      return 255;\n    } else {\n      return p.exitValue();\n    }\n  }\n\n  /**\n   * Gets the error stream connected to the error output of the subprocess.\n   * @return the error stream\n   * @see Process#getErrorStream()\n   */\n  public InputStream getErrorStream() {\n    if (cached_stderr == null) {\n      @SuppressWarnings(\"nullness\") // non-null because we didn't redirect the error stream\n      /*@NonNull*/ InputStream errorStream = p.getErrorStream();\n      return errorStream;\n    } else {\n      // Convert a String to an InputStream\n      String text = cached_stderr.toString();\n      try {\n        InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n        return is;\n      } catch (UnsupportedEncodingException e) {\n        throw new Error(e);\n      }\n    }\n  }\n\n  /**\n   * Gets an input stream connected to the output of the subprocess.\n   * @return the input stream\n   * @see Process#getInputStream()\n   */\n  public InputStream getInputStream() {\n    if (cached_stdout == null) {\n      @SuppressWarnings(\"nullness\") // non-null because we didn't redirect the input stream\n      /*@NonNull*/ InputStream inputStream = p.getInputStream();\n      return inputStream;\n    } else {\n      return stringToInputStream(cached_stdout.toString());\n    }\n  }\n\n  // Convert a String to an InputStream\n  private InputStream stringToInputStream(String text) {\n    try {\n      InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n      return is;\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(e);\n    }\n  }\n\n  /**\n   * Gets the output stream connected to the input of the subprocess.\n   * @return the output stream\n   * @see Process#getOutputStream()\n   */\n  @SuppressWarnings(\"nullness\") // non-null because we didn't redirect the output stream\n  public OutputStream getOutputStream() {\n    return p.getOutputStream();\n  }\n\n  /**\n   * Causes the current thread to wait, if necessary, until the process represented by this Process object has terminated.\n   * @return the exit value of the subprocess\n   * @see Process#waitFor()\n   */\n  public int waitFor() throws InterruptedException {\n    return p.waitFor();\n  }\n\n  /**\n   * @return true if the process if finished, false otherwise\n   */\n  public boolean finished() {\n    try {\n      // Process.exitValue() throws an exception if the process is not\n      // finished.\n      p.exitValue();\n      return true;\n    } catch (IllegalThreadStateException ie) {\n      return false;\n    }\n  }\n\n  /**\n   * This TimerTask destroys the process that is passed to it.\n   */\n  private static class TPTimerTask extends TimerTask {\n    TimeLimitProcess tp;\n    long timeLimit;\n\n    public TPTimerTask(TimeLimitProcess tp, long timeLimit) {\n      this.tp = tp;\n      this.timeLimit = timeLimit;\n    }\n\n    public void run() {\n      // If exitValue is queried while the process is still running,\n      // the IllegalThreadStateException will be thrown.  If that\n      // happens, we kill the process and note that so callers can\n      // tell that a timeout occurred.\n      try {\n        int exit = tp.p.exitValue();\n        if (debug) {\n          System.out.println();\n          System.out.println(\"Process exited with status \" + exit);\n          System.out.println();\n        }\n      } catch (IllegalThreadStateException ie) {\n        tp.p.destroy();\n        tp.timed_out = true;\n        if (debug) {\n          System.out.println(\n              \"Terminated process after timelimit of \" + timeLimit + \" msecs expired\");\n          System.out.println();\n        }\n      }\n      this.cancel();\n    }\n  }\n\n  // I'm not sure how to generalize the below two classes into one -- my\n  // attempt failed.\n\n  private class StdoutStreamReaderThread extends Thread {\n    @SuppressWarnings(\n        \"nullness\") // checker bug: NonNullOnEntry cannot access a variable in an enclosing class\n    /*@RequiresNonNull(\"cached_stdout\")*/\n    public void run() {\n      // This thread will block as the process produces output.  That's OK,\n      // because the blocking is happening in a separate thread.\n      try {\n        IOUtils.copy(p.getInputStream(), cached_stdout, Charset.defaultCharset());\n      } catch (IOException e) {\n        // assume the best\n      }\n    }\n  }\n\n  private class StderrStreamReaderThread extends Thread {\n    @SuppressWarnings(\n        \"nullness\") // checker bug: NonNullOnEntry cannot access a variable in an enclosing class\n    /*@RequiresNonNull(\"cached_stderr\")*/\n    public void run() {\n      // This thread will block as the process produces output.  That's OK,\n      // because the blocking is happening in a separate thread.\n      try {\n        IOUtils.copy(p.getErrorStream(), cached_stderr, Charset.defaultCharset());\n      } catch (IOException e) {\n        // assume the best\n      }\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "onExit", "java.lang", "Process", "public CompletableFuture<Process> onExit()" ], [ "timeout_msecs", "plume", "TimeLimitProcess", "public long timeout_msecs()" ], [ "children", "java.lang", "Process", "public Stream<ProcessHandle> children()" ], [ "outputWriter", "java.lang", "Process", "public final BufferedWriter outputWriter(Charset arg0)" ], [ "descendants", "java.lang", "Process", "public Stream<ProcessHandle> descendants()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "errorReader", "java.lang", "Process", "public final BufferedReader errorReader()" ], [ "waitFor", "plume", "TimeLimitProcess", "public int waitFor() throws InterruptedException" ], [ "exitValue", "plume", "TimeLimitProcess", "public int exitValue()" ], [ "getOutputStream", "plume", "TimeLimitProcess", "public OutputStream getOutputStream()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "outputWriter", "java.lang", "Process", "public final BufferedWriter outputWriter()" ], [ "inputReader", "java.lang", "Process", "public final BufferedReader inputReader()" ], [ "isAlive", "java.lang", "Process", "public boolean isAlive()" ], [ "supportsNormalTermination", "java.lang", "Process", "public boolean supportsNormalTermination()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toHandle", "java.lang", "Process", "public ProcessHandle toHandle()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getErrorStream", "plume", "TimeLimitProcess", "public InputStream getErrorStream()" ], [ "timed_out", "plume", "TimeLimitProcess", "public boolean timed_out()" ], [ "errorReader", "java.lang", "Process", "public final BufferedReader errorReader(Charset arg0)" ], [ "getInputStream", "plume", "TimeLimitProcess", "public InputStream getInputStream()" ], [ "pid", "java.lang", "Process", "public long pid()" ], [ "waitFor", "java.lang", "Process", "public boolean waitFor(long arg0, TimeUnit arg1) throws InterruptedException" ], [ "destroyForcibly", "java.lang", "Process", "public Process destroyForcibly()" ], [ "finished", "plume", "TimeLimitProcess", "public boolean finished()" ], [ "inputReader", "java.lang", "Process", "public final BufferedReader inputReader(Charset arg0)" ], [ "info", "java.lang", "Process", "public ProcessHandle.Info info()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10297,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Intern",
  "javadocTag" : "@param a the array to canonicalize",
  "methodJavadoc" : "    /**\n   * Intern (canonicalize) a long[].\n   * Return a canonical representation for the long[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the long[] array\n   */",
  "methodSourceCode" : "public static long[] intern(long[] a){\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}",
  "classJavadoc" : "/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */",
  "classSourceCode" : "package plume;\n\nimport java.lang.ref.WeakReference;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/*>>>\nimport org.checkerframework.checker.interning.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */\npublic final class Intern {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private Intern() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Strings\n  ///\n\n  /**\n   * Replace each element of the array by its interned version.\n   * Side-effects the array, but also returns it.\n   * @param a the array whose elements to intern in place\n   * @return an interned version of a\n   * @see String#intern\n   */\n  @SuppressWarnings(\"interning\") // side-effects the array in place (dangerous, but convenient)\n  public static /*@Interned*/ String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (a[i] != null) {\n        a[i] = a[i].intern();\n      }\n    }\n    return a;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Testing interning\n  ///\n\n  /**\n   * Return true if the argument is interned (is canonical among all\n   * objects equal to itself).\n   * @param value the value to test for interning\n   * @return true iff value is interned\n   */\n  @SuppressWarnings(\"interning\") // interning implementation\n  /*@Pure*/\n  public static boolean isInterned(/*@Nullable*/ Object value) {\n    if (value == null) {\n      // nothing to do\n      return true;\n    } else if (value instanceof String) {\n      return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n      return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n      return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n      return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n      return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n      return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n      return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n      return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n      return (value == intern((Object[]) value));\n    } else {\n      // Nothing to do, because we don't intern other types.\n      // System.out.println(\"What type? \" + value.getClass().getName());\n      return true;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning objects\n  ///\n\n  /**\n   * Hasher object which hashes and compares Integers.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class IntegerHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Integer i = (Integer) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Longs.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class LongHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Long i = (Long) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares int[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(int[], int[])\n   */\n  private static final class IntArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((int[]) a1, (int[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((int[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares long[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals (long[], long[])\n   */\n  private static final class LongArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((long[]) a1, (long[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((long[]) o);\n    }\n  }\n\n  private static final int FACTOR = 23;\n  // private static final double DOUBLE_FACTOR = 65537;\n  private static final double DOUBLE_FACTOR = 263;\n\n  /**\n   * Hasher object which hashes and compares Doubles.\n   * @see Hasher\n   */\n  private static final class DoubleHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Double d = (Double) o;\n      return d.hashCode();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares double[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[],Object[])\n   */\n  private static final class DoubleArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      // \"Arrays.equals\" considers +0.0 != -0.0.\n      // Also, it gives inconsistent results (on different JVMs/classpaths?).\n      // return Arrays.equals((double[])a1, (double[])a2);\n      double[] da1 = (double[]) a1;\n      double[] da2 = (double[]) a2;\n      if (da1.length != da2.length) {\n        return false;\n      }\n      for (int i = 0; i < da1.length; i++) {\n        if (!((da1[i] == da2[i]) || (Double.isNaN(da1[i]) && Double.isNaN(da2[i])))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      double[] a = (double[]) o;\n      // Not Arrays.hashCode(a), for consistency with equals method\n      // immediately above.\n      double running = 0;\n      for (int i = 0; i < a.length; i++) {\n        double elt = (Double.isNaN(a[i]) ? 0.0 : a[i]);\n        running = running * FACTOR + elt * DOUBLE_FACTOR;\n      }\n      // Could add \"... % Integer.MAX_VALUE\" here; is that good to do?\n      long result = Math.round(running);\n      return (int) (result % Integer.MAX_VALUE);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   * Arrays.equals\n   */\n  private static final class StringArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((String[]) a1, (String[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((String[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Object[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[], Object[])\n   */\n  private static final class ObjectArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((/*@Nullable*/ Object[]) a1, (/*@Nullable*/ Object[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((Object[]) o);\n    }\n  }\n\n  // Each of these maps has:\n  //   key = an interned object\n  //   value = a WeakReference for the object itself.\n  // They can be looked up using a non-interned value; equality tests know\n  // nothing of the interning types.\n\n  private static WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>\n      internedIntegers;\n  private static WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>> internedLongs;\n  private static WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>\n      internedIntArrays;\n  private static WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>\n      internedLongArrays;\n  private static WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>\n      internedDoubles;\n  private static /*@Interned*/ Double internedDoubleNaN;\n  private static /*@Interned*/ Double internedDoubleZero;\n  private static WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>\n      internedDoubleArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectArrays;\n  private static WeakHasherMap<\n          SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>\n      internedIntSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>\n      internedLongSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>\n      internedDoubleSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringSequenceAndIndices;\n\n  static {\n    internedIntegers =\n        new WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>(\n            new IntegerHasher());\n    internedLongs =\n        new WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>>(new LongHasher());\n    internedIntArrays =\n        new WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>(\n            new IntArrayHasher());\n    internedLongArrays =\n        new WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>(\n            new LongArrayHasher());\n    internedDoubles =\n        new WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>(\n            new DoubleHasher());\n    internedDoubleNaN = new /*@Interned*/ Double(Double.NaN);\n    internedDoubleZero = new /*@Interned*/ Double(0);\n    internedDoubleArrays =\n        new WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>(\n            new DoubleArrayHasher());\n    internedStringArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new StringArrayHasher());\n    internedObjectArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new ObjectArrayHasher());\n    internedIntSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<int /*@Interned*/ []>());\n    internedLongSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<long /*@Interned*/ []>());\n    internedDoubleSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<double /*@Interned*/ []>());\n    internedObjectSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>());\n    internedStringSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>());\n  }\n\n  // For testing only\n  public static int numIntegers() {\n    return internedIntegers.size();\n  }\n\n  public static int numLongs() {\n    return internedLongs.size();\n  }\n\n  public static int numIntArrays() {\n    return internedIntArrays.size();\n  }\n\n  public static int numLongArrays() {\n    return internedLongArrays.size();\n  }\n\n  public static int numDoubles() {\n    return internedDoubles.size();\n  }\n\n  public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n  }\n\n  public static int numStringArrays() {\n    return internedStringArrays.size();\n  }\n\n  public static int numObjectArrays() {\n    return internedObjectArrays.size();\n  }\n\n  public static Iterator</*@Interned*/ Integer> integers() {\n    return internedIntegers.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Long> longs() {\n    return internedLongs.keySet().iterator();\n  }\n\n  public static Iterator<int /*@Interned*/ []> intArrays() {\n    return internedIntArrays.keySet().iterator();\n  }\n\n  public static Iterator<long /*@Interned*/ []> longArrays() {\n    return internedLongArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Double> doubles() {\n    return internedDoubles.keySet().iterator();\n  }\n\n  public static Iterator<double /*@Interned*/ []> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n  }\n\n  /**\n   * Interns a String.\n   * Delegates to the builtin String.intern() method.\n   * Provided for completeness.\n   * @param a the string to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ String intern(/*@PolyNull*/ String a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n      return null;\n    }\n    return a.intern();\n  }\n\n  /**\n   * Interns a long.\n   * A no-op.  Provided for completeness.\n   * @param l the long to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static long intern(long l) {\n    return l;\n  }\n\n  /**\n   * Interns a double\n   * A no-op.  Provided for completeness.\n   * @param d the double to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static double intern(double d) {\n    return d;\n  }\n\n  /**\n   * Intern (canonicalize) an Integer.\n   * Return a canonical representation for the Integer.\n   * @param a an Integer to canonicalize\n   * @return a canonical representation for the Integer\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Intern.valueOf is intended to promise\n  // the same).  This does not currently take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"}) // interning implementation\n  /*@Pure*/\n  public static /*@Interned*/ Integer intern(Integer a) {\n    WeakReference</*@Interned*/ Integer> lookup = internedIntegers.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Integer result = (/*@Interned*/ Integer) a;\n      internedIntegers.put(result, new WeakReference</*@Interned*/ Integer>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Integer internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Integer parsed from s\n   */\n  public static /*@Interned*/ Integer internedInteger(String s) {\n    return intern(Integer.decode(s));\n  }\n\n  /**\n   * Intern (canonicalize) a Long.\n   * Return a canonical representation for the Long.\n   * @param a the value to intern\n   * @return a canonical representation for the Long\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Long.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Long intern(Long a) {\n    WeakReference</*@Interned*/ Long> lookup = internedLongs.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Long result = (/*@Interned*/ Long) a;\n      internedLongs.put(result, new WeakReference</*@Interned*/ Long>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Long internedLong(long i) {\n    return intern(Long.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Long parsed from s\n   */\n  public static /*@Interned*/ Long internedLong(String s) {\n    return intern(Long.decode(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) an int[].\n   * Return a canonical representation for the int[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the int[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static int /*@Interned*/ [] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n\n    WeakReference<int /*@Interned*/ []> lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ int[] result = (int /*@Interned*/ []) a;\n      internedIntArrays.put(result, new WeakReference<int /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a long[].\n   * Return a canonical representation for the long[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the long[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static long /*@Interned*/ [] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long /*@Interned*/ []> lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ long[] result = (long /*@Interned*/ []) a;\n      internedLongArrays.put(result, new WeakReference<long /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a Double.\n   * Return a canonical representation for the Double.\n   * @param a the Double to canonicalize\n   * @return a canonical representation for the Double\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Double.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Double intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n      return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) { // catches both positive and negative zero\n      return internedDoubleZero;\n    }\n    WeakReference</*@Interned*/ Double> lookup = internedDoubles.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Double result = (/*@Interned*/ Double) a;\n      internedDoubles.put(result, new WeakReference</*@Interned*/ Double>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value i.\n   * @param d the value to intern\n   * @return an interned Double with value d\n   */\n  public static /*@Interned*/ Double internedDouble(double d) {\n    return intern(Double.valueOf(d));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Double parsed from s\n   */\n  public static /*@Interned*/ Double internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) a double[].\n   * Return a canonical representation for the double[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the double[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static double /*@Interned*/ [] intern(double[] a) {\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ double[] result = (double /*@Interned*/ []) a;\n      internedDoubleArrays.put(result, new WeakReference<double /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) an String[].\n   * Return a canonical representation for the String[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the String[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ String[] a) {\n\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n      assert a[k] == Intern.intern(a[k]);\n    }\n\n    WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ String /*@Interned*/ []) a;\n      internedStringArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Intern (canonicalize) an Object[].\n   * Return a canonical representation for the Object[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the Object[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ Object[] a) {\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []) a;\n      internedObjectArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Convenince method to intern an Object when we don't know its\n   * runtime type.  Its runtime type must be one of the types for\n   * which we have an intern() method, else an exception is thrown.\n   * If the argument is an array, its elements should themselves be\n   * interned.\n   * @param a an Object to canonicalize\n   * @return a canonical version of a\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ Object intern(/*@PolyNull*/ Object a) {\n    if (a == null) {\n      return null;\n    } else if (a instanceof String) {\n      return intern((String) a);\n    } else if (a instanceof String[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ String[] asArray = (/*@Interned*/ String[]) a;\n      return intern(asArray);\n    } else if (a instanceof Integer) {\n      return intern((Integer) a);\n    } else if (a instanceof Long) {\n      return intern((Long) a);\n    } else if (a instanceof int[]) {\n      return intern((int[]) a);\n    } else if (a instanceof long[]) {\n      return intern((long[]) a);\n    } else if (a instanceof Double) {\n      return intern((Double) a);\n    } else if (a instanceof double[]) {\n      return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ Object[] asArray = (/*@Interned*/ Object[]) a;\n      return intern(asArray);\n    } else {\n      throw new IllegalArgumentException(\n          \"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n  }\n\n  /**\n   * Return the subsequence of seq from start (inclusive) to end\n   * (exclusive) that is interned.  What's different about this method\n   * from manually finding the subsequence and interning the\n   * subsequence is that if the subsequence is already interned, we\n   * can avoid having to compute the sequence.  Since derived\n   * variables in Daikon compute the subsequence many times, this\n   * shortcut saves quite a bit of computation.  It saves even more\n   * when there may be many derived variables that are non-canonical,\n   * since they are guaranteed to be ==.\n   * <p>\n   * Requires that seq is already interned.\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   */\n  public static int /*@Interned*/ [] internSubsequence(int /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int /*@Interned*/ []> sai =\n        new SequenceAndIndices<int /*@Interned*/ []>(seq, start, end);\n    WeakReference<int /*@Interned*/ []> lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n      int /*@Interned*/ [] subseq = Intern.intern(subseqUninterned);\n      internedIntSequenceAndIndices.put(sai, new WeakReference<int /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static long /*@Interned*/ [] internSubsequence(\n      long /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long /*@Interned*/ []> sai =\n        new SequenceAndIndices<long /*@Interned*/ []>(seq, start, end);\n    WeakReference<long /*@Interned*/ []> lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      long /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedLongSequenceAndIndices.put(sai, new WeakReference<long /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static double /*@Interned*/ [] internSubsequence(\n      double /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double /*@Interned*/ []> sai =\n        new SequenceAndIndices<double /*@Interned*/ []>(seq, start, end);\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      double /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedDoubleSequenceAndIndices.put(sai, new WeakReference<double /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedObjectSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedStringSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * Data structure for storing triples of a sequence and start and\n   * end indices, to represent a subsequence.  Requires that the\n   * sequence be interned.  Used for interning the repeated finding\n   * of subsequences on the same sequence.\n   */\n  private static final class SequenceAndIndices<T extends /*@Interned*/ Object> {\n    public T seq;\n    public int start;\n    public int end;\n\n    /**\n     * @param seq an interned array\n     */\n    public SequenceAndIndices(T seq, int start, int end) {\n      this.seq = seq;\n      this.start = start;\n      this.end = end;\n      assert isInterned(seq);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ /*@Nullable*/ Object other) {\n      if (other instanceof SequenceAndIndices<?>) {\n        @SuppressWarnings(\"unchecked\")\n        SequenceAndIndices<T> other_sai = (SequenceAndIndices<T>) other;\n        return equals(other_sai);\n      } else {\n        return false;\n      }\n    }\n\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ SequenceAndIndices<T> other) {\n      return ((this.seq == other.seq) && this.start == other.start && this.end == other.end);\n    }\n\n    /*@Pure*/\n    public int hashCode(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return seq.hashCode() + start * 30 - end * 2;\n    }\n\n    // For debugging\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return \"SAI(\" + start + \",\" + end + \") from: \" + ArraysMDE.toString(seq);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   */\n  private static final class SequenceAndIndicesHasher<T extends /*@Interned*/ Object>\n      implements Hasher {\n    public boolean equals(Object a1, Object a2) {\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai1 = (SequenceAndIndices<T>) a1;\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai2 = (SequenceAndIndices<T>) a2;\n      // The SAI objects are *not* interned, but the arrays inside them are.\n      return sai1.equals(sai2);\n    }\n\n    public int hashCode(Object o) {\n      return o.hashCode();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #1\n  ///\n\n  /// Interning arrays:  old implmentation.\n  /// The problem with this is that it doesn't release keys.\n  // // I can also use Arrays.equals() to compare two arrays of base\n  // // or Object type; but that doesn't do ordering.  (It does properly deal\n  // // with the possibility that the argument is null, which this doesn't\n  // // right now.  I may want to err in this implementation if the arguments\n  // // are null or the lengths are not equal -- if I never mix arrays of\n  // // different lengths.)\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical numbers).\n  // static final class IntArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     int[] a1 = (int[])o1;\n  //     int[] a2 = (int[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i] - a2[i];\n  //       if (tmp != 0)\n  //         return tmp;\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical objects).\n  // static final class ObjectArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     Object[] a1 = (Object[])o1;\n  //     Object[] a2 = (Object[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i].hashCode() - a2[i].hashCode();\n  //       if (tmp != 0)\n  //         return tmp;\n  //       // I'm counting on the fact that hashCode returns a different\n  //       // number for each Object in the system.  This checks that assumption.\n  //       assert a1[i].equals(a2[i]);\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // private static TreeSet internedIntArrays;\n  // private static TreeSet internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new TreeSet(new IntArrayComparator());\n  //   internedObjectArrays = new TreeSet(new ObjectArrayComparator());\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   boolean added = internedIntArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (int[])internedIntArrays.tailSet(a).first();\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   boolean added = internedObjectArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (Object[])internedObjectArrays.tailSet(a).first();\n  //   }\n  // }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #2\n  ///\n\n  /// This doesn't work because there are no references to the Wrappers,\n  /// so all of the WeakHashMap elements are immediately removed.\n\n  // // Create an ArrayWrapper which redefines equal (and hash) to act the\n  // // way I want them to.\n\n  // static final class IntArrayWrapper {\n  //   private int[] a;\n  //   IntArrayWrapper(int[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(IntArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i];\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // static final class ObjectArrayWrapper {\n  //   private Object[] a;\n  //   ObjectArrayWrapper(Object[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(ObjectArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   // Alternately, just xor all the element hash codes.\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i].hashCode();\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // // Map from an ArrayWrapper to the array (I don't need to map to a\n  // // WeakReference because the array isn't the key of the WeakHashMap).\n\n  // // non-private for debugging only\n  // static WeakHashMap internedIntArrays;\n  // static WeakHashMap internedObjectArrays;\n  // // private static WeakHashMap internedIntArrays;\n  // // private static WeakHashMap internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new WeakHashMap();\n  //   internedObjectArrays = new WeakHashMap();\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   IntArrayWrapper w = new IntArrayWrapper(a);\n  //   Object result = internedIntArrays.get(w);\n  //   if (result != null)\n  //     return (int[])result;\n  //   else {\n  //     internedIntArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   ObjectArrayWrapper w = new ObjectArrayWrapper(a);\n  //   Object result = internedObjectArrays.get(w);\n  //   if (result != null)\n  //     return (Object[])result;\n  //   else {\n  //     internedObjectArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "long[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "", "long[]", "public boolean equals(Object);" ], [ "toString", "", "long[]", "public String toString()" ], [ "hashCode", "", "long[]", "public native int hashCode()" ], [ "getClass", "", "long[]", "public final native Class getClass();" ], [ "clone", "", "long[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "long[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10307,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Intern",
  "javadocTag" : "@param a the array to canonicalize",
  "methodJavadoc" : "    /**\n   * Intern (canonicalize) an Object[].\n   * Return a canonical representation for the Object[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the Object[] array\n   */",
  "methodSourceCode" : "public static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a){\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}",
  "classJavadoc" : "/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */",
  "classSourceCode" : "package plume;\n\nimport java.lang.ref.WeakReference;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/*>>>\nimport org.checkerframework.checker.interning.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */\npublic final class Intern {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private Intern() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Strings\n  ///\n\n  /**\n   * Replace each element of the array by its interned version.\n   * Side-effects the array, but also returns it.\n   * @param a the array whose elements to intern in place\n   * @return an interned version of a\n   * @see String#intern\n   */\n  @SuppressWarnings(\"interning\") // side-effects the array in place (dangerous, but convenient)\n  public static /*@Interned*/ String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (a[i] != null) {\n        a[i] = a[i].intern();\n      }\n    }\n    return a;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Testing interning\n  ///\n\n  /**\n   * Return true if the argument is interned (is canonical among all\n   * objects equal to itself).\n   * @param value the value to test for interning\n   * @return true iff value is interned\n   */\n  @SuppressWarnings(\"interning\") // interning implementation\n  /*@Pure*/\n  public static boolean isInterned(/*@Nullable*/ Object value) {\n    if (value == null) {\n      // nothing to do\n      return true;\n    } else if (value instanceof String) {\n      return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n      return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n      return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n      return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n      return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n      return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n      return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n      return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n      return (value == intern((Object[]) value));\n    } else {\n      // Nothing to do, because we don't intern other types.\n      // System.out.println(\"What type? \" + value.getClass().getName());\n      return true;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning objects\n  ///\n\n  /**\n   * Hasher object which hashes and compares Integers.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class IntegerHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Integer i = (Integer) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Longs.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class LongHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Long i = (Long) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares int[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(int[], int[])\n   */\n  private static final class IntArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((int[]) a1, (int[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((int[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares long[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals (long[], long[])\n   */\n  private static final class LongArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((long[]) a1, (long[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((long[]) o);\n    }\n  }\n\n  private static final int FACTOR = 23;\n  // private static final double DOUBLE_FACTOR = 65537;\n  private static final double DOUBLE_FACTOR = 263;\n\n  /**\n   * Hasher object which hashes and compares Doubles.\n   * @see Hasher\n   */\n  private static final class DoubleHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Double d = (Double) o;\n      return d.hashCode();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares double[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[],Object[])\n   */\n  private static final class DoubleArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      // \"Arrays.equals\" considers +0.0 != -0.0.\n      // Also, it gives inconsistent results (on different JVMs/classpaths?).\n      // return Arrays.equals((double[])a1, (double[])a2);\n      double[] da1 = (double[]) a1;\n      double[] da2 = (double[]) a2;\n      if (da1.length != da2.length) {\n        return false;\n      }\n      for (int i = 0; i < da1.length; i++) {\n        if (!((da1[i] == da2[i]) || (Double.isNaN(da1[i]) && Double.isNaN(da2[i])))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      double[] a = (double[]) o;\n      // Not Arrays.hashCode(a), for consistency with equals method\n      // immediately above.\n      double running = 0;\n      for (int i = 0; i < a.length; i++) {\n        double elt = (Double.isNaN(a[i]) ? 0.0 : a[i]);\n        running = running * FACTOR + elt * DOUBLE_FACTOR;\n      }\n      // Could add \"... % Integer.MAX_VALUE\" here; is that good to do?\n      long result = Math.round(running);\n      return (int) (result % Integer.MAX_VALUE);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   * Arrays.equals\n   */\n  private static final class StringArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((String[]) a1, (String[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((String[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Object[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[], Object[])\n   */\n  private static final class ObjectArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((/*@Nullable*/ Object[]) a1, (/*@Nullable*/ Object[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((Object[]) o);\n    }\n  }\n\n  // Each of these maps has:\n  //   key = an interned object\n  //   value = a WeakReference for the object itself.\n  // They can be looked up using a non-interned value; equality tests know\n  // nothing of the interning types.\n\n  private static WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>\n      internedIntegers;\n  private static WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>> internedLongs;\n  private static WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>\n      internedIntArrays;\n  private static WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>\n      internedLongArrays;\n  private static WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>\n      internedDoubles;\n  private static /*@Interned*/ Double internedDoubleNaN;\n  private static /*@Interned*/ Double internedDoubleZero;\n  private static WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>\n      internedDoubleArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectArrays;\n  private static WeakHasherMap<\n          SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>\n      internedIntSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>\n      internedLongSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>\n      internedDoubleSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringSequenceAndIndices;\n\n  static {\n    internedIntegers =\n        new WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>(\n            new IntegerHasher());\n    internedLongs =\n        new WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>>(new LongHasher());\n    internedIntArrays =\n        new WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>(\n            new IntArrayHasher());\n    internedLongArrays =\n        new WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>(\n            new LongArrayHasher());\n    internedDoubles =\n        new WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>(\n            new DoubleHasher());\n    internedDoubleNaN = new /*@Interned*/ Double(Double.NaN);\n    internedDoubleZero = new /*@Interned*/ Double(0);\n    internedDoubleArrays =\n        new WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>(\n            new DoubleArrayHasher());\n    internedStringArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new StringArrayHasher());\n    internedObjectArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new ObjectArrayHasher());\n    internedIntSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<int /*@Interned*/ []>());\n    internedLongSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<long /*@Interned*/ []>());\n    internedDoubleSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<double /*@Interned*/ []>());\n    internedObjectSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>());\n    internedStringSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>());\n  }\n\n  // For testing only\n  public static int numIntegers() {\n    return internedIntegers.size();\n  }\n\n  public static int numLongs() {\n    return internedLongs.size();\n  }\n\n  public static int numIntArrays() {\n    return internedIntArrays.size();\n  }\n\n  public static int numLongArrays() {\n    return internedLongArrays.size();\n  }\n\n  public static int numDoubles() {\n    return internedDoubles.size();\n  }\n\n  public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n  }\n\n  public static int numStringArrays() {\n    return internedStringArrays.size();\n  }\n\n  public static int numObjectArrays() {\n    return internedObjectArrays.size();\n  }\n\n  public static Iterator</*@Interned*/ Integer> integers() {\n    return internedIntegers.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Long> longs() {\n    return internedLongs.keySet().iterator();\n  }\n\n  public static Iterator<int /*@Interned*/ []> intArrays() {\n    return internedIntArrays.keySet().iterator();\n  }\n\n  public static Iterator<long /*@Interned*/ []> longArrays() {\n    return internedLongArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Double> doubles() {\n    return internedDoubles.keySet().iterator();\n  }\n\n  public static Iterator<double /*@Interned*/ []> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n  }\n\n  /**\n   * Interns a String.\n   * Delegates to the builtin String.intern() method.\n   * Provided for completeness.\n   * @param a the string to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ String intern(/*@PolyNull*/ String a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n      return null;\n    }\n    return a.intern();\n  }\n\n  /**\n   * Interns a long.\n   * A no-op.  Provided for completeness.\n   * @param l the long to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static long intern(long l) {\n    return l;\n  }\n\n  /**\n   * Interns a double\n   * A no-op.  Provided for completeness.\n   * @param d the double to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static double intern(double d) {\n    return d;\n  }\n\n  /**\n   * Intern (canonicalize) an Integer.\n   * Return a canonical representation for the Integer.\n   * @param a an Integer to canonicalize\n   * @return a canonical representation for the Integer\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Intern.valueOf is intended to promise\n  // the same).  This does not currently take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"}) // interning implementation\n  /*@Pure*/\n  public static /*@Interned*/ Integer intern(Integer a) {\n    WeakReference</*@Interned*/ Integer> lookup = internedIntegers.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Integer result = (/*@Interned*/ Integer) a;\n      internedIntegers.put(result, new WeakReference</*@Interned*/ Integer>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Integer internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Integer parsed from s\n   */\n  public static /*@Interned*/ Integer internedInteger(String s) {\n    return intern(Integer.decode(s));\n  }\n\n  /**\n   * Intern (canonicalize) a Long.\n   * Return a canonical representation for the Long.\n   * @param a the value to intern\n   * @return a canonical representation for the Long\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Long.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Long intern(Long a) {\n    WeakReference</*@Interned*/ Long> lookup = internedLongs.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Long result = (/*@Interned*/ Long) a;\n      internedLongs.put(result, new WeakReference</*@Interned*/ Long>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Long internedLong(long i) {\n    return intern(Long.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Long parsed from s\n   */\n  public static /*@Interned*/ Long internedLong(String s) {\n    return intern(Long.decode(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) an int[].\n   * Return a canonical representation for the int[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the int[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static int /*@Interned*/ [] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n\n    WeakReference<int /*@Interned*/ []> lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ int[] result = (int /*@Interned*/ []) a;\n      internedIntArrays.put(result, new WeakReference<int /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a long[].\n   * Return a canonical representation for the long[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the long[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static long /*@Interned*/ [] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long /*@Interned*/ []> lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ long[] result = (long /*@Interned*/ []) a;\n      internedLongArrays.put(result, new WeakReference<long /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a Double.\n   * Return a canonical representation for the Double.\n   * @param a the Double to canonicalize\n   * @return a canonical representation for the Double\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Double.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Double intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n      return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) { // catches both positive and negative zero\n      return internedDoubleZero;\n    }\n    WeakReference</*@Interned*/ Double> lookup = internedDoubles.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Double result = (/*@Interned*/ Double) a;\n      internedDoubles.put(result, new WeakReference</*@Interned*/ Double>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value i.\n   * @param d the value to intern\n   * @return an interned Double with value d\n   */\n  public static /*@Interned*/ Double internedDouble(double d) {\n    return intern(Double.valueOf(d));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Double parsed from s\n   */\n  public static /*@Interned*/ Double internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) a double[].\n   * Return a canonical representation for the double[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the double[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static double /*@Interned*/ [] intern(double[] a) {\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ double[] result = (double /*@Interned*/ []) a;\n      internedDoubleArrays.put(result, new WeakReference<double /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) an String[].\n   * Return a canonical representation for the String[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the String[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ String[] a) {\n\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n      assert a[k] == Intern.intern(a[k]);\n    }\n\n    WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ String /*@Interned*/ []) a;\n      internedStringArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Intern (canonicalize) an Object[].\n   * Return a canonical representation for the Object[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the Object[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ Object[] a) {\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []) a;\n      internedObjectArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Convenince method to intern an Object when we don't know its\n   * runtime type.  Its runtime type must be one of the types for\n   * which we have an intern() method, else an exception is thrown.\n   * If the argument is an array, its elements should themselves be\n   * interned.\n   * @param a an Object to canonicalize\n   * @return a canonical version of a\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ Object intern(/*@PolyNull*/ Object a) {\n    if (a == null) {\n      return null;\n    } else if (a instanceof String) {\n      return intern((String) a);\n    } else if (a instanceof String[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ String[] asArray = (/*@Interned*/ String[]) a;\n      return intern(asArray);\n    } else if (a instanceof Integer) {\n      return intern((Integer) a);\n    } else if (a instanceof Long) {\n      return intern((Long) a);\n    } else if (a instanceof int[]) {\n      return intern((int[]) a);\n    } else if (a instanceof long[]) {\n      return intern((long[]) a);\n    } else if (a instanceof Double) {\n      return intern((Double) a);\n    } else if (a instanceof double[]) {\n      return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ Object[] asArray = (/*@Interned*/ Object[]) a;\n      return intern(asArray);\n    } else {\n      throw new IllegalArgumentException(\n          \"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n  }\n\n  /**\n   * Return the subsequence of seq from start (inclusive) to end\n   * (exclusive) that is interned.  What's different about this method\n   * from manually finding the subsequence and interning the\n   * subsequence is that if the subsequence is already interned, we\n   * can avoid having to compute the sequence.  Since derived\n   * variables in Daikon compute the subsequence many times, this\n   * shortcut saves quite a bit of computation.  It saves even more\n   * when there may be many derived variables that are non-canonical,\n   * since they are guaranteed to be ==.\n   * <p>\n   * Requires that seq is already interned.\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   */\n  public static int /*@Interned*/ [] internSubsequence(int /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int /*@Interned*/ []> sai =\n        new SequenceAndIndices<int /*@Interned*/ []>(seq, start, end);\n    WeakReference<int /*@Interned*/ []> lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n      int /*@Interned*/ [] subseq = Intern.intern(subseqUninterned);\n      internedIntSequenceAndIndices.put(sai, new WeakReference<int /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static long /*@Interned*/ [] internSubsequence(\n      long /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long /*@Interned*/ []> sai =\n        new SequenceAndIndices<long /*@Interned*/ []>(seq, start, end);\n    WeakReference<long /*@Interned*/ []> lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      long /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedLongSequenceAndIndices.put(sai, new WeakReference<long /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static double /*@Interned*/ [] internSubsequence(\n      double /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double /*@Interned*/ []> sai =\n        new SequenceAndIndices<double /*@Interned*/ []>(seq, start, end);\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      double /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedDoubleSequenceAndIndices.put(sai, new WeakReference<double /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedObjectSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedStringSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * Data structure for storing triples of a sequence and start and\n   * end indices, to represent a subsequence.  Requires that the\n   * sequence be interned.  Used for interning the repeated finding\n   * of subsequences on the same sequence.\n   */\n  private static final class SequenceAndIndices<T extends /*@Interned*/ Object> {\n    public T seq;\n    public int start;\n    public int end;\n\n    /**\n     * @param seq an interned array\n     */\n    public SequenceAndIndices(T seq, int start, int end) {\n      this.seq = seq;\n      this.start = start;\n      this.end = end;\n      assert isInterned(seq);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ /*@Nullable*/ Object other) {\n      if (other instanceof SequenceAndIndices<?>) {\n        @SuppressWarnings(\"unchecked\")\n        SequenceAndIndices<T> other_sai = (SequenceAndIndices<T>) other;\n        return equals(other_sai);\n      } else {\n        return false;\n      }\n    }\n\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ SequenceAndIndices<T> other) {\n      return ((this.seq == other.seq) && this.start == other.start && this.end == other.end);\n    }\n\n    /*@Pure*/\n    public int hashCode(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return seq.hashCode() + start * 30 - end * 2;\n    }\n\n    // For debugging\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return \"SAI(\" + start + \",\" + end + \") from: \" + ArraysMDE.toString(seq);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   */\n  private static final class SequenceAndIndicesHasher<T extends /*@Interned*/ Object>\n      implements Hasher {\n    public boolean equals(Object a1, Object a2) {\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai1 = (SequenceAndIndices<T>) a1;\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai2 = (SequenceAndIndices<T>) a2;\n      // The SAI objects are *not* interned, but the arrays inside them are.\n      return sai1.equals(sai2);\n    }\n\n    public int hashCode(Object o) {\n      return o.hashCode();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #1\n  ///\n\n  /// Interning arrays:  old implmentation.\n  /// The problem with this is that it doesn't release keys.\n  // // I can also use Arrays.equals() to compare two arrays of base\n  // // or Object type; but that doesn't do ordering.  (It does properly deal\n  // // with the possibility that the argument is null, which this doesn't\n  // // right now.  I may want to err in this implementation if the arguments\n  // // are null or the lengths are not equal -- if I never mix arrays of\n  // // different lengths.)\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical numbers).\n  // static final class IntArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     int[] a1 = (int[])o1;\n  //     int[] a2 = (int[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i] - a2[i];\n  //       if (tmp != 0)\n  //         return tmp;\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical objects).\n  // static final class ObjectArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     Object[] a1 = (Object[])o1;\n  //     Object[] a2 = (Object[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i].hashCode() - a2[i].hashCode();\n  //       if (tmp != 0)\n  //         return tmp;\n  //       // I'm counting on the fact that hashCode returns a different\n  //       // number for each Object in the system.  This checks that assumption.\n  //       assert a1[i].equals(a2[i]);\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // private static TreeSet internedIntArrays;\n  // private static TreeSet internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new TreeSet(new IntArrayComparator());\n  //   internedObjectArrays = new TreeSet(new ObjectArrayComparator());\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   boolean added = internedIntArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (int[])internedIntArrays.tailSet(a).first();\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   boolean added = internedObjectArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (Object[])internedObjectArrays.tailSet(a).first();\n  //   }\n  // }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #2\n  ///\n\n  /// This doesn't work because there are no references to the Wrappers,\n  /// so all of the WeakHashMap elements are immediately removed.\n\n  // // Create an ArrayWrapper which redefines equal (and hash) to act the\n  // // way I want them to.\n\n  // static final class IntArrayWrapper {\n  //   private int[] a;\n  //   IntArrayWrapper(int[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(IntArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i];\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // static final class ObjectArrayWrapper {\n  //   private Object[] a;\n  //   ObjectArrayWrapper(Object[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(ObjectArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   // Alternately, just xor all the element hash codes.\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i].hashCode();\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // // Map from an ArrayWrapper to the array (I don't need to map to a\n  // // WeakReference because the array isn't the key of the WeakHashMap).\n\n  // // non-private for debugging only\n  // static WeakHashMap internedIntArrays;\n  // static WeakHashMap internedObjectArrays;\n  // // private static WeakHashMap internedIntArrays;\n  // // private static WeakHashMap internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new WeakHashMap();\n  //   internedObjectArrays = new WeakHashMap();\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   IntArrayWrapper w = new IntArrayWrapper(a);\n  //   Object result = internedIntArrays.get(w);\n  //   if (result != null)\n  //     return (int[])result;\n  //   else {\n  //     internedIntArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   ObjectArrayWrapper w = new ObjectArrayWrapper(a);\n  //   Object result = internedObjectArrays.get(w);\n  //   if (result != null)\n  //     return (Object[])result;\n  //   else {\n  //     internedObjectArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "a", "", "Object[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "", "java.lang.Object[]", "public boolean equals(Object);" ], [ "toString", "", "java.lang.Object[]", "public String toString()" ], [ "hashCode", "", "java.lang.Object[]", "public native int hashCode()" ], [ "getClass", "", "java.lang.Object[]", "public final native Class getClass();" ], [ "clone", "", "java.lang.Object[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "java.lang", "Object[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10315,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Intern",
  "javadocTag" : "@param seq the sequence whose subsequence should be interned",
  "methodJavadoc" : "    /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */",
  "methodSourceCode" : "public static long[] internSubsequence(long[] seq, int start, int end){\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}",
  "classJavadoc" : "/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */",
  "classSourceCode" : "package plume;\n\nimport java.lang.ref.WeakReference;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/*>>>\nimport org.checkerframework.checker.interning.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */\npublic final class Intern {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private Intern() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Strings\n  ///\n\n  /**\n   * Replace each element of the array by its interned version.\n   * Side-effects the array, but also returns it.\n   * @param a the array whose elements to intern in place\n   * @return an interned version of a\n   * @see String#intern\n   */\n  @SuppressWarnings(\"interning\") // side-effects the array in place (dangerous, but convenient)\n  public static /*@Interned*/ String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (a[i] != null) {\n        a[i] = a[i].intern();\n      }\n    }\n    return a;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Testing interning\n  ///\n\n  /**\n   * Return true if the argument is interned (is canonical among all\n   * objects equal to itself).\n   * @param value the value to test for interning\n   * @return true iff value is interned\n   */\n  @SuppressWarnings(\"interning\") // interning implementation\n  /*@Pure*/\n  public static boolean isInterned(/*@Nullable*/ Object value) {\n    if (value == null) {\n      // nothing to do\n      return true;\n    } else if (value instanceof String) {\n      return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n      return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n      return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n      return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n      return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n      return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n      return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n      return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n      return (value == intern((Object[]) value));\n    } else {\n      // Nothing to do, because we don't intern other types.\n      // System.out.println(\"What type? \" + value.getClass().getName());\n      return true;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning objects\n  ///\n\n  /**\n   * Hasher object which hashes and compares Integers.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class IntegerHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Integer i = (Integer) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Longs.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class LongHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Long i = (Long) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares int[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(int[], int[])\n   */\n  private static final class IntArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((int[]) a1, (int[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((int[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares long[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals (long[], long[])\n   */\n  private static final class LongArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((long[]) a1, (long[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((long[]) o);\n    }\n  }\n\n  private static final int FACTOR = 23;\n  // private static final double DOUBLE_FACTOR = 65537;\n  private static final double DOUBLE_FACTOR = 263;\n\n  /**\n   * Hasher object which hashes and compares Doubles.\n   * @see Hasher\n   */\n  private static final class DoubleHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Double d = (Double) o;\n      return d.hashCode();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares double[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[],Object[])\n   */\n  private static final class DoubleArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      // \"Arrays.equals\" considers +0.0 != -0.0.\n      // Also, it gives inconsistent results (on different JVMs/classpaths?).\n      // return Arrays.equals((double[])a1, (double[])a2);\n      double[] da1 = (double[]) a1;\n      double[] da2 = (double[]) a2;\n      if (da1.length != da2.length) {\n        return false;\n      }\n      for (int i = 0; i < da1.length; i++) {\n        if (!((da1[i] == da2[i]) || (Double.isNaN(da1[i]) && Double.isNaN(da2[i])))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      double[] a = (double[]) o;\n      // Not Arrays.hashCode(a), for consistency with equals method\n      // immediately above.\n      double running = 0;\n      for (int i = 0; i < a.length; i++) {\n        double elt = (Double.isNaN(a[i]) ? 0.0 : a[i]);\n        running = running * FACTOR + elt * DOUBLE_FACTOR;\n      }\n      // Could add \"... % Integer.MAX_VALUE\" here; is that good to do?\n      long result = Math.round(running);\n      return (int) (result % Integer.MAX_VALUE);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   * Arrays.equals\n   */\n  private static final class StringArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((String[]) a1, (String[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((String[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Object[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[], Object[])\n   */\n  private static final class ObjectArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((/*@Nullable*/ Object[]) a1, (/*@Nullable*/ Object[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((Object[]) o);\n    }\n  }\n\n  // Each of these maps has:\n  //   key = an interned object\n  //   value = a WeakReference for the object itself.\n  // They can be looked up using a non-interned value; equality tests know\n  // nothing of the interning types.\n\n  private static WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>\n      internedIntegers;\n  private static WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>> internedLongs;\n  private static WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>\n      internedIntArrays;\n  private static WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>\n      internedLongArrays;\n  private static WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>\n      internedDoubles;\n  private static /*@Interned*/ Double internedDoubleNaN;\n  private static /*@Interned*/ Double internedDoubleZero;\n  private static WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>\n      internedDoubleArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectArrays;\n  private static WeakHasherMap<\n          SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>\n      internedIntSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>\n      internedLongSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>\n      internedDoubleSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringSequenceAndIndices;\n\n  static {\n    internedIntegers =\n        new WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>(\n            new IntegerHasher());\n    internedLongs =\n        new WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>>(new LongHasher());\n    internedIntArrays =\n        new WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>(\n            new IntArrayHasher());\n    internedLongArrays =\n        new WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>(\n            new LongArrayHasher());\n    internedDoubles =\n        new WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>(\n            new DoubleHasher());\n    internedDoubleNaN = new /*@Interned*/ Double(Double.NaN);\n    internedDoubleZero = new /*@Interned*/ Double(0);\n    internedDoubleArrays =\n        new WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>(\n            new DoubleArrayHasher());\n    internedStringArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new StringArrayHasher());\n    internedObjectArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new ObjectArrayHasher());\n    internedIntSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<int /*@Interned*/ []>());\n    internedLongSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<long /*@Interned*/ []>());\n    internedDoubleSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<double /*@Interned*/ []>());\n    internedObjectSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>());\n    internedStringSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>());\n  }\n\n  // For testing only\n  public static int numIntegers() {\n    return internedIntegers.size();\n  }\n\n  public static int numLongs() {\n    return internedLongs.size();\n  }\n\n  public static int numIntArrays() {\n    return internedIntArrays.size();\n  }\n\n  public static int numLongArrays() {\n    return internedLongArrays.size();\n  }\n\n  public static int numDoubles() {\n    return internedDoubles.size();\n  }\n\n  public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n  }\n\n  public static int numStringArrays() {\n    return internedStringArrays.size();\n  }\n\n  public static int numObjectArrays() {\n    return internedObjectArrays.size();\n  }\n\n  public static Iterator</*@Interned*/ Integer> integers() {\n    return internedIntegers.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Long> longs() {\n    return internedLongs.keySet().iterator();\n  }\n\n  public static Iterator<int /*@Interned*/ []> intArrays() {\n    return internedIntArrays.keySet().iterator();\n  }\n\n  public static Iterator<long /*@Interned*/ []> longArrays() {\n    return internedLongArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Double> doubles() {\n    return internedDoubles.keySet().iterator();\n  }\n\n  public static Iterator<double /*@Interned*/ []> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n  }\n\n  /**\n   * Interns a String.\n   * Delegates to the builtin String.intern() method.\n   * Provided for completeness.\n   * @param a the string to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ String intern(/*@PolyNull*/ String a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n      return null;\n    }\n    return a.intern();\n  }\n\n  /**\n   * Interns a long.\n   * A no-op.  Provided for completeness.\n   * @param l the long to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static long intern(long l) {\n    return l;\n  }\n\n  /**\n   * Interns a double\n   * A no-op.  Provided for completeness.\n   * @param d the double to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static double intern(double d) {\n    return d;\n  }\n\n  /**\n   * Intern (canonicalize) an Integer.\n   * Return a canonical representation for the Integer.\n   * @param a an Integer to canonicalize\n   * @return a canonical representation for the Integer\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Intern.valueOf is intended to promise\n  // the same).  This does not currently take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"}) // interning implementation\n  /*@Pure*/\n  public static /*@Interned*/ Integer intern(Integer a) {\n    WeakReference</*@Interned*/ Integer> lookup = internedIntegers.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Integer result = (/*@Interned*/ Integer) a;\n      internedIntegers.put(result, new WeakReference</*@Interned*/ Integer>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Integer internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Integer parsed from s\n   */\n  public static /*@Interned*/ Integer internedInteger(String s) {\n    return intern(Integer.decode(s));\n  }\n\n  /**\n   * Intern (canonicalize) a Long.\n   * Return a canonical representation for the Long.\n   * @param a the value to intern\n   * @return a canonical representation for the Long\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Long.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Long intern(Long a) {\n    WeakReference</*@Interned*/ Long> lookup = internedLongs.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Long result = (/*@Interned*/ Long) a;\n      internedLongs.put(result, new WeakReference</*@Interned*/ Long>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Long internedLong(long i) {\n    return intern(Long.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Long parsed from s\n   */\n  public static /*@Interned*/ Long internedLong(String s) {\n    return intern(Long.decode(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) an int[].\n   * Return a canonical representation for the int[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the int[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static int /*@Interned*/ [] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n\n    WeakReference<int /*@Interned*/ []> lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ int[] result = (int /*@Interned*/ []) a;\n      internedIntArrays.put(result, new WeakReference<int /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a long[].\n   * Return a canonical representation for the long[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the long[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static long /*@Interned*/ [] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long /*@Interned*/ []> lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ long[] result = (long /*@Interned*/ []) a;\n      internedLongArrays.put(result, new WeakReference<long /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a Double.\n   * Return a canonical representation for the Double.\n   * @param a the Double to canonicalize\n   * @return a canonical representation for the Double\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Double.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Double intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n      return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) { // catches both positive and negative zero\n      return internedDoubleZero;\n    }\n    WeakReference</*@Interned*/ Double> lookup = internedDoubles.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Double result = (/*@Interned*/ Double) a;\n      internedDoubles.put(result, new WeakReference</*@Interned*/ Double>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value i.\n   * @param d the value to intern\n   * @return an interned Double with value d\n   */\n  public static /*@Interned*/ Double internedDouble(double d) {\n    return intern(Double.valueOf(d));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Double parsed from s\n   */\n  public static /*@Interned*/ Double internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) a double[].\n   * Return a canonical representation for the double[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the double[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static double /*@Interned*/ [] intern(double[] a) {\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ double[] result = (double /*@Interned*/ []) a;\n      internedDoubleArrays.put(result, new WeakReference<double /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) an String[].\n   * Return a canonical representation for the String[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the String[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ String[] a) {\n\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n      assert a[k] == Intern.intern(a[k]);\n    }\n\n    WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ String /*@Interned*/ []) a;\n      internedStringArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Intern (canonicalize) an Object[].\n   * Return a canonical representation for the Object[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the Object[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ Object[] a) {\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []) a;\n      internedObjectArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Convenince method to intern an Object when we don't know its\n   * runtime type.  Its runtime type must be one of the types for\n   * which we have an intern() method, else an exception is thrown.\n   * If the argument is an array, its elements should themselves be\n   * interned.\n   * @param a an Object to canonicalize\n   * @return a canonical version of a\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ Object intern(/*@PolyNull*/ Object a) {\n    if (a == null) {\n      return null;\n    } else if (a instanceof String) {\n      return intern((String) a);\n    } else if (a instanceof String[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ String[] asArray = (/*@Interned*/ String[]) a;\n      return intern(asArray);\n    } else if (a instanceof Integer) {\n      return intern((Integer) a);\n    } else if (a instanceof Long) {\n      return intern((Long) a);\n    } else if (a instanceof int[]) {\n      return intern((int[]) a);\n    } else if (a instanceof long[]) {\n      return intern((long[]) a);\n    } else if (a instanceof Double) {\n      return intern((Double) a);\n    } else if (a instanceof double[]) {\n      return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ Object[] asArray = (/*@Interned*/ Object[]) a;\n      return intern(asArray);\n    } else {\n      throw new IllegalArgumentException(\n          \"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n  }\n\n  /**\n   * Return the subsequence of seq from start (inclusive) to end\n   * (exclusive) that is interned.  What's different about this method\n   * from manually finding the subsequence and interning the\n   * subsequence is that if the subsequence is already interned, we\n   * can avoid having to compute the sequence.  Since derived\n   * variables in Daikon compute the subsequence many times, this\n   * shortcut saves quite a bit of computation.  It saves even more\n   * when there may be many derived variables that are non-canonical,\n   * since they are guaranteed to be ==.\n   * <p>\n   * Requires that seq is already interned.\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   */\n  public static int /*@Interned*/ [] internSubsequence(int /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int /*@Interned*/ []> sai =\n        new SequenceAndIndices<int /*@Interned*/ []>(seq, start, end);\n    WeakReference<int /*@Interned*/ []> lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n      int /*@Interned*/ [] subseq = Intern.intern(subseqUninterned);\n      internedIntSequenceAndIndices.put(sai, new WeakReference<int /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static long /*@Interned*/ [] internSubsequence(\n      long /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long /*@Interned*/ []> sai =\n        new SequenceAndIndices<long /*@Interned*/ []>(seq, start, end);\n    WeakReference<long /*@Interned*/ []> lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      long /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedLongSequenceAndIndices.put(sai, new WeakReference<long /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static double /*@Interned*/ [] internSubsequence(\n      double /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double /*@Interned*/ []> sai =\n        new SequenceAndIndices<double /*@Interned*/ []>(seq, start, end);\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      double /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedDoubleSequenceAndIndices.put(sai, new WeakReference<double /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedObjectSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedStringSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * Data structure for storing triples of a sequence and start and\n   * end indices, to represent a subsequence.  Requires that the\n   * sequence be interned.  Used for interning the repeated finding\n   * of subsequences on the same sequence.\n   */\n  private static final class SequenceAndIndices<T extends /*@Interned*/ Object> {\n    public T seq;\n    public int start;\n    public int end;\n\n    /**\n     * @param seq an interned array\n     */\n    public SequenceAndIndices(T seq, int start, int end) {\n      this.seq = seq;\n      this.start = start;\n      this.end = end;\n      assert isInterned(seq);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ /*@Nullable*/ Object other) {\n      if (other instanceof SequenceAndIndices<?>) {\n        @SuppressWarnings(\"unchecked\")\n        SequenceAndIndices<T> other_sai = (SequenceAndIndices<T>) other;\n        return equals(other_sai);\n      } else {\n        return false;\n      }\n    }\n\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ SequenceAndIndices<T> other) {\n      return ((this.seq == other.seq) && this.start == other.start && this.end == other.end);\n    }\n\n    /*@Pure*/\n    public int hashCode(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return seq.hashCode() + start * 30 - end * 2;\n    }\n\n    // For debugging\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return \"SAI(\" + start + \",\" + end + \") from: \" + ArraysMDE.toString(seq);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   */\n  private static final class SequenceAndIndicesHasher<T extends /*@Interned*/ Object>\n      implements Hasher {\n    public boolean equals(Object a1, Object a2) {\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai1 = (SequenceAndIndices<T>) a1;\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai2 = (SequenceAndIndices<T>) a2;\n      // The SAI objects are *not* interned, but the arrays inside them are.\n      return sai1.equals(sai2);\n    }\n\n    public int hashCode(Object o) {\n      return o.hashCode();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #1\n  ///\n\n  /// Interning arrays:  old implmentation.\n  /// The problem with this is that it doesn't release keys.\n  // // I can also use Arrays.equals() to compare two arrays of base\n  // // or Object type; but that doesn't do ordering.  (It does properly deal\n  // // with the possibility that the argument is null, which this doesn't\n  // // right now.  I may want to err in this implementation if the arguments\n  // // are null or the lengths are not equal -- if I never mix arrays of\n  // // different lengths.)\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical numbers).\n  // static final class IntArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     int[] a1 = (int[])o1;\n  //     int[] a2 = (int[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i] - a2[i];\n  //       if (tmp != 0)\n  //         return tmp;\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical objects).\n  // static final class ObjectArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     Object[] a1 = (Object[])o1;\n  //     Object[] a2 = (Object[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i].hashCode() - a2[i].hashCode();\n  //       if (tmp != 0)\n  //         return tmp;\n  //       // I'm counting on the fact that hashCode returns a different\n  //       // number for each Object in the system.  This checks that assumption.\n  //       assert a1[i].equals(a2[i]);\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // private static TreeSet internedIntArrays;\n  // private static TreeSet internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new TreeSet(new IntArrayComparator());\n  //   internedObjectArrays = new TreeSet(new ObjectArrayComparator());\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   boolean added = internedIntArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (int[])internedIntArrays.tailSet(a).first();\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   boolean added = internedObjectArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (Object[])internedObjectArrays.tailSet(a).first();\n  //   }\n  // }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #2\n  ///\n\n  /// This doesn't work because there are no references to the Wrappers,\n  /// so all of the WeakHashMap elements are immediately removed.\n\n  // // Create an ArrayWrapper which redefines equal (and hash) to act the\n  // // way I want them to.\n\n  // static final class IntArrayWrapper {\n  //   private int[] a;\n  //   IntArrayWrapper(int[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(IntArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i];\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // static final class ObjectArrayWrapper {\n  //   private Object[] a;\n  //   ObjectArrayWrapper(Object[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(ObjectArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   // Alternately, just xor all the element hash codes.\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i].hashCode();\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // // Map from an ArrayWrapper to the array (I don't need to map to a\n  // // WeakReference because the array isn't the key of the WeakHashMap).\n\n  // // non-private for debugging only\n  // static WeakHashMap internedIntArrays;\n  // static WeakHashMap internedObjectArrays;\n  // // private static WeakHashMap internedIntArrays;\n  // // private static WeakHashMap internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new WeakHashMap();\n  //   internedObjectArrays = new WeakHashMap();\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   IntArrayWrapper w = new IntArrayWrapper(a);\n  //   Object result = internedIntArrays.get(w);\n  //   if (result != null)\n  //     return (int[])result;\n  //   else {\n  //     internedIntArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   ObjectArrayWrapper w = new ObjectArrayWrapper(a);\n  //   Object result = internedObjectArrays.get(w);\n  //   if (result != null)\n  //     return (Object[])result;\n  //   else {\n  //     internedObjectArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "seq", "", "long[]" ], [ "start", "", "int" ], [ "end", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "equals", "", "long[]", "public boolean equals(Object);" ], [ "toString", "", "long[]", "public String toString()" ], [ "hashCode", "", "long[]", "public native int hashCode()" ], [ "getClass", "", "long[]", "public final native Class getClass();" ], [ "clone", "", "long[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "long[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10322,
  "oracle" : "true ? methodResultID.length <= seq.length;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Intern",
  "javadocTag" : "@return a subsequence of seq from start to end that is interned",
  "methodJavadoc" : "    /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */",
  "methodSourceCode" : "public static double[] internSubsequence(double[] seq, int start, int end){\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}",
  "classJavadoc" : "/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */",
  "classSourceCode" : "package plume;\n\nimport java.lang.ref.WeakReference;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/*>>>\nimport org.checkerframework.checker.interning.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */\npublic final class Intern {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private Intern() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Strings\n  ///\n\n  /**\n   * Replace each element of the array by its interned version.\n   * Side-effects the array, but also returns it.\n   * @param a the array whose elements to intern in place\n   * @return an interned version of a\n   * @see String#intern\n   */\n  @SuppressWarnings(\"interning\") // side-effects the array in place (dangerous, but convenient)\n  public static /*@Interned*/ String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (a[i] != null) {\n        a[i] = a[i].intern();\n      }\n    }\n    return a;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Testing interning\n  ///\n\n  /**\n   * Return true if the argument is interned (is canonical among all\n   * objects equal to itself).\n   * @param value the value to test for interning\n   * @return true iff value is interned\n   */\n  @SuppressWarnings(\"interning\") // interning implementation\n  /*@Pure*/\n  public static boolean isInterned(/*@Nullable*/ Object value) {\n    if (value == null) {\n      // nothing to do\n      return true;\n    } else if (value instanceof String) {\n      return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n      return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n      return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n      return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n      return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n      return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n      return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n      return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n      return (value == intern((Object[]) value));\n    } else {\n      // Nothing to do, because we don't intern other types.\n      // System.out.println(\"What type? \" + value.getClass().getName());\n      return true;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning objects\n  ///\n\n  /**\n   * Hasher object which hashes and compares Integers.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class IntegerHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Integer i = (Integer) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Longs.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class LongHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Long i = (Long) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares int[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(int[], int[])\n   */\n  private static final class IntArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((int[]) a1, (int[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((int[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares long[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals (long[], long[])\n   */\n  private static final class LongArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((long[]) a1, (long[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((long[]) o);\n    }\n  }\n\n  private static final int FACTOR = 23;\n  // private static final double DOUBLE_FACTOR = 65537;\n  private static final double DOUBLE_FACTOR = 263;\n\n  /**\n   * Hasher object which hashes and compares Doubles.\n   * @see Hasher\n   */\n  private static final class DoubleHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Double d = (Double) o;\n      return d.hashCode();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares double[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[],Object[])\n   */\n  private static final class DoubleArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      // \"Arrays.equals\" considers +0.0 != -0.0.\n      // Also, it gives inconsistent results (on different JVMs/classpaths?).\n      // return Arrays.equals((double[])a1, (double[])a2);\n      double[] da1 = (double[]) a1;\n      double[] da2 = (double[]) a2;\n      if (da1.length != da2.length) {\n        return false;\n      }\n      for (int i = 0; i < da1.length; i++) {\n        if (!((da1[i] == da2[i]) || (Double.isNaN(da1[i]) && Double.isNaN(da2[i])))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      double[] a = (double[]) o;\n      // Not Arrays.hashCode(a), for consistency with equals method\n      // immediately above.\n      double running = 0;\n      for (int i = 0; i < a.length; i++) {\n        double elt = (Double.isNaN(a[i]) ? 0.0 : a[i]);\n        running = running * FACTOR + elt * DOUBLE_FACTOR;\n      }\n      // Could add \"... % Integer.MAX_VALUE\" here; is that good to do?\n      long result = Math.round(running);\n      return (int) (result % Integer.MAX_VALUE);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   * Arrays.equals\n   */\n  private static final class StringArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((String[]) a1, (String[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((String[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Object[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[], Object[])\n   */\n  private static final class ObjectArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((/*@Nullable*/ Object[]) a1, (/*@Nullable*/ Object[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((Object[]) o);\n    }\n  }\n\n  // Each of these maps has:\n  //   key = an interned object\n  //   value = a WeakReference for the object itself.\n  // They can be looked up using a non-interned value; equality tests know\n  // nothing of the interning types.\n\n  private static WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>\n      internedIntegers;\n  private static WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>> internedLongs;\n  private static WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>\n      internedIntArrays;\n  private static WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>\n      internedLongArrays;\n  private static WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>\n      internedDoubles;\n  private static /*@Interned*/ Double internedDoubleNaN;\n  private static /*@Interned*/ Double internedDoubleZero;\n  private static WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>\n      internedDoubleArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectArrays;\n  private static WeakHasherMap<\n          SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>\n      internedIntSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>\n      internedLongSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>\n      internedDoubleSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringSequenceAndIndices;\n\n  static {\n    internedIntegers =\n        new WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>(\n            new IntegerHasher());\n    internedLongs =\n        new WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>>(new LongHasher());\n    internedIntArrays =\n        new WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>(\n            new IntArrayHasher());\n    internedLongArrays =\n        new WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>(\n            new LongArrayHasher());\n    internedDoubles =\n        new WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>(\n            new DoubleHasher());\n    internedDoubleNaN = new /*@Interned*/ Double(Double.NaN);\n    internedDoubleZero = new /*@Interned*/ Double(0);\n    internedDoubleArrays =\n        new WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>(\n            new DoubleArrayHasher());\n    internedStringArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new StringArrayHasher());\n    internedObjectArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new ObjectArrayHasher());\n    internedIntSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<int /*@Interned*/ []>());\n    internedLongSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<long /*@Interned*/ []>());\n    internedDoubleSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<double /*@Interned*/ []>());\n    internedObjectSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>());\n    internedStringSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>());\n  }\n\n  // For testing only\n  public static int numIntegers() {\n    return internedIntegers.size();\n  }\n\n  public static int numLongs() {\n    return internedLongs.size();\n  }\n\n  public static int numIntArrays() {\n    return internedIntArrays.size();\n  }\n\n  public static int numLongArrays() {\n    return internedLongArrays.size();\n  }\n\n  public static int numDoubles() {\n    return internedDoubles.size();\n  }\n\n  public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n  }\n\n  public static int numStringArrays() {\n    return internedStringArrays.size();\n  }\n\n  public static int numObjectArrays() {\n    return internedObjectArrays.size();\n  }\n\n  public static Iterator</*@Interned*/ Integer> integers() {\n    return internedIntegers.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Long> longs() {\n    return internedLongs.keySet().iterator();\n  }\n\n  public static Iterator<int /*@Interned*/ []> intArrays() {\n    return internedIntArrays.keySet().iterator();\n  }\n\n  public static Iterator<long /*@Interned*/ []> longArrays() {\n    return internedLongArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Double> doubles() {\n    return internedDoubles.keySet().iterator();\n  }\n\n  public static Iterator<double /*@Interned*/ []> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n  }\n\n  /**\n   * Interns a String.\n   * Delegates to the builtin String.intern() method.\n   * Provided for completeness.\n   * @param a the string to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ String intern(/*@PolyNull*/ String a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n      return null;\n    }\n    return a.intern();\n  }\n\n  /**\n   * Interns a long.\n   * A no-op.  Provided for completeness.\n   * @param l the long to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static long intern(long l) {\n    return l;\n  }\n\n  /**\n   * Interns a double\n   * A no-op.  Provided for completeness.\n   * @param d the double to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static double intern(double d) {\n    return d;\n  }\n\n  /**\n   * Intern (canonicalize) an Integer.\n   * Return a canonical representation for the Integer.\n   * @param a an Integer to canonicalize\n   * @return a canonical representation for the Integer\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Intern.valueOf is intended to promise\n  // the same).  This does not currently take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"}) // interning implementation\n  /*@Pure*/\n  public static /*@Interned*/ Integer intern(Integer a) {\n    WeakReference</*@Interned*/ Integer> lookup = internedIntegers.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Integer result = (/*@Interned*/ Integer) a;\n      internedIntegers.put(result, new WeakReference</*@Interned*/ Integer>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Integer internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Integer parsed from s\n   */\n  public static /*@Interned*/ Integer internedInteger(String s) {\n    return intern(Integer.decode(s));\n  }\n\n  /**\n   * Intern (canonicalize) a Long.\n   * Return a canonical representation for the Long.\n   * @param a the value to intern\n   * @return a canonical representation for the Long\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Long.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Long intern(Long a) {\n    WeakReference</*@Interned*/ Long> lookup = internedLongs.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Long result = (/*@Interned*/ Long) a;\n      internedLongs.put(result, new WeakReference</*@Interned*/ Long>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Long internedLong(long i) {\n    return intern(Long.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Long parsed from s\n   */\n  public static /*@Interned*/ Long internedLong(String s) {\n    return intern(Long.decode(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) an int[].\n   * Return a canonical representation for the int[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the int[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static int /*@Interned*/ [] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n\n    WeakReference<int /*@Interned*/ []> lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ int[] result = (int /*@Interned*/ []) a;\n      internedIntArrays.put(result, new WeakReference<int /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a long[].\n   * Return a canonical representation for the long[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the long[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static long /*@Interned*/ [] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long /*@Interned*/ []> lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ long[] result = (long /*@Interned*/ []) a;\n      internedLongArrays.put(result, new WeakReference<long /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a Double.\n   * Return a canonical representation for the Double.\n   * @param a the Double to canonicalize\n   * @return a canonical representation for the Double\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Double.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Double intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n      return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) { // catches both positive and negative zero\n      return internedDoubleZero;\n    }\n    WeakReference</*@Interned*/ Double> lookup = internedDoubles.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Double result = (/*@Interned*/ Double) a;\n      internedDoubles.put(result, new WeakReference</*@Interned*/ Double>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value i.\n   * @param d the value to intern\n   * @return an interned Double with value d\n   */\n  public static /*@Interned*/ Double internedDouble(double d) {\n    return intern(Double.valueOf(d));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Double parsed from s\n   */\n  public static /*@Interned*/ Double internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) a double[].\n   * Return a canonical representation for the double[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the double[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static double /*@Interned*/ [] intern(double[] a) {\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ double[] result = (double /*@Interned*/ []) a;\n      internedDoubleArrays.put(result, new WeakReference<double /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) an String[].\n   * Return a canonical representation for the String[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the String[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ String[] a) {\n\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n      assert a[k] == Intern.intern(a[k]);\n    }\n\n    WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ String /*@Interned*/ []) a;\n      internedStringArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Intern (canonicalize) an Object[].\n   * Return a canonical representation for the Object[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the Object[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ Object[] a) {\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []) a;\n      internedObjectArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Convenince method to intern an Object when we don't know its\n   * runtime type.  Its runtime type must be one of the types for\n   * which we have an intern() method, else an exception is thrown.\n   * If the argument is an array, its elements should themselves be\n   * interned.\n   * @param a an Object to canonicalize\n   * @return a canonical version of a\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ Object intern(/*@PolyNull*/ Object a) {\n    if (a == null) {\n      return null;\n    } else if (a instanceof String) {\n      return intern((String) a);\n    } else if (a instanceof String[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ String[] asArray = (/*@Interned*/ String[]) a;\n      return intern(asArray);\n    } else if (a instanceof Integer) {\n      return intern((Integer) a);\n    } else if (a instanceof Long) {\n      return intern((Long) a);\n    } else if (a instanceof int[]) {\n      return intern((int[]) a);\n    } else if (a instanceof long[]) {\n      return intern((long[]) a);\n    } else if (a instanceof Double) {\n      return intern((Double) a);\n    } else if (a instanceof double[]) {\n      return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ Object[] asArray = (/*@Interned*/ Object[]) a;\n      return intern(asArray);\n    } else {\n      throw new IllegalArgumentException(\n          \"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n  }\n\n  /**\n   * Return the subsequence of seq from start (inclusive) to end\n   * (exclusive) that is interned.  What's different about this method\n   * from manually finding the subsequence and interning the\n   * subsequence is that if the subsequence is already interned, we\n   * can avoid having to compute the sequence.  Since derived\n   * variables in Daikon compute the subsequence many times, this\n   * shortcut saves quite a bit of computation.  It saves even more\n   * when there may be many derived variables that are non-canonical,\n   * since they are guaranteed to be ==.\n   * <p>\n   * Requires that seq is already interned.\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   */\n  public static int /*@Interned*/ [] internSubsequence(int /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int /*@Interned*/ []> sai =\n        new SequenceAndIndices<int /*@Interned*/ []>(seq, start, end);\n    WeakReference<int /*@Interned*/ []> lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n      int /*@Interned*/ [] subseq = Intern.intern(subseqUninterned);\n      internedIntSequenceAndIndices.put(sai, new WeakReference<int /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static long /*@Interned*/ [] internSubsequence(\n      long /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long /*@Interned*/ []> sai =\n        new SequenceAndIndices<long /*@Interned*/ []>(seq, start, end);\n    WeakReference<long /*@Interned*/ []> lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      long /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedLongSequenceAndIndices.put(sai, new WeakReference<long /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static double /*@Interned*/ [] internSubsequence(\n      double /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double /*@Interned*/ []> sai =\n        new SequenceAndIndices<double /*@Interned*/ []>(seq, start, end);\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      double /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedDoubleSequenceAndIndices.put(sai, new WeakReference<double /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedObjectSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedStringSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * Data structure for storing triples of a sequence and start and\n   * end indices, to represent a subsequence.  Requires that the\n   * sequence be interned.  Used for interning the repeated finding\n   * of subsequences on the same sequence.\n   */\n  private static final class SequenceAndIndices<T extends /*@Interned*/ Object> {\n    public T seq;\n    public int start;\n    public int end;\n\n    /**\n     * @param seq an interned array\n     */\n    public SequenceAndIndices(T seq, int start, int end) {\n      this.seq = seq;\n      this.start = start;\n      this.end = end;\n      assert isInterned(seq);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ /*@Nullable*/ Object other) {\n      if (other instanceof SequenceAndIndices<?>) {\n        @SuppressWarnings(\"unchecked\")\n        SequenceAndIndices<T> other_sai = (SequenceAndIndices<T>) other;\n        return equals(other_sai);\n      } else {\n        return false;\n      }\n    }\n\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ SequenceAndIndices<T> other) {\n      return ((this.seq == other.seq) && this.start == other.start && this.end == other.end);\n    }\n\n    /*@Pure*/\n    public int hashCode(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return seq.hashCode() + start * 30 - end * 2;\n    }\n\n    // For debugging\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return \"SAI(\" + start + \",\" + end + \") from: \" + ArraysMDE.toString(seq);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   */\n  private static final class SequenceAndIndicesHasher<T extends /*@Interned*/ Object>\n      implements Hasher {\n    public boolean equals(Object a1, Object a2) {\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai1 = (SequenceAndIndices<T>) a1;\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai2 = (SequenceAndIndices<T>) a2;\n      // The SAI objects are *not* interned, but the arrays inside them are.\n      return sai1.equals(sai2);\n    }\n\n    public int hashCode(Object o) {\n      return o.hashCode();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #1\n  ///\n\n  /// Interning arrays:  old implmentation.\n  /// The problem with this is that it doesn't release keys.\n  // // I can also use Arrays.equals() to compare two arrays of base\n  // // or Object type; but that doesn't do ordering.  (It does properly deal\n  // // with the possibility that the argument is null, which this doesn't\n  // // right now.  I may want to err in this implementation if the arguments\n  // // are null or the lengths are not equal -- if I never mix arrays of\n  // // different lengths.)\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical numbers).\n  // static final class IntArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     int[] a1 = (int[])o1;\n  //     int[] a2 = (int[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i] - a2[i];\n  //       if (tmp != 0)\n  //         return tmp;\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical objects).\n  // static final class ObjectArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     Object[] a1 = (Object[])o1;\n  //     Object[] a2 = (Object[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i].hashCode() - a2[i].hashCode();\n  //       if (tmp != 0)\n  //         return tmp;\n  //       // I'm counting on the fact that hashCode returns a different\n  //       // number for each Object in the system.  This checks that assumption.\n  //       assert a1[i].equals(a2[i]);\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // private static TreeSet internedIntArrays;\n  // private static TreeSet internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new TreeSet(new IntArrayComparator());\n  //   internedObjectArrays = new TreeSet(new ObjectArrayComparator());\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   boolean added = internedIntArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (int[])internedIntArrays.tailSet(a).first();\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   boolean added = internedObjectArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (Object[])internedObjectArrays.tailSet(a).first();\n  //   }\n  // }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #2\n  ///\n\n  /// This doesn't work because there are no references to the Wrappers,\n  /// so all of the WeakHashMap elements are immediately removed.\n\n  // // Create an ArrayWrapper which redefines equal (and hash) to act the\n  // // way I want them to.\n\n  // static final class IntArrayWrapper {\n  //   private int[] a;\n  //   IntArrayWrapper(int[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(IntArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i];\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // static final class ObjectArrayWrapper {\n  //   private Object[] a;\n  //   ObjectArrayWrapper(Object[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(ObjectArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   // Alternately, just xor all the element hash codes.\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i].hashCode();\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // // Map from an ArrayWrapper to the array (I don't need to map to a\n  // // WeakReference because the array isn't the key of the WeakHashMap).\n\n  // // non-private for debugging only\n  // static WeakHashMap internedIntArrays;\n  // static WeakHashMap internedObjectArrays;\n  // // private static WeakHashMap internedIntArrays;\n  // // private static WeakHashMap internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new WeakHashMap();\n  //   internedObjectArrays = new WeakHashMap();\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   IntArrayWrapper w = new IntArrayWrapper(a);\n  //   Object result = internedIntArrays.get(w);\n  //   if (result != null)\n  //     return (int[])result;\n  //   else {\n  //     internedIntArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   ObjectArrayWrapper w = new ObjectArrayWrapper(a);\n  //   Object result = internedObjectArrays.get(w);\n  //   if (result != null)\n  //     return (Object[])result;\n  //   else {\n  //     internedObjectArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "seq", "", "double[]" ], [ "start", "", "int" ], [ "end", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "", "double[]", "public boolean equals(Object);" ], [ "toString", "", "double[]", "public String toString()" ], [ "hashCode", "", "double[]", "public native int hashCode()" ], [ "getClass", "", "double[]", "public final native Class getClass();" ], [ "clone", "", "double[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "double[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]