[
    {
        "id": 23635,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.geometry.euclidean.threed",
        "className": "FieldRotation",
        "javadocTag": "@param a0 first array element",
        "methodJavadoc": "    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */",
        "methodSourceCode": "private T[] buildArray(final T a0, final T a1, final T a2){\n    final T[] array = MathArrays.buildArray(a0.getField(), 3);\n    array[0] = a0;\n    array[1] = a1;\n    array[2] = a2;\n    return array;\n}",
        "classJavadoc": "/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.RealFieldElement;\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */\n\npublic class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 20130224l;\n\n    /** Scalar coordinate of the quaternion. */\n    private final T q0;\n\n    /** First coordinate of the vectorial part of the quaternion. */\n    private final T q1;\n\n    /** Second coordinate of the vectorial part of the quaternion. */\n    private final T q2;\n\n    /** Third coordinate of the vectorial part of the quaternion. */\n    private final T q3;\n\n    /** Build a rotation from the quaternion coordinates.\n     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n     * the constructor can normalize it in a preprocessing step.</p>\n     * <p>Note that some conventions put the scalar part of the quaternion\n     * as the 4<sup>th</sup> component and the vector part as the first three\n     * components. This is <em>not</em> our convention. We put the scalar part\n     * as the first component.</p>\n     * @param q0 scalar part of the quaternion\n     * @param q1 first coordinate of the vectorial part of the quaternion\n     * @param q2 second coordinate of the vectorial part of the quaternion\n     * @param q3 third coordinate of the vectorial part of the quaternion\n     * @param needsNormalization if true, the coordinates are considered\n     * not to be normalized, a normalization preprocessing step is performed\n     * before using them\n     */\n    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n\n        if (needsNormalization) {\n            // normalization preprocessing\n            final T inv =\n                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n            this.q0 = inv.multiply(q0);\n            this.q1 = inv.multiply(q1);\n            this.q2 = inv.multiply(q2);\n            this.q3 = inv.multiply(q3);\n        } else {\n            this.q0 = q0;\n            this.q1 = q1;\n            this.q2 = q2;\n            this.q3 = q3;\n        }\n\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}\n     */\n    @Deprecated\n    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n        throws MathIllegalArgumentException {\n        this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @param convention convention to use for the semantics of the angle\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @since 3.6\n     */\n    public FieldRotation(final FieldVector3D<T> axis, final T angle, final RotationConvention convention)\n        throws MathIllegalArgumentException {\n\n        final T norm = axis.getNorm();\n        if (norm.getReal() == 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n        }\n\n        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);\n        final T coeff = halfAngle.sin().divide(norm);\n\n        q0 = halfAngle.cos();\n        q1 = coeff.multiply(axis.getX());\n        q2 = coeff.multiply(axis.getY());\n        q3 = coeff.multiply(axis.getZ());\n\n    }\n\n    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @exception NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */\n    public FieldRotation(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        // dimension check\n        if ((m.length != 3) || (m[0].length != 3) ||\n                (m[1].length != 3) || (m[2].length != 3)) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                  m.length, m[0].length);\n        }\n\n        // compute a \"close\" orthogonal matrix\n        final T[][] ort = orthogonalizeMatrix(m, threshold);\n\n        // check the sign of the determinant\n        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n        final T det =\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n        if (det.getReal() < 0.0) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n                                                  det);\n        }\n\n        final T[] quat = mat2quat(ort);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build the rotation that transforms a pair of vectors into another pair.\n\n     * <p>Except for possible scale factors, if the instance were applied to\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n     * not the same as the angular separation between v<sub>1</sub> and\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>,\n     * +v<sub>2</sub>) half-plane.</p>\n\n     * @param u1 first vector of the origin pair\n     * @param u2 second vector of the origin pair\n     * @param v1 desired image of u1 by the rotation\n     * @param v2 desired image of u2 by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\n     */\n    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n        throws MathArithmeticException {\n\n        // build orthonormalized base from u1, u2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n        u1 = u1.normalize();\n\n        // build an orthonormalized base from v1, v2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n        v1 = v1.normalize();\n\n        // buid a matrix transforming the first base into the second one\n        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n\n        T[] quat = mat2quat(array);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build one of the rotations that transform one vector into another one.\n\n     * <p>Except for a possible scale factor, if the instance were\n     * applied to the vector u it will produce the vector v. There is an\n     * infinite number of such rotations, this constructor choose the\n     * one with the smallest associated angle (i.e. the one whose axis\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\n     * arbitrary rotation axis is chosen.</p>\n\n     * @param u origin vector\n     * @param v desired image of u by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero\n     */\n    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n\n        final T normProduct = u.getNorm().multiply(v.getNorm());\n        if (normProduct.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n        }\n\n        final T dot = FieldVector3D.dotProduct(u, v);\n\n        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n            // special case u = -v: we select a PI angle rotation around\n            // an arbitrary vector orthogonal to u\n            final FieldVector3D<T> w = u.orthogonal();\n            q0 = normProduct.getField().getZero();\n            q1 = w.getX().negate();\n            q2 = w.getY().negate();\n            q3 = w.getZ().negate();\n        } else {\n            // general case: (u, v) defines a plane, we select\n            // the shortest possible rotation: axis orthogonal to this plane\n            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n            q1 = coeff.multiply(q.getX());\n            q2 = coeff.multiply(q.getY());\n            q3 = coeff.multiply(q.getZ());\n        }\n\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to use\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(RotationOrder, RotationConvention,\n     * RealFieldElement, RealFieldElement, RealFieldElement)}\n     */\n    @Deprecated\n    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to compose, from left to right\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\n     * @param convention convention to use for the semantics of the angle\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @since 3.6\n     */\n    public FieldRotation(final RotationOrder order, final RotationConvention convention,\n                         final T alpha1, final T alpha2, final T alpha3) {\n        final T one = alpha1.getField().getOne();\n        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1, convention);\n        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2, convention);\n        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3, convention);\n        final FieldRotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\n        q0 = composed.q0;\n        q1 = composed.q1;\n        q2 = composed.q2;\n        q3 = composed.q3;\n    }\n\n    /** Convert an orthogonal rotation matrix to a quaternion.\n     * @param ort orthogonal rotation matrix\n     * @return quaternion corresponding to the matrix\n     */\n    private T[] mat2quat(final T[][] ort) {\n\n        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n\n        // There are different ways to compute the quaternions elements\n        // from the matrix. They all involve computing one element from\n        // the diagonal of the matrix, and computing the three other ones\n        // using a formula involving a division by the first element,\n        // which unfortunately can be zero. Since the norm of the\n        // quaternion is 1, we know at least one element has an absolute\n        // value greater or equal to 0.5, so it is always possible to\n        // select the right formula and avoid division by zero and even\n        // numerical inaccuracy. Checking the elements in turn and using\n        // the first one greater than 0.45 is safe (this leads to a simple\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n        if (s.getReal() > -0.19) {\n            // compute q0 and deduce q1, q2 and q3\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n            T inv = quat[0].reciprocal().multiply(0.25);\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n        } else {\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n            if (s.getReal() > -0.19) {\n                // compute q1 and deduce q0, q2 and q3\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n                T inv = quat[1].reciprocal().multiply(0.25);\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n            } else {\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n                if (s.getReal() > -0.19) {\n                    // compute q2 and deduce q0, q1 and q3\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[2].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n                } else {\n                    // compute q3 and deduce q0, q1 and q2\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[3].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n                }\n            }\n        }\n\n        return quat;\n\n    }\n\n    /** Revert a rotation.\n     * Build a rotation which reverse the effect of another\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n     * instance is not changed.\n     * @return a new rotation whose effect is the reverse of the effect\n     * of the instance\n     */\n    public FieldRotation<T> revert() {\n        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n    }\n\n    /** Get the scalar coordinate of the quaternion.\n     * @return scalar coordinate of the quaternion\n     */\n    public T getQ0() {\n        return q0;\n    }\n\n    /** Get the first coordinate of the vectorial part of the quaternion.\n     * @return first coordinate of the vectorial part of the quaternion\n     */\n    public T getQ1() {\n        return q1;\n    }\n\n    /** Get the second coordinate of the vectorial part of the quaternion.\n     * @return second coordinate of the vectorial part of the quaternion\n     */\n    public T getQ2() {\n        return q2;\n    }\n\n    /** Get the third coordinate of the vectorial part of the quaternion.\n     * @return third coordinate of the vectorial part of the quaternion\n     */\n    public T getQ3() {\n        return q3;\n    }\n\n    /** Get the normalized axis of the rotation.\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}\n     */\n    @Deprecated\n    public FieldVector3D<T> getAxis() {\n        return getAxis(RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the normalized axis of the rotation.\n     * <p>\n     * Note that as {@link #getAngle()} always returns an angle\n     * between 0 and &pi;, changing the convention changes the\n     * direction of the axis, not the sign of the angle.\n     * </p>\n     * @param convention convention to use for the semantics of the angle\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @since 3.6\n     */\n    public FieldVector3D<T> getAxis(final RotationConvention convention) {\n        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n        if (squaredSine.getReal() == 0) {\n            final Field<T> field = squaredSine.getField();\n            return new FieldVector3D<T>(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),\n                                        field.getZero(),\n                                        field.getZero());\n        } else {\n            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n            if (q0.getReal() < 0) {\n                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);\n                return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n            }\n            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);\n            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n        }\n    }\n\n    /** Get the angle of the rotation.\n     * @return angle of the rotation (between 0 and &pi;)\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     */\n    public T getAngle() {\n        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n        } else if (q0.getReal() < 0) {\n            return q0.negate().acos().multiply(2);\n        }\n        return q0.acos().multiply(2);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}\n     */\n    @Deprecated\n    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n        return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @param convention convention to use for the semantics of the angle\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @since 3.6\n     */\n    public T[] getAngles(final RotationOrder order, RotationConvention convention)\n        throws CardanEulerSingularityException {\n\n        if (convention == RotationConvention.VECTOR_OPERATOR) {\n            if (order == RotationOrder.XYZ) {\n\n                // r (+K) coordinates are :\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (+I) coordinates are :\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                                  v2.getZ().asin(),\n                                  v2.getY().negate().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (+J) coordinates are :\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n                // (-r) (+I) coordinates are :\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getY().asin().negate(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (+K) coordinates are :\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getZ().asin().negate(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (+I) coordinates are :\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                                  v2.getX().asin(),\n                                  v2.getZ().negate().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (+J) coordinates are :\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().negate().atan2(v1.getY()),\n                                  v2.getY().asin(),\n                                  v2.getX().negate().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getX().asin().negate(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n                // (-r) (+I) coordinates are :\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (+I) coordinates are :\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n                // (-r) (+I) coordinates are :\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getX().acos(),\n                                  v2.getZ().atan2(v2.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (+J) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // (-r) (+J) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getY().acos(),\n                                  v2.getX().atan2(v2.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (+J) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                                  v2.getY().acos(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (+K) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // (-r) (+K) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (+K) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getZ().acos(),\n                                  v2.getY().atan2(v2.getX().negate()));\n\n            }\n        } else {\n            if (order == RotationOrder.XYZ) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().negate().atan2(v2.getZ()),\n                                  v2.getX().asin(),\n                                  v1.getY().negate().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().asin().negate(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().asin().negate(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().negate().atan2(v2.getX()),\n                                  v2.getY().asin(),\n                                  v1.getZ().negate().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().negate().atan2(v2.getY()),\n                                  v2.getZ().asin(),\n                                  v1.getX().negate().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().asin().negate(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().acos(),\n                                  v1.getZ().atan2(v1.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().acos(),\n                                  v1.getX().atan2(v1.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getX().negate()),\n                                  v2.getY().acos(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (Vector3D.plusK) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (Vector3D.plusK) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().acos(),\n                                  v1.getY().atan2(v1.getX().negate()));\n\n            }\n        }\n\n    }\n\n    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */\n    private T[] buildArray(final T a0, final T a1, final T a2) {\n        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n        array[0] = a0;\n        array[1] = a1;\n        array[2] = a2;\n        return array;\n    }\n\n    /** Create a constant vector.\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @return a constant vector\n     */\n    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n        final T zero = q0.getField().getZero();\n        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n    }\n\n    /** Get the 3X3 matrix corresponding to the instance\n     * @return the matrix corresponding to the instance\n     */\n    public T[][] getMatrix() {\n\n        // products\n        final T q0q0  = q0.multiply(q0);\n        final T q0q1  = q0.multiply(q1);\n        final T q0q2  = q0.multiply(q2);\n        final T q0q3  = q0.multiply(q3);\n        final T q1q1  = q1.multiply(q1);\n        final T q1q2  = q1.multiply(q2);\n        final T q1q3  = q1.multiply(q3);\n        final T q2q2  = q2.multiply(q2);\n        final T q2q3  = q2.multiply(q3);\n        final T q3q3  = q3.multiply(q3);\n\n        // create the matrix\n        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n\n        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n        m [2][0] = q1q3.add(q0q2).multiply(2);\n\n        m [0][1] = q1q2.add(q0q3).multiply(2);\n        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n\n        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n        m [1][2] = q2q3.add(q0q1).multiply(2);\n        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n\n        return m;\n\n    }\n\n    /** Convert to a constant vector without derivatives.\n     * @return a constant vector\n     */\n    public Rotation toRotation() {\n        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n\n        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyInverseTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyInverseTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the inverse of the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n        final double m0 = -r.getQ0();\n\n        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(FieldRotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : r.composeInternal(this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n                                    false);\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(Rotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final Rotation r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : applyTo(r, this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n                        q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n                        false);\n    }\n\n    /** Apply a rotation to another rotation.\n     * Applying a rotation to another rotation is computing the composition\n     * in an order compliant with the following rule : let u be any\n     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n     * where comp = applyTo(rOuter, rInner).\n     * @param r1 rotation to apply\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(FieldRotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : r.composeInternal(revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(Rotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final Rotation r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : applyTo(r, revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n                                    false);\n    }\n\n    /** Apply the inverse of a rotation to another rotation.\n     * Applying the inverse of a rotation to another rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n     * let w be the inverse image of v by rOuter\n     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n     * comp = applyInverseTo(rOuter, rInner).\n     * @param rOuter rotation to apply the rotation to\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n                                    false);\n    }\n\n    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @exception NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */\n    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        T x00 = m[0][0];\n        T x01 = m[0][1];\n        T x02 = m[0][2];\n        T x10 = m[1][0];\n        T x11 = m[1][1];\n        T x12 = m[1][2];\n        T x20 = m[2][0];\n        T x21 = m[2][1];\n        T x22 = m[2][2];\n        double fn = 0;\n        double fn1;\n\n        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n        int i = 0;\n        while (++i < 11) {\n\n            // Mt.Xn\n            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n\n            // Xn+1\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n\n            // correction on each elements\n            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n\n            // Frobenius norm of the correction\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n            // convergence test\n            if (FastMath.abs(fn1 - fn) <= threshold) {\n                return o;\n            }\n\n            // prepare next iteration\n            x00 = o[0][0];\n            x01 = o[0][1];\n            x02 = o[0][2];\n            x10 = o[1][0];\n            x11 = o[1][1];\n            x12 = o[1][2];\n            x20 = o[2][0];\n            x21 = o[2][1];\n            x22 = o[2][2];\n            fn  = fn1;\n\n        }\n\n        // the algorithm did not converge after 10 iterations\n        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n                                              i - 1);\n\n    }\n\n    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */\n    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n        return r1.composeInverseInternal(r2).getAngle();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static boolean isPrime(int n)"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static int nextPrime(int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int smallTrialDivision(int n, final List<Integer> factors)"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors)"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static List<Integer> trialDivision(int n)"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static boolean millerRabinPrimeTest(final int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int rhoBrent(final int n)"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int gcdPositive(int a, int b)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "public static GaussianCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "public static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights)"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights)"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter)"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker)"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "public static HarmonicCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "public static PolynomialCurveFitter create(int degree)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction compose(final UnivariateFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction add(final UnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction multiply(final UnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue)"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f)"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f)"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f)"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f)"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double midpoint(double a, double b)"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isSequence(final double start, final double mid, final double end)"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "public static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createConstant(final double value)"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createVariable(final int idx, final double value)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient hypot(final SparseGradient x, final SparseGradient y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient pow(final double a, final SparseGradient x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient atan2(final SparseGradient y, final SparseGradient x)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure pow(final double a, final DerivativeStructure x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "public static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createChebyshevPolynomial(final int degree)"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createHermitePolynomial(final int degree)"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLaguerrePolynomial(final int degree)"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLegendrePolynomial(final int degree)"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w)"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static double[] shift(final double[] coefficients, final double shift)"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "protected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(double x, double y, double eps)"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(final double x, final double y, final int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y, float eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, float eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final float x, final float y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsWithRelativeTolerance(double x, double y, double eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, double eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final double x, final double y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, int maxUlps)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale, int roundingMethod)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double representableDelta(double x, double originalDelta)"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor wrap(final IntegerSequence.Incrementor incrementor)"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] scale(double val, final double[] arr)"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double cosAngle(double[] v1, double[] v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(double[] a, double[] b, boolean abort)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(int[] a, int[] b, boolean abort)"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double safeNorm(double[] v)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source, int len)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source, int len)"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOfRange(double[] source, int from, int to)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(float[] x, float[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(float[] x, float[] y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(double[] x, double[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(double[] x, double[] y)"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] natural(int n)"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] sequence(int size, int start, int stride)"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] concatenate(double[]... x)"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] unique(double[] data)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "public static <K, V> Pair<K, V> create(K k, V v)"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowCos(final double x, final double[] result)"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowSin(final double x, final double[] result)"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowexp(final double x, final double[] result)"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double expint(int p, final double[] result)"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double[] slowLog(double xi)"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static String format(double d)"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sqrt(final double a)"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cosh(double x)"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sinh(double x)"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tanh(double x)"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acosh(final double a)"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asinh(double a)"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atanh(double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double signum(final double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float signum(final float a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextUp(final double a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextUp(final float a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextDown(final double a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextDown(final float a)"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double random()"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double exp(double x)"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double expm1(double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(final double x)"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log1p(final double x)"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log10(final double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(double base, double x)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(final double x, final double y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, int e)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, long e)"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sin(double x)"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cos(double x)"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tan(double x)"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan(double x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan2(double y, double x)"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asin(double x)"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acos(double x)"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cbrt(double x)"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toRadians(double x)"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toDegrees(double x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int abs(final int x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long abs(final long x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float abs(final float x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double abs(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ulp(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float ulp(float x)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double scalb(final double d, final int n)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float scalb(final float f, final int n)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextAfter(double d, double direction)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextAfter(final float f, final double direction)"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double floor(double x)"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ceil(double x)"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double rint(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long round(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int round(final float x)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int min(final int a, final int b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long min(final long a, final long b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float min(final float a, final float b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double min(final double a, final double b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int max(final int a, final int b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long max(final long a, final long b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float max(final float a, final float b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double max(final double a, final double b)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double hypot(final double x, final double y)"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double IEEEremainder(double dividend, double divisor)"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int toIntExact(final long n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int incrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long incrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int decrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long decrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int addExact(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long addExact(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int subtractExact(final int a, final int b)"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long subtractExact(final long a, final long b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int multiplyExact(final int a, final int b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long multiplyExact(final long a, final long b)"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorDiv(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorDiv(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorMod(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorMod(final long a, final long b)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double copySign(double magnitude, double sign)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float copySign(float magnitude, float sign)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final double d)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final float f)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "public static BigRealField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "public static final Decimal64Field getInstance()"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double value)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static boolean equals(double x, double y)"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double[] value)"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double normalizeAngle(double a, double center)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T max(final T e1, final T e2)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T min(final T e1, final T e2)"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double reduce(double a, double period, double offset)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static byte copySign(byte magnitude, byte sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static short copySign(short magnitude, short sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int copySign(int magnitude, int sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static long copySign(long magnitude, long sign) throws MathArithmeticException"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos)"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos)"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(int start, int end)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(final int start, final int max, final int step)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Incrementor create()"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor create()"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntA()"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntB()"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracA()"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracB()"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[][] loadLnMant()"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static Iterator<int[]> combinationsIterator(int n, int k)"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int addAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long addAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int gcd(int p, int q) throws MathArithmeticException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long gcd(final long p, final long q) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int lcm(int a, int b) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long lcm(long a, long b) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int mulAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long mulAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int subAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long subAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static boolean isPowerOfTwo(long n)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(Locale locale)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "public static ComplexField getInstance()"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion multiply(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion add(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion subtract(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static double dotProduct(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart, double imaginaryPart)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart)"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex[] convertToComplex(double[] real)"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance(final Locale locale)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(final int rows, final int columns)"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealIdentityMatrix(int dimension)"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension)"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal)"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal)"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static boolean isSymmetric(RealMatrix matrix, double eps)"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m)"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m)"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix blockInverse(RealMatrix m, int splitIndex)"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] createBlocksLayout(final int rows, final int columns)"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "public static RealVector unmodifiableRealVector(final RealVector v)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance(final Locale locale)"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "public static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getStirlingError(double z)"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getDeviancePart(double x, double mu)"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double logBinomialProbability(int x, int n, double p, double q)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper2(final double x)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper2(final double x)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "public static MaxIter unlimited()"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "public static SimpleBounds unbounded(int dim)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "public static MaxEval unlimited()"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x)"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfc(double x)"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x1, double x2)"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfInv(final double x)"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfcInv(final double x)"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static BesselJResult rjBesl(double x, double alpha, int nb)"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma(double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(double a, double x)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double digamma(double x)"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double trigamma(double x)"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double lanczos(final double x)"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double invGamma1pm1(final double x)"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double gamma(final double x)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, double epsilon)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, int maxIterations)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(double a, double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(final double p, final double q)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "public static DummyStepHandler getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "public static AdamsNordsieckTransformer getInstance(final int nSteps)"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "public static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps)"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] normalize(final double[] sample)"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample) throws MathIllegalArgumentException"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample, final int begin, final int length)"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double exactP(double d, int m, int n, boolean strict)"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double approximateP(double d, int n, int m)"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double monteCarloP(double d, int n, int m, boolean strict, int iterations)"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "public static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics)"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final double min, final double max)"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc)"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final DfpField field, final String a)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final Dfp a)"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp splitPow(final Dfp[] base, int a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp base, int a)"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp exp(final Dfp a)"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp expInternal(final Dfp a)"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp log(Dfp a)"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] logInternal(final Dfp[] a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp x, final Dfp y)"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp sinInternal(Dfp[] a)"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp cosInternal(Dfp[] a)"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp sin(final Dfp a)"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp cos(Dfp a)"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp tan(final Dfp a)"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp atanInternal(final Dfp a)"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp atan(final Dfp a)"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp asin(final Dfp a)"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp acos(Dfp a)"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static Dfp copysign(final Dfp x, final Dfp y)"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeExp(final Dfp a, final Dfp one)"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two)"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "public static synchronized RandomGenerator getRandomGenerator()"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> randomPermutation(final int l)"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> identityPermutation(final int l)"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator)"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "public static List<Integer> randomBinaryRepresentation(int length)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static double distance(Rotation r1, Rotation r2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "public static Euclidean3D getInstance()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double dotProduct(Vector3D v1, Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance1(Vector3D v1, Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceInf(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceSq(Vector3D v1, Vector3D v2)"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "public static Euclidean1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance(final Locale locale)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distance(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceInf(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceSq(Vector1D p1, Vector1D p2)"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distance(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceInf(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceSq(Vector2D p1, Vector2D p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "public static Euclidean2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static double distance(S1Point p1, S1Point p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "public static Sphere1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "public static Sphere2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "public static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static double distance(S2Point p1, S2Point p2)"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "public static Random createAdaptor(RandomGenerator randomGenerator)"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static RandomGenerator createRandomGenerator(final Random rng)"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static long convertToLong(int[] seed)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static String formatBigFraction(final BigFraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static Fraction getReducedFraction(int numerator, int denominator)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static BigFraction getReducedFraction(final int numerator, final int denominator)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static String formatFraction(Fraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "public static FractionField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "public static BigFractionField getInstance()"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "public static Object[] flatten(Object[] array)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[] scaleArray(double[] f, double d)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] scaleArray(Complex[] f, double d)"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[][] createRealImaginaryArray(final Complex[] dataC)"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static int exactLog2(final int n) throws MathIllegalArgumentException"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "static final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "public static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "public static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "public static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "public static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "protected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "static final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "static final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "static final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "static final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "3",
                "int"
            ],
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "a0",
                "",
                "RealFieldElement"
            ],
            [
                "a1",
                "",
                "RealFieldElement"
            ],
            [
                "a2",
                "",
                "RealFieldElement"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final Rotation r)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getAngle()"
            ],
            [
                "toRotation",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public Rotation toRotation()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order, RotationConvention convention) throws CardanEulerSingularityException"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final Vector3D u)"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order) throws CardanEulerSingularityException"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ2()"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ3()"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> revert()"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ1()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis(final RotationConvention convention)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final FieldRotation<T> r)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final FieldRotation<T> r)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final Rotation r)"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[][] getMatrix()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ0()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final Vector3D u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final FieldVector3D<T> u)"
            ],
            [
                "equals",
                "",
                "T[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "T[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "T[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "T[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "T[]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "length",
                "",
                "T[]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 23654,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.geometry.euclidean.threed",
        "className": "FieldRotation",
        "javadocTag": "@param u vector to apply the rotation to",
        "methodJavadoc": "    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */",
        "methodSourceCode": "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u){\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}",
        "classJavadoc": "/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.RealFieldElement;\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */\n\npublic class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 20130224l;\n\n    /** Scalar coordinate of the quaternion. */\n    private final T q0;\n\n    /** First coordinate of the vectorial part of the quaternion. */\n    private final T q1;\n\n    /** Second coordinate of the vectorial part of the quaternion. */\n    private final T q2;\n\n    /** Third coordinate of the vectorial part of the quaternion. */\n    private final T q3;\n\n    /** Build a rotation from the quaternion coordinates.\n     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n     * the constructor can normalize it in a preprocessing step.</p>\n     * <p>Note that some conventions put the scalar part of the quaternion\n     * as the 4<sup>th</sup> component and the vector part as the first three\n     * components. This is <em>not</em> our convention. We put the scalar part\n     * as the first component.</p>\n     * @param q0 scalar part of the quaternion\n     * @param q1 first coordinate of the vectorial part of the quaternion\n     * @param q2 second coordinate of the vectorial part of the quaternion\n     * @param q3 third coordinate of the vectorial part of the quaternion\n     * @param needsNormalization if true, the coordinates are considered\n     * not to be normalized, a normalization preprocessing step is performed\n     * before using them\n     */\n    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n\n        if (needsNormalization) {\n            // normalization preprocessing\n            final T inv =\n                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n            this.q0 = inv.multiply(q0);\n            this.q1 = inv.multiply(q1);\n            this.q2 = inv.multiply(q2);\n            this.q3 = inv.multiply(q3);\n        } else {\n            this.q0 = q0;\n            this.q1 = q1;\n            this.q2 = q2;\n            this.q3 = q3;\n        }\n\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}\n     */\n    @Deprecated\n    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n        throws MathIllegalArgumentException {\n        this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @param convention convention to use for the semantics of the angle\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @since 3.6\n     */\n    public FieldRotation(final FieldVector3D<T> axis, final T angle, final RotationConvention convention)\n        throws MathIllegalArgumentException {\n\n        final T norm = axis.getNorm();\n        if (norm.getReal() == 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n        }\n\n        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);\n        final T coeff = halfAngle.sin().divide(norm);\n\n        q0 = halfAngle.cos();\n        q1 = coeff.multiply(axis.getX());\n        q2 = coeff.multiply(axis.getY());\n        q3 = coeff.multiply(axis.getZ());\n\n    }\n\n    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @exception NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */\n    public FieldRotation(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        // dimension check\n        if ((m.length != 3) || (m[0].length != 3) ||\n                (m[1].length != 3) || (m[2].length != 3)) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                  m.length, m[0].length);\n        }\n\n        // compute a \"close\" orthogonal matrix\n        final T[][] ort = orthogonalizeMatrix(m, threshold);\n\n        // check the sign of the determinant\n        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n        final T det =\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n        if (det.getReal() < 0.0) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n                                                  det);\n        }\n\n        final T[] quat = mat2quat(ort);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build the rotation that transforms a pair of vectors into another pair.\n\n     * <p>Except for possible scale factors, if the instance were applied to\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n     * not the same as the angular separation between v<sub>1</sub> and\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>,\n     * +v<sub>2</sub>) half-plane.</p>\n\n     * @param u1 first vector of the origin pair\n     * @param u2 second vector of the origin pair\n     * @param v1 desired image of u1 by the rotation\n     * @param v2 desired image of u2 by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\n     */\n    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n        throws MathArithmeticException {\n\n        // build orthonormalized base from u1, u2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n        u1 = u1.normalize();\n\n        // build an orthonormalized base from v1, v2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n        v1 = v1.normalize();\n\n        // buid a matrix transforming the first base into the second one\n        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n\n        T[] quat = mat2quat(array);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build one of the rotations that transform one vector into another one.\n\n     * <p>Except for a possible scale factor, if the instance were\n     * applied to the vector u it will produce the vector v. There is an\n     * infinite number of such rotations, this constructor choose the\n     * one with the smallest associated angle (i.e. the one whose axis\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\n     * arbitrary rotation axis is chosen.</p>\n\n     * @param u origin vector\n     * @param v desired image of u by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero\n     */\n    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n\n        final T normProduct = u.getNorm().multiply(v.getNorm());\n        if (normProduct.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n        }\n\n        final T dot = FieldVector3D.dotProduct(u, v);\n\n        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n            // special case u = -v: we select a PI angle rotation around\n            // an arbitrary vector orthogonal to u\n            final FieldVector3D<T> w = u.orthogonal();\n            q0 = normProduct.getField().getZero();\n            q1 = w.getX().negate();\n            q2 = w.getY().negate();\n            q3 = w.getZ().negate();\n        } else {\n            // general case: (u, v) defines a plane, we select\n            // the shortest possible rotation: axis orthogonal to this plane\n            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n            q1 = coeff.multiply(q.getX());\n            q2 = coeff.multiply(q.getY());\n            q3 = coeff.multiply(q.getZ());\n        }\n\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to use\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(RotationOrder, RotationConvention,\n     * RealFieldElement, RealFieldElement, RealFieldElement)}\n     */\n    @Deprecated\n    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to compose, from left to right\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\n     * @param convention convention to use for the semantics of the angle\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @since 3.6\n     */\n    public FieldRotation(final RotationOrder order, final RotationConvention convention,\n                         final T alpha1, final T alpha2, final T alpha3) {\n        final T one = alpha1.getField().getOne();\n        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1, convention);\n        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2, convention);\n        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3, convention);\n        final FieldRotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\n        q0 = composed.q0;\n        q1 = composed.q1;\n        q2 = composed.q2;\n        q3 = composed.q3;\n    }\n\n    /** Convert an orthogonal rotation matrix to a quaternion.\n     * @param ort orthogonal rotation matrix\n     * @return quaternion corresponding to the matrix\n     */\n    private T[] mat2quat(final T[][] ort) {\n\n        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n\n        // There are different ways to compute the quaternions elements\n        // from the matrix. They all involve computing one element from\n        // the diagonal of the matrix, and computing the three other ones\n        // using a formula involving a division by the first element,\n        // which unfortunately can be zero. Since the norm of the\n        // quaternion is 1, we know at least one element has an absolute\n        // value greater or equal to 0.5, so it is always possible to\n        // select the right formula and avoid division by zero and even\n        // numerical inaccuracy. Checking the elements in turn and using\n        // the first one greater than 0.45 is safe (this leads to a simple\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n        if (s.getReal() > -0.19) {\n            // compute q0 and deduce q1, q2 and q3\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n            T inv = quat[0].reciprocal().multiply(0.25);\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n        } else {\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n            if (s.getReal() > -0.19) {\n                // compute q1 and deduce q0, q2 and q3\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n                T inv = quat[1].reciprocal().multiply(0.25);\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n            } else {\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n                if (s.getReal() > -0.19) {\n                    // compute q2 and deduce q0, q1 and q3\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[2].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n                } else {\n                    // compute q3 and deduce q0, q1 and q2\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[3].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n                }\n            }\n        }\n\n        return quat;\n\n    }\n\n    /** Revert a rotation.\n     * Build a rotation which reverse the effect of another\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n     * instance is not changed.\n     * @return a new rotation whose effect is the reverse of the effect\n     * of the instance\n     */\n    public FieldRotation<T> revert() {\n        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n    }\n\n    /** Get the scalar coordinate of the quaternion.\n     * @return scalar coordinate of the quaternion\n     */\n    public T getQ0() {\n        return q0;\n    }\n\n    /** Get the first coordinate of the vectorial part of the quaternion.\n     * @return first coordinate of the vectorial part of the quaternion\n     */\n    public T getQ1() {\n        return q1;\n    }\n\n    /** Get the second coordinate of the vectorial part of the quaternion.\n     * @return second coordinate of the vectorial part of the quaternion\n     */\n    public T getQ2() {\n        return q2;\n    }\n\n    /** Get the third coordinate of the vectorial part of the quaternion.\n     * @return third coordinate of the vectorial part of the quaternion\n     */\n    public T getQ3() {\n        return q3;\n    }\n\n    /** Get the normalized axis of the rotation.\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}\n     */\n    @Deprecated\n    public FieldVector3D<T> getAxis() {\n        return getAxis(RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the normalized axis of the rotation.\n     * <p>\n     * Note that as {@link #getAngle()} always returns an angle\n     * between 0 and &pi;, changing the convention changes the\n     * direction of the axis, not the sign of the angle.\n     * </p>\n     * @param convention convention to use for the semantics of the angle\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @since 3.6\n     */\n    public FieldVector3D<T> getAxis(final RotationConvention convention) {\n        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n        if (squaredSine.getReal() == 0) {\n            final Field<T> field = squaredSine.getField();\n            return new FieldVector3D<T>(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),\n                                        field.getZero(),\n                                        field.getZero());\n        } else {\n            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n            if (q0.getReal() < 0) {\n                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);\n                return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n            }\n            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);\n            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n        }\n    }\n\n    /** Get the angle of the rotation.\n     * @return angle of the rotation (between 0 and &pi;)\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     */\n    public T getAngle() {\n        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n        } else if (q0.getReal() < 0) {\n            return q0.negate().acos().multiply(2);\n        }\n        return q0.acos().multiply(2);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}\n     */\n    @Deprecated\n    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n        return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @param convention convention to use for the semantics of the angle\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @since 3.6\n     */\n    public T[] getAngles(final RotationOrder order, RotationConvention convention)\n        throws CardanEulerSingularityException {\n\n        if (convention == RotationConvention.VECTOR_OPERATOR) {\n            if (order == RotationOrder.XYZ) {\n\n                // r (+K) coordinates are :\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (+I) coordinates are :\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                                  v2.getZ().asin(),\n                                  v2.getY().negate().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (+J) coordinates are :\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n                // (-r) (+I) coordinates are :\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getY().asin().negate(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (+K) coordinates are :\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getZ().asin().negate(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (+I) coordinates are :\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                                  v2.getX().asin(),\n                                  v2.getZ().negate().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (+J) coordinates are :\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().negate().atan2(v1.getY()),\n                                  v2.getY().asin(),\n                                  v2.getX().negate().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getX().asin().negate(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n                // (-r) (+I) coordinates are :\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (+I) coordinates are :\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n                // (-r) (+I) coordinates are :\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getX().acos(),\n                                  v2.getZ().atan2(v2.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (+J) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // (-r) (+J) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getY().acos(),\n                                  v2.getX().atan2(v2.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (+J) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                                  v2.getY().acos(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (+K) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // (-r) (+K) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (+K) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getZ().acos(),\n                                  v2.getY().atan2(v2.getX().negate()));\n\n            }\n        } else {\n            if (order == RotationOrder.XYZ) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().negate().atan2(v2.getZ()),\n                                  v2.getX().asin(),\n                                  v1.getY().negate().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().asin().negate(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().asin().negate(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().negate().atan2(v2.getX()),\n                                  v2.getY().asin(),\n                                  v1.getZ().negate().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().negate().atan2(v2.getY()),\n                                  v2.getZ().asin(),\n                                  v1.getX().negate().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().asin().negate(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().acos(),\n                                  v1.getZ().atan2(v1.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().acos(),\n                                  v1.getX().atan2(v1.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getX().negate()),\n                                  v2.getY().acos(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (Vector3D.plusK) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (Vector3D.plusK) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().acos(),\n                                  v1.getY().atan2(v1.getX().negate()));\n\n            }\n        }\n\n    }\n\n    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */\n    private T[] buildArray(final T a0, final T a1, final T a2) {\n        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n        array[0] = a0;\n        array[1] = a1;\n        array[2] = a2;\n        return array;\n    }\n\n    /** Create a constant vector.\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @return a constant vector\n     */\n    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n        final T zero = q0.getField().getZero();\n        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n    }\n\n    /** Get the 3X3 matrix corresponding to the instance\n     * @return the matrix corresponding to the instance\n     */\n    public T[][] getMatrix() {\n\n        // products\n        final T q0q0  = q0.multiply(q0);\n        final T q0q1  = q0.multiply(q1);\n        final T q0q2  = q0.multiply(q2);\n        final T q0q3  = q0.multiply(q3);\n        final T q1q1  = q1.multiply(q1);\n        final T q1q2  = q1.multiply(q2);\n        final T q1q3  = q1.multiply(q3);\n        final T q2q2  = q2.multiply(q2);\n        final T q2q3  = q2.multiply(q3);\n        final T q3q3  = q3.multiply(q3);\n\n        // create the matrix\n        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n\n        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n        m [2][0] = q1q3.add(q0q2).multiply(2);\n\n        m [0][1] = q1q2.add(q0q3).multiply(2);\n        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n\n        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n        m [1][2] = q2q3.add(q0q1).multiply(2);\n        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n\n        return m;\n\n    }\n\n    /** Convert to a constant vector without derivatives.\n     * @return a constant vector\n     */\n    public Rotation toRotation() {\n        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n\n        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyInverseTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyInverseTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the inverse of the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n        final double m0 = -r.getQ0();\n\n        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(FieldRotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : r.composeInternal(this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n                                    false);\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(Rotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final Rotation r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : applyTo(r, this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n                        q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n                        false);\n    }\n\n    /** Apply a rotation to another rotation.\n     * Applying a rotation to another rotation is computing the composition\n     * in an order compliant with the following rule : let u be any\n     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n     * where comp = applyTo(rOuter, rInner).\n     * @param r1 rotation to apply\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(FieldRotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : r.composeInternal(revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(Rotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final Rotation r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : applyTo(r, revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n                                    false);\n    }\n\n    /** Apply the inverse of a rotation to another rotation.\n     * Applying the inverse of a rotation to another rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n     * let w be the inverse image of v by rOuter\n     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n     * comp = applyInverseTo(rOuter, rInner).\n     * @param rOuter rotation to apply the rotation to\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n                                    false);\n    }\n\n    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @exception NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */\n    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        T x00 = m[0][0];\n        T x01 = m[0][1];\n        T x02 = m[0][2];\n        T x10 = m[1][0];\n        T x11 = m[1][1];\n        T x12 = m[1][2];\n        T x20 = m[2][0];\n        T x21 = m[2][1];\n        T x22 = m[2][2];\n        double fn = 0;\n        double fn1;\n\n        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n        int i = 0;\n        while (++i < 11) {\n\n            // Mt.Xn\n            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n\n            // Xn+1\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n\n            // correction on each elements\n            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n\n            // Frobenius norm of the correction\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n            // convergence test\n            if (FastMath.abs(fn1 - fn) <= threshold) {\n                return o;\n            }\n\n            // prepare next iteration\n            x00 = o[0][0];\n            x01 = o[0][1];\n            x02 = o[0][2];\n            x10 = o[1][0];\n            x11 = o[1][1];\n            x12 = o[1][2];\n            x20 = o[2][0];\n            x21 = o[2][1];\n            x22 = o[2][2];\n            fn  = fn1;\n\n        }\n\n        // the algorithm did not converge after 10 iterations\n        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n                                              i - 1);\n\n    }\n\n    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */\n    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n        return r1.composeInverseInternal(r2).getAngle();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static boolean isPrime(int n)"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static int nextPrime(int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int smallTrialDivision(int n, final List<Integer> factors)"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors)"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static List<Integer> trialDivision(int n)"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static boolean millerRabinPrimeTest(final int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int rhoBrent(final int n)"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int gcdPositive(int a, int b)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "public static GaussianCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "public static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights)"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights)"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter)"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker)"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "public static HarmonicCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "public static PolynomialCurveFitter create(int degree)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction compose(final UnivariateFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction add(final UnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction multiply(final UnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue)"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f)"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f)"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f)"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f)"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double midpoint(double a, double b)"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isSequence(final double start, final double mid, final double end)"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "public static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createConstant(final double value)"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createVariable(final int idx, final double value)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient hypot(final SparseGradient x, final SparseGradient y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient pow(final double a, final SparseGradient x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient atan2(final SparseGradient y, final SparseGradient x)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure pow(final double a, final DerivativeStructure x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "public static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createChebyshevPolynomial(final int degree)"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createHermitePolynomial(final int degree)"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLaguerrePolynomial(final int degree)"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLegendrePolynomial(final int degree)"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w)"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static double[] shift(final double[] coefficients, final double shift)"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "protected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(double x, double y, double eps)"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(final double x, final double y, final int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y, float eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, float eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final float x, final float y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsWithRelativeTolerance(double x, double y, double eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, double eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final double x, final double y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, int maxUlps)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale, int roundingMethod)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double representableDelta(double x, double originalDelta)"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor wrap(final IntegerSequence.Incrementor incrementor)"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] scale(double val, final double[] arr)"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double cosAngle(double[] v1, double[] v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(double[] a, double[] b, boolean abort)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(int[] a, int[] b, boolean abort)"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double safeNorm(double[] v)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source, int len)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source, int len)"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOfRange(double[] source, int from, int to)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(float[] x, float[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(float[] x, float[] y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(double[] x, double[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(double[] x, double[] y)"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] natural(int n)"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] sequence(int size, int start, int stride)"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] concatenate(double[]... x)"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] unique(double[] data)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "public static <K, V> Pair<K, V> create(K k, V v)"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowCos(final double x, final double[] result)"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowSin(final double x, final double[] result)"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowexp(final double x, final double[] result)"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double expint(int p, final double[] result)"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double[] slowLog(double xi)"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static String format(double d)"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sqrt(final double a)"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cosh(double x)"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sinh(double x)"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tanh(double x)"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acosh(final double a)"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asinh(double a)"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atanh(double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double signum(final double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float signum(final float a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextUp(final double a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextUp(final float a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextDown(final double a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextDown(final float a)"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double random()"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double exp(double x)"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double expm1(double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(final double x)"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log1p(final double x)"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log10(final double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(double base, double x)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(final double x, final double y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, int e)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, long e)"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sin(double x)"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cos(double x)"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tan(double x)"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan(double x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan2(double y, double x)"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asin(double x)"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acos(double x)"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cbrt(double x)"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toRadians(double x)"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toDegrees(double x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int abs(final int x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long abs(final long x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float abs(final float x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double abs(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ulp(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float ulp(float x)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double scalb(final double d, final int n)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float scalb(final float f, final int n)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextAfter(double d, double direction)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextAfter(final float f, final double direction)"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double floor(double x)"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ceil(double x)"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double rint(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long round(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int round(final float x)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int min(final int a, final int b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long min(final long a, final long b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float min(final float a, final float b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double min(final double a, final double b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int max(final int a, final int b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long max(final long a, final long b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float max(final float a, final float b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double max(final double a, final double b)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double hypot(final double x, final double y)"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double IEEEremainder(double dividend, double divisor)"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int toIntExact(final long n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int incrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long incrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int decrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long decrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int addExact(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long addExact(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int subtractExact(final int a, final int b)"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long subtractExact(final long a, final long b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int multiplyExact(final int a, final int b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long multiplyExact(final long a, final long b)"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorDiv(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorDiv(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorMod(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorMod(final long a, final long b)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double copySign(double magnitude, double sign)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float copySign(float magnitude, float sign)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final double d)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final float f)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "public static BigRealField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "public static final Decimal64Field getInstance()"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double value)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static boolean equals(double x, double y)"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double[] value)"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double normalizeAngle(double a, double center)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T max(final T e1, final T e2)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T min(final T e1, final T e2)"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double reduce(double a, double period, double offset)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static byte copySign(byte magnitude, byte sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static short copySign(short magnitude, short sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int copySign(int magnitude, int sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static long copySign(long magnitude, long sign) throws MathArithmeticException"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos)"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos)"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(int start, int end)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(final int start, final int max, final int step)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Incrementor create()"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor create()"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntA()"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntB()"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracA()"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracB()"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[][] loadLnMant()"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static Iterator<int[]> combinationsIterator(int n, int k)"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int addAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long addAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int gcd(int p, int q) throws MathArithmeticException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long gcd(final long p, final long q) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int lcm(int a, int b) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long lcm(long a, long b) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int mulAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long mulAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int subAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long subAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static boolean isPowerOfTwo(long n)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(Locale locale)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "public static ComplexField getInstance()"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion multiply(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion add(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion subtract(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static double dotProduct(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart, double imaginaryPart)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart)"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex[] convertToComplex(double[] real)"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance(final Locale locale)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(final int rows, final int columns)"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealIdentityMatrix(int dimension)"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension)"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal)"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal)"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static boolean isSymmetric(RealMatrix matrix, double eps)"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m)"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m)"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix blockInverse(RealMatrix m, int splitIndex)"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] createBlocksLayout(final int rows, final int columns)"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "public static RealVector unmodifiableRealVector(final RealVector v)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance(final Locale locale)"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "public static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getStirlingError(double z)"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getDeviancePart(double x, double mu)"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double logBinomialProbability(int x, int n, double p, double q)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper2(final double x)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper2(final double x)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "public static MaxIter unlimited()"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "public static SimpleBounds unbounded(int dim)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "public static MaxEval unlimited()"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x)"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfc(double x)"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x1, double x2)"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfInv(final double x)"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfcInv(final double x)"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static BesselJResult rjBesl(double x, double alpha, int nb)"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma(double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(double a, double x)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double digamma(double x)"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double trigamma(double x)"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double lanczos(final double x)"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double invGamma1pm1(final double x)"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double gamma(final double x)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, double epsilon)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, int maxIterations)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(double a, double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(final double p, final double q)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "public static DummyStepHandler getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "public static AdamsNordsieckTransformer getInstance(final int nSteps)"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "public static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps)"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] normalize(final double[] sample)"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample) throws MathIllegalArgumentException"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample, final int begin, final int length)"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double exactP(double d, int m, int n, boolean strict)"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double approximateP(double d, int n, int m)"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double monteCarloP(double d, int n, int m, boolean strict, int iterations)"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "public static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics)"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final double min, final double max)"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc)"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final DfpField field, final String a)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final Dfp a)"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp splitPow(final Dfp[] base, int a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp base, int a)"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp exp(final Dfp a)"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp expInternal(final Dfp a)"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp log(Dfp a)"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] logInternal(final Dfp[] a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp x, final Dfp y)"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp sinInternal(Dfp[] a)"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp cosInternal(Dfp[] a)"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp sin(final Dfp a)"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp cos(Dfp a)"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp tan(final Dfp a)"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp atanInternal(final Dfp a)"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp atan(final Dfp a)"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp asin(final Dfp a)"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp acos(Dfp a)"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static Dfp copysign(final Dfp x, final Dfp y)"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeExp(final Dfp a, final Dfp one)"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two)"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "public static synchronized RandomGenerator getRandomGenerator()"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> randomPermutation(final int l)"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> identityPermutation(final int l)"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator)"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "public static List<Integer> randomBinaryRepresentation(int length)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static double distance(Rotation r1, Rotation r2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "public static Euclidean3D getInstance()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double dotProduct(Vector3D v1, Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance1(Vector3D v1, Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceInf(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceSq(Vector3D v1, Vector3D v2)"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "public static Euclidean1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance(final Locale locale)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distance(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceInf(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceSq(Vector1D p1, Vector1D p2)"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distance(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceInf(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceSq(Vector2D p1, Vector2D p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "public static Euclidean2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static double distance(S1Point p1, S1Point p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "public static Sphere1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "public static Sphere2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "public static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static double distance(S2Point p1, S2Point p2)"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "public static Random createAdaptor(RandomGenerator randomGenerator)"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static RandomGenerator createRandomGenerator(final Random rng)"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static long convertToLong(int[] seed)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static String formatBigFraction(final BigFraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static Fraction getReducedFraction(int numerator, int denominator)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static BigFraction getReducedFraction(final int numerator, final int denominator)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static String formatFraction(Fraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "public static FractionField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "public static BigFractionField getInstance()"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "public static Object[] flatten(Object[] array)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[] scaleArray(double[] f, double d)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] scaleArray(Complex[] f, double d)"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[][] createRealImaginaryArray(final Complex[] dataC)"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static int exactLog2(final int n) throws MathIllegalArgumentException"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "static final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "public static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "public static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "public static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "public static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "protected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "static final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "static final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "static final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "static final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "r",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation"
            ],
            [
                "u",
                "org.apache.commons.math3.geometry.euclidean.threed.FieldVector3D",
                "FieldVector3D<T>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order) throws CardanEulerSingularityException"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final Vector3D u)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis(final RotationConvention convention)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final Vector3D u)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis()"
            ],
            [
                "toRotation",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public Rotation toRotation()"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ1()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order, RotationConvention convention) throws CardanEulerSingularityException"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final Rotation r)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[][] getMatrix()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> revert()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final Rotation r)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ3()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention)"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ2()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final FieldVector3D<T> u)"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ0()"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final FieldRotation<T> r)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getAngle()"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final FieldRotation<T> r)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D applyInverseTo(Vector3D arg0)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation composeInverse(Rotation arg0, RotationConvention arg1)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation applyTo(Rotation arg0)"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ0()"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ3()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double[] getAngles(RotationOrder arg0) throws CardanEulerSingularityException"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D applyTo(Vector3D arg0)"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getAngle()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double[] getAngles(RotationOrder arg0, RotationConvention arg1) throws CardanEulerSingularityException"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double[][] getMatrix()"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ1()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D getAxis()"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation compose(Rotation arg0, RotationConvention arg1)"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ2()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D getAxis(RotationConvention arg0)"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation revert()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation applyInverseTo(Rotation arg0)"
            ],
            [
                "getZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getZ()"
            ],
            [
                "add",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> add(FieldVector3D<T> arg0)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T dotProduct(FieldVector3D<T> arg0)"
            ],
            [
                "add",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> add(double arg0, FieldVector3D<T> arg1)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distanceInf(Vector3D arg0)"
            ],
            [
                "getDelta",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getDelta()"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> crossProduct(FieldVector3D<T> arg0)"
            ],
            [
                "add",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> add(double arg0, Vector3D arg1)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distance1(FieldVector3D<T> arg0)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T dotProduct(Vector3D arg0)"
            ],
            [
                "scalarMultiply",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> scalarMultiply(double arg0)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distance(Vector3D arg0)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distanceSq(FieldVector3D<T> arg0)"
            ],
            [
                "getNormSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getNormSq()"
            ],
            [
                "subtract",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> subtract(double arg0, Vector3D arg1)"
            ],
            [
                "toArray",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T[] toArray()"
            ],
            [
                "hashCode",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public int hashCode()"
            ],
            [
                "subtract",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> subtract(FieldVector3D<T> arg0)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> subtract(Vector3D arg0)"
            ],
            [
                "isInfinite",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public boolean isInfinite()"
            ],
            [
                "getNorm1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getNorm1()"
            ],
            [
                "add",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> add(T arg0, Vector3D arg1)"
            ],
            [
                "orthogonal",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> orthogonal() throws MathArithmeticException"
            ],
            [
                "toString",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public String toString()"
            ],
            [
                "normalize",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> normalize() throws MathArithmeticException"
            ],
            [
                "subtract",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> subtract(T arg0, Vector3D arg1)"
            ],
            [
                "toVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public Vector3D toVector3D()"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distance(FieldVector3D<T> arg0)"
            ],
            [
                "equals",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public boolean equals(Object arg0)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distanceInf(FieldVector3D<T> arg0)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distance1(Vector3D arg0)"
            ],
            [
                "add",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> add(Vector3D arg0)"
            ],
            [
                "getY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getY()"
            ],
            [
                "isNaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public boolean isNaN()"
            ],
            [
                "getNorm",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getNorm()"
            ],
            [
                "getNormInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getNormInf()"
            ],
            [
                "scalarMultiply",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> scalarMultiply(T arg0)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T distanceSq(Vector3D arg0)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> subtract(double arg0, FieldVector3D<T> arg1)"
            ],
            [
                "negate",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> negate()"
            ],
            [
                "getAlpha",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getAlpha()"
            ],
            [
                "getX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public T getX()"
            ],
            [
                "add",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> add(T arg0, FieldVector3D<T> arg1)"
            ],
            [
                "toString",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public String toString(NumberFormat arg0)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> crossProduct(Vector3D arg0)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public FieldVector3D<T> subtract(T arg0, FieldVector3D<T> arg1)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 23663,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.geometry.euclidean.threed",
        "className": "FieldRotation",
        "javadocTag": "@param in an array with three items which stores vector to rotate",
        "methodJavadoc": "    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */",
        "methodSourceCode": "public void applyInverseTo(final double[] in, final T[] out){\n    final double x = in[0];\n    final double y = in[1];\n    final double z = in[2];\n    final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n    final T m0 = q0.negate();\n    out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n    out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n    out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n}",
        "classJavadoc": "/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.RealFieldElement;\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */\n\npublic class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 20130224l;\n\n    /** Scalar coordinate of the quaternion. */\n    private final T q0;\n\n    /** First coordinate of the vectorial part of the quaternion. */\n    private final T q1;\n\n    /** Second coordinate of the vectorial part of the quaternion. */\n    private final T q2;\n\n    /** Third coordinate of the vectorial part of the quaternion. */\n    private final T q3;\n\n    /** Build a rotation from the quaternion coordinates.\n     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n     * the constructor can normalize it in a preprocessing step.</p>\n     * <p>Note that some conventions put the scalar part of the quaternion\n     * as the 4<sup>th</sup> component and the vector part as the first three\n     * components. This is <em>not</em> our convention. We put the scalar part\n     * as the first component.</p>\n     * @param q0 scalar part of the quaternion\n     * @param q1 first coordinate of the vectorial part of the quaternion\n     * @param q2 second coordinate of the vectorial part of the quaternion\n     * @param q3 third coordinate of the vectorial part of the quaternion\n     * @param needsNormalization if true, the coordinates are considered\n     * not to be normalized, a normalization preprocessing step is performed\n     * before using them\n     */\n    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n\n        if (needsNormalization) {\n            // normalization preprocessing\n            final T inv =\n                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n            this.q0 = inv.multiply(q0);\n            this.q1 = inv.multiply(q1);\n            this.q2 = inv.multiply(q2);\n            this.q3 = inv.multiply(q3);\n        } else {\n            this.q0 = q0;\n            this.q1 = q1;\n            this.q2 = q2;\n            this.q3 = q3;\n        }\n\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}\n     */\n    @Deprecated\n    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n        throws MathIllegalArgumentException {\n        this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @param convention convention to use for the semantics of the angle\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @since 3.6\n     */\n    public FieldRotation(final FieldVector3D<T> axis, final T angle, final RotationConvention convention)\n        throws MathIllegalArgumentException {\n\n        final T norm = axis.getNorm();\n        if (norm.getReal() == 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n        }\n\n        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);\n        final T coeff = halfAngle.sin().divide(norm);\n\n        q0 = halfAngle.cos();\n        q1 = coeff.multiply(axis.getX());\n        q2 = coeff.multiply(axis.getY());\n        q3 = coeff.multiply(axis.getZ());\n\n    }\n\n    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @exception NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */\n    public FieldRotation(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        // dimension check\n        if ((m.length != 3) || (m[0].length != 3) ||\n                (m[1].length != 3) || (m[2].length != 3)) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                  m.length, m[0].length);\n        }\n\n        // compute a \"close\" orthogonal matrix\n        final T[][] ort = orthogonalizeMatrix(m, threshold);\n\n        // check the sign of the determinant\n        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n        final T det =\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n        if (det.getReal() < 0.0) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n                                                  det);\n        }\n\n        final T[] quat = mat2quat(ort);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build the rotation that transforms a pair of vectors into another pair.\n\n     * <p>Except for possible scale factors, if the instance were applied to\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n     * not the same as the angular separation between v<sub>1</sub> and\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>,\n     * +v<sub>2</sub>) half-plane.</p>\n\n     * @param u1 first vector of the origin pair\n     * @param u2 second vector of the origin pair\n     * @param v1 desired image of u1 by the rotation\n     * @param v2 desired image of u2 by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\n     */\n    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n        throws MathArithmeticException {\n\n        // build orthonormalized base from u1, u2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n        u1 = u1.normalize();\n\n        // build an orthonormalized base from v1, v2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n        v1 = v1.normalize();\n\n        // buid a matrix transforming the first base into the second one\n        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n\n        T[] quat = mat2quat(array);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build one of the rotations that transform one vector into another one.\n\n     * <p>Except for a possible scale factor, if the instance were\n     * applied to the vector u it will produce the vector v. There is an\n     * infinite number of such rotations, this constructor choose the\n     * one with the smallest associated angle (i.e. the one whose axis\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\n     * arbitrary rotation axis is chosen.</p>\n\n     * @param u origin vector\n     * @param v desired image of u by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero\n     */\n    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n\n        final T normProduct = u.getNorm().multiply(v.getNorm());\n        if (normProduct.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n        }\n\n        final T dot = FieldVector3D.dotProduct(u, v);\n\n        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n            // special case u = -v: we select a PI angle rotation around\n            // an arbitrary vector orthogonal to u\n            final FieldVector3D<T> w = u.orthogonal();\n            q0 = normProduct.getField().getZero();\n            q1 = w.getX().negate();\n            q2 = w.getY().negate();\n            q3 = w.getZ().negate();\n        } else {\n            // general case: (u, v) defines a plane, we select\n            // the shortest possible rotation: axis orthogonal to this plane\n            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n            q1 = coeff.multiply(q.getX());\n            q2 = coeff.multiply(q.getY());\n            q3 = coeff.multiply(q.getZ());\n        }\n\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to use\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(RotationOrder, RotationConvention,\n     * RealFieldElement, RealFieldElement, RealFieldElement)}\n     */\n    @Deprecated\n    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to compose, from left to right\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\n     * @param convention convention to use for the semantics of the angle\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @since 3.6\n     */\n    public FieldRotation(final RotationOrder order, final RotationConvention convention,\n                         final T alpha1, final T alpha2, final T alpha3) {\n        final T one = alpha1.getField().getOne();\n        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1, convention);\n        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2, convention);\n        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3, convention);\n        final FieldRotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\n        q0 = composed.q0;\n        q1 = composed.q1;\n        q2 = composed.q2;\n        q3 = composed.q3;\n    }\n\n    /** Convert an orthogonal rotation matrix to a quaternion.\n     * @param ort orthogonal rotation matrix\n     * @return quaternion corresponding to the matrix\n     */\n    private T[] mat2quat(final T[][] ort) {\n\n        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n\n        // There are different ways to compute the quaternions elements\n        // from the matrix. They all involve computing one element from\n        // the diagonal of the matrix, and computing the three other ones\n        // using a formula involving a division by the first element,\n        // which unfortunately can be zero. Since the norm of the\n        // quaternion is 1, we know at least one element has an absolute\n        // value greater or equal to 0.5, so it is always possible to\n        // select the right formula and avoid division by zero and even\n        // numerical inaccuracy. Checking the elements in turn and using\n        // the first one greater than 0.45 is safe (this leads to a simple\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n        if (s.getReal() > -0.19) {\n            // compute q0 and deduce q1, q2 and q3\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n            T inv = quat[0].reciprocal().multiply(0.25);\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n        } else {\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n            if (s.getReal() > -0.19) {\n                // compute q1 and deduce q0, q2 and q3\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n                T inv = quat[1].reciprocal().multiply(0.25);\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n            } else {\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n                if (s.getReal() > -0.19) {\n                    // compute q2 and deduce q0, q1 and q3\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[2].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n                } else {\n                    // compute q3 and deduce q0, q1 and q2\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[3].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n                }\n            }\n        }\n\n        return quat;\n\n    }\n\n    /** Revert a rotation.\n     * Build a rotation which reverse the effect of another\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n     * instance is not changed.\n     * @return a new rotation whose effect is the reverse of the effect\n     * of the instance\n     */\n    public FieldRotation<T> revert() {\n        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n    }\n\n    /** Get the scalar coordinate of the quaternion.\n     * @return scalar coordinate of the quaternion\n     */\n    public T getQ0() {\n        return q0;\n    }\n\n    /** Get the first coordinate of the vectorial part of the quaternion.\n     * @return first coordinate of the vectorial part of the quaternion\n     */\n    public T getQ1() {\n        return q1;\n    }\n\n    /** Get the second coordinate of the vectorial part of the quaternion.\n     * @return second coordinate of the vectorial part of the quaternion\n     */\n    public T getQ2() {\n        return q2;\n    }\n\n    /** Get the third coordinate of the vectorial part of the quaternion.\n     * @return third coordinate of the vectorial part of the quaternion\n     */\n    public T getQ3() {\n        return q3;\n    }\n\n    /** Get the normalized axis of the rotation.\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}\n     */\n    @Deprecated\n    public FieldVector3D<T> getAxis() {\n        return getAxis(RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the normalized axis of the rotation.\n     * <p>\n     * Note that as {@link #getAngle()} always returns an angle\n     * between 0 and &pi;, changing the convention changes the\n     * direction of the axis, not the sign of the angle.\n     * </p>\n     * @param convention convention to use for the semantics of the angle\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @since 3.6\n     */\n    public FieldVector3D<T> getAxis(final RotationConvention convention) {\n        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n        if (squaredSine.getReal() == 0) {\n            final Field<T> field = squaredSine.getField();\n            return new FieldVector3D<T>(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),\n                                        field.getZero(),\n                                        field.getZero());\n        } else {\n            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n            if (q0.getReal() < 0) {\n                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);\n                return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n            }\n            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);\n            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n        }\n    }\n\n    /** Get the angle of the rotation.\n     * @return angle of the rotation (between 0 and &pi;)\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     */\n    public T getAngle() {\n        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n        } else if (q0.getReal() < 0) {\n            return q0.negate().acos().multiply(2);\n        }\n        return q0.acos().multiply(2);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}\n     */\n    @Deprecated\n    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n        return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @param convention convention to use for the semantics of the angle\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @since 3.6\n     */\n    public T[] getAngles(final RotationOrder order, RotationConvention convention)\n        throws CardanEulerSingularityException {\n\n        if (convention == RotationConvention.VECTOR_OPERATOR) {\n            if (order == RotationOrder.XYZ) {\n\n                // r (+K) coordinates are :\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (+I) coordinates are :\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                                  v2.getZ().asin(),\n                                  v2.getY().negate().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (+J) coordinates are :\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n                // (-r) (+I) coordinates are :\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getY().asin().negate(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (+K) coordinates are :\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getZ().asin().negate(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (+I) coordinates are :\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                                  v2.getX().asin(),\n                                  v2.getZ().negate().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (+J) coordinates are :\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().negate().atan2(v1.getY()),\n                                  v2.getY().asin(),\n                                  v2.getX().negate().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getX().asin().negate(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n                // (-r) (+I) coordinates are :\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (+I) coordinates are :\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n                // (-r) (+I) coordinates are :\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getX().acos(),\n                                  v2.getZ().atan2(v2.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (+J) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // (-r) (+J) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getY().acos(),\n                                  v2.getX().atan2(v2.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (+J) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                                  v2.getY().acos(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (+K) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // (-r) (+K) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (+K) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getZ().acos(),\n                                  v2.getY().atan2(v2.getX().negate()));\n\n            }\n        } else {\n            if (order == RotationOrder.XYZ) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().negate().atan2(v2.getZ()),\n                                  v2.getX().asin(),\n                                  v1.getY().negate().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().asin().negate(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().asin().negate(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().negate().atan2(v2.getX()),\n                                  v2.getY().asin(),\n                                  v1.getZ().negate().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().negate().atan2(v2.getY()),\n                                  v2.getZ().asin(),\n                                  v1.getX().negate().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().asin().negate(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().acos(),\n                                  v1.getZ().atan2(v1.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().acos(),\n                                  v1.getX().atan2(v1.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getX().negate()),\n                                  v2.getY().acos(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (Vector3D.plusK) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (Vector3D.plusK) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().acos(),\n                                  v1.getY().atan2(v1.getX().negate()));\n\n            }\n        }\n\n    }\n\n    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */\n    private T[] buildArray(final T a0, final T a1, final T a2) {\n        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n        array[0] = a0;\n        array[1] = a1;\n        array[2] = a2;\n        return array;\n    }\n\n    /** Create a constant vector.\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @return a constant vector\n     */\n    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n        final T zero = q0.getField().getZero();\n        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n    }\n\n    /** Get the 3X3 matrix corresponding to the instance\n     * @return the matrix corresponding to the instance\n     */\n    public T[][] getMatrix() {\n\n        // products\n        final T q0q0  = q0.multiply(q0);\n        final T q0q1  = q0.multiply(q1);\n        final T q0q2  = q0.multiply(q2);\n        final T q0q3  = q0.multiply(q3);\n        final T q1q1  = q1.multiply(q1);\n        final T q1q2  = q1.multiply(q2);\n        final T q1q3  = q1.multiply(q3);\n        final T q2q2  = q2.multiply(q2);\n        final T q2q3  = q2.multiply(q3);\n        final T q3q3  = q3.multiply(q3);\n\n        // create the matrix\n        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n\n        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n        m [2][0] = q1q3.add(q0q2).multiply(2);\n\n        m [0][1] = q1q2.add(q0q3).multiply(2);\n        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n\n        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n        m [1][2] = q2q3.add(q0q1).multiply(2);\n        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n\n        return m;\n\n    }\n\n    /** Convert to a constant vector without derivatives.\n     * @return a constant vector\n     */\n    public Rotation toRotation() {\n        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n\n        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyInverseTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyInverseTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the inverse of the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n        final double m0 = -r.getQ0();\n\n        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(FieldRotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : r.composeInternal(this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n                                    false);\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(Rotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final Rotation r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : applyTo(r, this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n                        q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n                        false);\n    }\n\n    /** Apply a rotation to another rotation.\n     * Applying a rotation to another rotation is computing the composition\n     * in an order compliant with the following rule : let u be any\n     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n     * where comp = applyTo(rOuter, rInner).\n     * @param r1 rotation to apply\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(FieldRotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : r.composeInternal(revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(Rotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final Rotation r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : applyTo(r, revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n                                    false);\n    }\n\n    /** Apply the inverse of a rotation to another rotation.\n     * Applying the inverse of a rotation to another rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n     * let w be the inverse image of v by rOuter\n     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n     * comp = applyInverseTo(rOuter, rInner).\n     * @param rOuter rotation to apply the rotation to\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n                                    false);\n    }\n\n    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @exception NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */\n    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        T x00 = m[0][0];\n        T x01 = m[0][1];\n        T x02 = m[0][2];\n        T x10 = m[1][0];\n        T x11 = m[1][1];\n        T x12 = m[1][2];\n        T x20 = m[2][0];\n        T x21 = m[2][1];\n        T x22 = m[2][2];\n        double fn = 0;\n        double fn1;\n\n        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n        int i = 0;\n        while (++i < 11) {\n\n            // Mt.Xn\n            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n\n            // Xn+1\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n\n            // correction on each elements\n            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n\n            // Frobenius norm of the correction\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n            // convergence test\n            if (FastMath.abs(fn1 - fn) <= threshold) {\n                return o;\n            }\n\n            // prepare next iteration\n            x00 = o[0][0];\n            x01 = o[0][1];\n            x02 = o[0][2];\n            x10 = o[1][0];\n            x11 = o[1][1];\n            x12 = o[1][2];\n            x20 = o[2][0];\n            x21 = o[2][1];\n            x22 = o[2][2];\n            fn  = fn1;\n\n        }\n\n        // the algorithm did not converge after 10 iterations\n        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n                                              i - 1);\n\n    }\n\n    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */\n    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n        return r1.composeInverseInternal(r2).getAngle();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static boolean isPrime(int n)"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static int nextPrime(int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int smallTrialDivision(int n, final List<Integer> factors)"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors)"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static List<Integer> trialDivision(int n)"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static boolean millerRabinPrimeTest(final int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int rhoBrent(final int n)"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int gcdPositive(int a, int b)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "public static GaussianCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "public static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights)"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights)"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter)"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker)"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "public static HarmonicCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "public static PolynomialCurveFitter create(int degree)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction compose(final UnivariateFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction add(final UnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction multiply(final UnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue)"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f)"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f)"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f)"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f)"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double midpoint(double a, double b)"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isSequence(final double start, final double mid, final double end)"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "public static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createConstant(final double value)"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createVariable(final int idx, final double value)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient hypot(final SparseGradient x, final SparseGradient y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient pow(final double a, final SparseGradient x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient atan2(final SparseGradient y, final SparseGradient x)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure pow(final double a, final DerivativeStructure x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "public static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createChebyshevPolynomial(final int degree)"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createHermitePolynomial(final int degree)"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLaguerrePolynomial(final int degree)"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLegendrePolynomial(final int degree)"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w)"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static double[] shift(final double[] coefficients, final double shift)"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "protected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(double x, double y, double eps)"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(final double x, final double y, final int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y, float eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, float eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final float x, final float y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsWithRelativeTolerance(double x, double y, double eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, double eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final double x, final double y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, int maxUlps)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale, int roundingMethod)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double representableDelta(double x, double originalDelta)"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor wrap(final IntegerSequence.Incrementor incrementor)"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] scale(double val, final double[] arr)"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double cosAngle(double[] v1, double[] v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(double[] a, double[] b, boolean abort)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(int[] a, int[] b, boolean abort)"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double safeNorm(double[] v)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source, int len)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source, int len)"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOfRange(double[] source, int from, int to)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(float[] x, float[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(float[] x, float[] y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(double[] x, double[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(double[] x, double[] y)"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] natural(int n)"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] sequence(int size, int start, int stride)"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] concatenate(double[]... x)"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] unique(double[] data)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "public static <K, V> Pair<K, V> create(K k, V v)"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowCos(final double x, final double[] result)"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowSin(final double x, final double[] result)"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowexp(final double x, final double[] result)"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double expint(int p, final double[] result)"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double[] slowLog(double xi)"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static String format(double d)"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sqrt(final double a)"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cosh(double x)"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sinh(double x)"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tanh(double x)"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acosh(final double a)"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asinh(double a)"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atanh(double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double signum(final double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float signum(final float a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextUp(final double a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextUp(final float a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextDown(final double a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextDown(final float a)"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double random()"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double exp(double x)"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double expm1(double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(final double x)"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log1p(final double x)"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log10(final double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(double base, double x)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(final double x, final double y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, int e)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, long e)"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sin(double x)"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cos(double x)"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tan(double x)"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan(double x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan2(double y, double x)"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asin(double x)"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acos(double x)"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cbrt(double x)"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toRadians(double x)"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toDegrees(double x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int abs(final int x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long abs(final long x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float abs(final float x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double abs(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ulp(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float ulp(float x)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double scalb(final double d, final int n)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float scalb(final float f, final int n)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextAfter(double d, double direction)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextAfter(final float f, final double direction)"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double floor(double x)"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ceil(double x)"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double rint(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long round(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int round(final float x)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int min(final int a, final int b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long min(final long a, final long b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float min(final float a, final float b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double min(final double a, final double b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int max(final int a, final int b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long max(final long a, final long b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float max(final float a, final float b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double max(final double a, final double b)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double hypot(final double x, final double y)"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double IEEEremainder(double dividend, double divisor)"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int toIntExact(final long n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int incrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long incrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int decrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long decrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int addExact(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long addExact(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int subtractExact(final int a, final int b)"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long subtractExact(final long a, final long b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int multiplyExact(final int a, final int b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long multiplyExact(final long a, final long b)"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorDiv(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorDiv(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorMod(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorMod(final long a, final long b)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double copySign(double magnitude, double sign)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float copySign(float magnitude, float sign)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final double d)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final float f)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "public static BigRealField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "public static final Decimal64Field getInstance()"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double value)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static boolean equals(double x, double y)"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double[] value)"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double normalizeAngle(double a, double center)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T max(final T e1, final T e2)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T min(final T e1, final T e2)"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double reduce(double a, double period, double offset)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static byte copySign(byte magnitude, byte sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static short copySign(short magnitude, short sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int copySign(int magnitude, int sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static long copySign(long magnitude, long sign) throws MathArithmeticException"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos)"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos)"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(int start, int end)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(final int start, final int max, final int step)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Incrementor create()"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor create()"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntA()"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntB()"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracA()"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracB()"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[][] loadLnMant()"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static Iterator<int[]> combinationsIterator(int n, int k)"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int addAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long addAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int gcd(int p, int q) throws MathArithmeticException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long gcd(final long p, final long q) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int lcm(int a, int b) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long lcm(long a, long b) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int mulAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long mulAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int subAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long subAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static boolean isPowerOfTwo(long n)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(Locale locale)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "public static ComplexField getInstance()"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion multiply(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion add(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion subtract(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static double dotProduct(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart, double imaginaryPart)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart)"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex[] convertToComplex(double[] real)"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance(final Locale locale)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(final int rows, final int columns)"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealIdentityMatrix(int dimension)"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension)"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal)"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal)"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static boolean isSymmetric(RealMatrix matrix, double eps)"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m)"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m)"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix blockInverse(RealMatrix m, int splitIndex)"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] createBlocksLayout(final int rows, final int columns)"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "public static RealVector unmodifiableRealVector(final RealVector v)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance(final Locale locale)"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "public static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getStirlingError(double z)"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getDeviancePart(double x, double mu)"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double logBinomialProbability(int x, int n, double p, double q)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper2(final double x)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper2(final double x)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "public static MaxIter unlimited()"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "public static SimpleBounds unbounded(int dim)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "public static MaxEval unlimited()"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x)"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfc(double x)"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x1, double x2)"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfInv(final double x)"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfcInv(final double x)"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static BesselJResult rjBesl(double x, double alpha, int nb)"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma(double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(double a, double x)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double digamma(double x)"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double trigamma(double x)"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double lanczos(final double x)"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double invGamma1pm1(final double x)"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double gamma(final double x)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, double epsilon)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, int maxIterations)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(double a, double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(final double p, final double q)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "public static DummyStepHandler getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "public static AdamsNordsieckTransformer getInstance(final int nSteps)"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "public static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps)"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] normalize(final double[] sample)"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample) throws MathIllegalArgumentException"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample, final int begin, final int length)"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double exactP(double d, int m, int n, boolean strict)"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double approximateP(double d, int n, int m)"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double monteCarloP(double d, int n, int m, boolean strict, int iterations)"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "public static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics)"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final double min, final double max)"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc)"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final DfpField field, final String a)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final Dfp a)"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp splitPow(final Dfp[] base, int a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp base, int a)"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp exp(final Dfp a)"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp expInternal(final Dfp a)"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp log(Dfp a)"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] logInternal(final Dfp[] a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp x, final Dfp y)"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp sinInternal(Dfp[] a)"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp cosInternal(Dfp[] a)"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp sin(final Dfp a)"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp cos(Dfp a)"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp tan(final Dfp a)"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp atanInternal(final Dfp a)"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp atan(final Dfp a)"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp asin(final Dfp a)"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp acos(Dfp a)"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static Dfp copysign(final Dfp x, final Dfp y)"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeExp(final Dfp a, final Dfp one)"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two)"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "public static synchronized RandomGenerator getRandomGenerator()"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> randomPermutation(final int l)"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> identityPermutation(final int l)"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator)"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "public static List<Integer> randomBinaryRepresentation(int length)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static double distance(Rotation r1, Rotation r2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "public static Euclidean3D getInstance()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double dotProduct(Vector3D v1, Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance1(Vector3D v1, Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceInf(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceSq(Vector3D v1, Vector3D v2)"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "public static Euclidean1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance(final Locale locale)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distance(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceInf(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceSq(Vector1D p1, Vector1D p2)"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distance(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceInf(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceSq(Vector2D p1, Vector2D p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "public static Euclidean2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static double distance(S1Point p1, S1Point p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "public static Sphere1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "public static Sphere2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "public static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static double distance(S2Point p1, S2Point p2)"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "public static Random createAdaptor(RandomGenerator randomGenerator)"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static RandomGenerator createRandomGenerator(final Random rng)"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static long convertToLong(int[] seed)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static String formatBigFraction(final BigFraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static Fraction getReducedFraction(int numerator, int denominator)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static BigFraction getReducedFraction(final int numerator, final int denominator)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static String formatFraction(Fraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "public static FractionField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "public static BigFractionField getInstance()"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "public static Object[] flatten(Object[] array)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[] scaleArray(double[] f, double d)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] scaleArray(Complex[] f, double d)"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[][] createRealImaginaryArray(final Complex[] dataC)"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static int exactLog2(final int n) throws MathIllegalArgumentException"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "static final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "public static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "public static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "public static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "public static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "protected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "static final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "static final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "static final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "static final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "in",
                "",
                "double[]"
            ],
            [
                "out",
                "",
                "RealFieldElement[]"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final FieldRotation<T> r)"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[][] getMatrix()"
            ],
            [
                "toRotation",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public Rotation toRotation()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final Vector3D u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final Rotation r)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final Vector3D u)"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getAngle()"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order) throws CardanEulerSingularityException"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ3()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final FieldRotation<T> r)"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ2()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ0()"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ1()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> revert()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final FieldVector3D<T> u)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis(final RotationConvention convention)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final Rotation r)"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order, RotationConvention convention) throws CardanEulerSingularityException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "equals",
                "",
                "double[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "double[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "double[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "double[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "double[]",
                "public T[] clone();"
            ],
            [
                "equals",
                "",
                "T[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "T[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "T[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "T[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "T[]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "length",
                "",
                "double[]",
                "public final int length;"
            ],
            [
                "length",
                "",
                "T[]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 23679,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.geometry.euclidean.threed",
        "className": "FieldRotation",
        "javadocTag": "@param convention convention to use for the semantics of the angle",
        "methodJavadoc": "    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */",
        "methodSourceCode": "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention){\n    return convention == RotationConvention.VECTOR_OPERATOR ? composeInternal(r) : applyTo(r, this);\n}",
        "classJavadoc": "/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.RealFieldElement;\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */\n\npublic class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 20130224l;\n\n    /** Scalar coordinate of the quaternion. */\n    private final T q0;\n\n    /** First coordinate of the vectorial part of the quaternion. */\n    private final T q1;\n\n    /** Second coordinate of the vectorial part of the quaternion. */\n    private final T q2;\n\n    /** Third coordinate of the vectorial part of the quaternion. */\n    private final T q3;\n\n    /** Build a rotation from the quaternion coordinates.\n     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n     * the constructor can normalize it in a preprocessing step.</p>\n     * <p>Note that some conventions put the scalar part of the quaternion\n     * as the 4<sup>th</sup> component and the vector part as the first three\n     * components. This is <em>not</em> our convention. We put the scalar part\n     * as the first component.</p>\n     * @param q0 scalar part of the quaternion\n     * @param q1 first coordinate of the vectorial part of the quaternion\n     * @param q2 second coordinate of the vectorial part of the quaternion\n     * @param q3 third coordinate of the vectorial part of the quaternion\n     * @param needsNormalization if true, the coordinates are considered\n     * not to be normalized, a normalization preprocessing step is performed\n     * before using them\n     */\n    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n\n        if (needsNormalization) {\n            // normalization preprocessing\n            final T inv =\n                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n            this.q0 = inv.multiply(q0);\n            this.q1 = inv.multiply(q1);\n            this.q2 = inv.multiply(q2);\n            this.q3 = inv.multiply(q3);\n        } else {\n            this.q0 = q0;\n            this.q1 = q1;\n            this.q2 = q2;\n            this.q3 = q3;\n        }\n\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}\n     */\n    @Deprecated\n    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n        throws MathIllegalArgumentException {\n        this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @param convention convention to use for the semantics of the angle\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @since 3.6\n     */\n    public FieldRotation(final FieldVector3D<T> axis, final T angle, final RotationConvention convention)\n        throws MathIllegalArgumentException {\n\n        final T norm = axis.getNorm();\n        if (norm.getReal() == 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n        }\n\n        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);\n        final T coeff = halfAngle.sin().divide(norm);\n\n        q0 = halfAngle.cos();\n        q1 = coeff.multiply(axis.getX());\n        q2 = coeff.multiply(axis.getY());\n        q3 = coeff.multiply(axis.getZ());\n\n    }\n\n    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @exception NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */\n    public FieldRotation(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        // dimension check\n        if ((m.length != 3) || (m[0].length != 3) ||\n                (m[1].length != 3) || (m[2].length != 3)) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                  m.length, m[0].length);\n        }\n\n        // compute a \"close\" orthogonal matrix\n        final T[][] ort = orthogonalizeMatrix(m, threshold);\n\n        // check the sign of the determinant\n        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n        final T det =\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n        if (det.getReal() < 0.0) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n                                                  det);\n        }\n\n        final T[] quat = mat2quat(ort);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build the rotation that transforms a pair of vectors into another pair.\n\n     * <p>Except for possible scale factors, if the instance were applied to\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n     * not the same as the angular separation between v<sub>1</sub> and\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>,\n     * +v<sub>2</sub>) half-plane.</p>\n\n     * @param u1 first vector of the origin pair\n     * @param u2 second vector of the origin pair\n     * @param v1 desired image of u1 by the rotation\n     * @param v2 desired image of u2 by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\n     */\n    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n        throws MathArithmeticException {\n\n        // build orthonormalized base from u1, u2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n        u1 = u1.normalize();\n\n        // build an orthonormalized base from v1, v2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n        v1 = v1.normalize();\n\n        // buid a matrix transforming the first base into the second one\n        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n\n        T[] quat = mat2quat(array);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build one of the rotations that transform one vector into another one.\n\n     * <p>Except for a possible scale factor, if the instance were\n     * applied to the vector u it will produce the vector v. There is an\n     * infinite number of such rotations, this constructor choose the\n     * one with the smallest associated angle (i.e. the one whose axis\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\n     * arbitrary rotation axis is chosen.</p>\n\n     * @param u origin vector\n     * @param v desired image of u by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero\n     */\n    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n\n        final T normProduct = u.getNorm().multiply(v.getNorm());\n        if (normProduct.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n        }\n\n        final T dot = FieldVector3D.dotProduct(u, v);\n\n        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n            // special case u = -v: we select a PI angle rotation around\n            // an arbitrary vector orthogonal to u\n            final FieldVector3D<T> w = u.orthogonal();\n            q0 = normProduct.getField().getZero();\n            q1 = w.getX().negate();\n            q2 = w.getY().negate();\n            q3 = w.getZ().negate();\n        } else {\n            // general case: (u, v) defines a plane, we select\n            // the shortest possible rotation: axis orthogonal to this plane\n            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n            q1 = coeff.multiply(q.getX());\n            q2 = coeff.multiply(q.getY());\n            q3 = coeff.multiply(q.getZ());\n        }\n\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to use\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(RotationOrder, RotationConvention,\n     * RealFieldElement, RealFieldElement, RealFieldElement)}\n     */\n    @Deprecated\n    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to compose, from left to right\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\n     * @param convention convention to use for the semantics of the angle\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @since 3.6\n     */\n    public FieldRotation(final RotationOrder order, final RotationConvention convention,\n                         final T alpha1, final T alpha2, final T alpha3) {\n        final T one = alpha1.getField().getOne();\n        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1, convention);\n        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2, convention);\n        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3, convention);\n        final FieldRotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\n        q0 = composed.q0;\n        q1 = composed.q1;\n        q2 = composed.q2;\n        q3 = composed.q3;\n    }\n\n    /** Convert an orthogonal rotation matrix to a quaternion.\n     * @param ort orthogonal rotation matrix\n     * @return quaternion corresponding to the matrix\n     */\n    private T[] mat2quat(final T[][] ort) {\n\n        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n\n        // There are different ways to compute the quaternions elements\n        // from the matrix. They all involve computing one element from\n        // the diagonal of the matrix, and computing the three other ones\n        // using a formula involving a division by the first element,\n        // which unfortunately can be zero. Since the norm of the\n        // quaternion is 1, we know at least one element has an absolute\n        // value greater or equal to 0.5, so it is always possible to\n        // select the right formula and avoid division by zero and even\n        // numerical inaccuracy. Checking the elements in turn and using\n        // the first one greater than 0.45 is safe (this leads to a simple\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n        if (s.getReal() > -0.19) {\n            // compute q0 and deduce q1, q2 and q3\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n            T inv = quat[0].reciprocal().multiply(0.25);\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n        } else {\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n            if (s.getReal() > -0.19) {\n                // compute q1 and deduce q0, q2 and q3\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n                T inv = quat[1].reciprocal().multiply(0.25);\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n            } else {\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n                if (s.getReal() > -0.19) {\n                    // compute q2 and deduce q0, q1 and q3\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[2].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n                } else {\n                    // compute q3 and deduce q0, q1 and q2\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[3].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n                }\n            }\n        }\n\n        return quat;\n\n    }\n\n    /** Revert a rotation.\n     * Build a rotation which reverse the effect of another\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n     * instance is not changed.\n     * @return a new rotation whose effect is the reverse of the effect\n     * of the instance\n     */\n    public FieldRotation<T> revert() {\n        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n    }\n\n    /** Get the scalar coordinate of the quaternion.\n     * @return scalar coordinate of the quaternion\n     */\n    public T getQ0() {\n        return q0;\n    }\n\n    /** Get the first coordinate of the vectorial part of the quaternion.\n     * @return first coordinate of the vectorial part of the quaternion\n     */\n    public T getQ1() {\n        return q1;\n    }\n\n    /** Get the second coordinate of the vectorial part of the quaternion.\n     * @return second coordinate of the vectorial part of the quaternion\n     */\n    public T getQ2() {\n        return q2;\n    }\n\n    /** Get the third coordinate of the vectorial part of the quaternion.\n     * @return third coordinate of the vectorial part of the quaternion\n     */\n    public T getQ3() {\n        return q3;\n    }\n\n    /** Get the normalized axis of the rotation.\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}\n     */\n    @Deprecated\n    public FieldVector3D<T> getAxis() {\n        return getAxis(RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the normalized axis of the rotation.\n     * <p>\n     * Note that as {@link #getAngle()} always returns an angle\n     * between 0 and &pi;, changing the convention changes the\n     * direction of the axis, not the sign of the angle.\n     * </p>\n     * @param convention convention to use for the semantics of the angle\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @since 3.6\n     */\n    public FieldVector3D<T> getAxis(final RotationConvention convention) {\n        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n        if (squaredSine.getReal() == 0) {\n            final Field<T> field = squaredSine.getField();\n            return new FieldVector3D<T>(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),\n                                        field.getZero(),\n                                        field.getZero());\n        } else {\n            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n            if (q0.getReal() < 0) {\n                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);\n                return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n            }\n            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);\n            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n        }\n    }\n\n    /** Get the angle of the rotation.\n     * @return angle of the rotation (between 0 and &pi;)\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     */\n    public T getAngle() {\n        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n        } else if (q0.getReal() < 0) {\n            return q0.negate().acos().multiply(2);\n        }\n        return q0.acos().multiply(2);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}\n     */\n    @Deprecated\n    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n        return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @param convention convention to use for the semantics of the angle\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @since 3.6\n     */\n    public T[] getAngles(final RotationOrder order, RotationConvention convention)\n        throws CardanEulerSingularityException {\n\n        if (convention == RotationConvention.VECTOR_OPERATOR) {\n            if (order == RotationOrder.XYZ) {\n\n                // r (+K) coordinates are :\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (+I) coordinates are :\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                                  v2.getZ().asin(),\n                                  v2.getY().negate().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (+J) coordinates are :\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n                // (-r) (+I) coordinates are :\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getY().asin().negate(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (+K) coordinates are :\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getZ().asin().negate(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (+I) coordinates are :\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                                  v2.getX().asin(),\n                                  v2.getZ().negate().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (+J) coordinates are :\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().negate().atan2(v1.getY()),\n                                  v2.getY().asin(),\n                                  v2.getX().negate().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getX().asin().negate(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n                // (-r) (+I) coordinates are :\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (+I) coordinates are :\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n                // (-r) (+I) coordinates are :\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getX().acos(),\n                                  v2.getZ().atan2(v2.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (+J) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // (-r) (+J) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getY().acos(),\n                                  v2.getX().atan2(v2.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (+J) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                                  v2.getY().acos(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (+K) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // (-r) (+K) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (+K) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getZ().acos(),\n                                  v2.getY().atan2(v2.getX().negate()));\n\n            }\n        } else {\n            if (order == RotationOrder.XYZ) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().negate().atan2(v2.getZ()),\n                                  v2.getX().asin(),\n                                  v1.getY().negate().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().asin().negate(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().asin().negate(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().negate().atan2(v2.getX()),\n                                  v2.getY().asin(),\n                                  v1.getZ().negate().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().negate().atan2(v2.getY()),\n                                  v2.getZ().asin(),\n                                  v1.getX().negate().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().asin().negate(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().acos(),\n                                  v1.getZ().atan2(v1.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().acos(),\n                                  v1.getX().atan2(v1.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getX().negate()),\n                                  v2.getY().acos(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (Vector3D.plusK) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (Vector3D.plusK) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().acos(),\n                                  v1.getY().atan2(v1.getX().negate()));\n\n            }\n        }\n\n    }\n\n    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */\n    private T[] buildArray(final T a0, final T a1, final T a2) {\n        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n        array[0] = a0;\n        array[1] = a1;\n        array[2] = a2;\n        return array;\n    }\n\n    /** Create a constant vector.\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @return a constant vector\n     */\n    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n        final T zero = q0.getField().getZero();\n        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n    }\n\n    /** Get the 3X3 matrix corresponding to the instance\n     * @return the matrix corresponding to the instance\n     */\n    public T[][] getMatrix() {\n\n        // products\n        final T q0q0  = q0.multiply(q0);\n        final T q0q1  = q0.multiply(q1);\n        final T q0q2  = q0.multiply(q2);\n        final T q0q3  = q0.multiply(q3);\n        final T q1q1  = q1.multiply(q1);\n        final T q1q2  = q1.multiply(q2);\n        final T q1q3  = q1.multiply(q3);\n        final T q2q2  = q2.multiply(q2);\n        final T q2q3  = q2.multiply(q3);\n        final T q3q3  = q3.multiply(q3);\n\n        // create the matrix\n        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n\n        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n        m [2][0] = q1q3.add(q0q2).multiply(2);\n\n        m [0][1] = q1q2.add(q0q3).multiply(2);\n        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n\n        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n        m [1][2] = q2q3.add(q0q1).multiply(2);\n        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n\n        return m;\n\n    }\n\n    /** Convert to a constant vector without derivatives.\n     * @return a constant vector\n     */\n    public Rotation toRotation() {\n        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n\n        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyInverseTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyInverseTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the inverse of the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n        final double m0 = -r.getQ0();\n\n        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(FieldRotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : r.composeInternal(this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n                                    false);\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(Rotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final Rotation r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : applyTo(r, this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n                        q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n                        false);\n    }\n\n    /** Apply a rotation to another rotation.\n     * Applying a rotation to another rotation is computing the composition\n     * in an order compliant with the following rule : let u be any\n     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n     * where comp = applyTo(rOuter, rInner).\n     * @param r1 rotation to apply\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(FieldRotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : r.composeInternal(revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(Rotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final Rotation r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : applyTo(r, revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n                                    false);\n    }\n\n    /** Apply the inverse of a rotation to another rotation.\n     * Applying the inverse of a rotation to another rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n     * let w be the inverse image of v by rOuter\n     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n     * comp = applyInverseTo(rOuter, rInner).\n     * @param rOuter rotation to apply the rotation to\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n                                    false);\n    }\n\n    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @exception NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */\n    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        T x00 = m[0][0];\n        T x01 = m[0][1];\n        T x02 = m[0][2];\n        T x10 = m[1][0];\n        T x11 = m[1][1];\n        T x12 = m[1][2];\n        T x20 = m[2][0];\n        T x21 = m[2][1];\n        T x22 = m[2][2];\n        double fn = 0;\n        double fn1;\n\n        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n        int i = 0;\n        while (++i < 11) {\n\n            // Mt.Xn\n            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n\n            // Xn+1\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n\n            // correction on each elements\n            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n\n            // Frobenius norm of the correction\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n            // convergence test\n            if (FastMath.abs(fn1 - fn) <= threshold) {\n                return o;\n            }\n\n            // prepare next iteration\n            x00 = o[0][0];\n            x01 = o[0][1];\n            x02 = o[0][2];\n            x10 = o[1][0];\n            x11 = o[1][1];\n            x12 = o[1][2];\n            x20 = o[2][0];\n            x21 = o[2][1];\n            x22 = o[2][2];\n            fn  = fn1;\n\n        }\n\n        // the algorithm did not converge after 10 iterations\n        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n                                              i - 1);\n\n    }\n\n    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */\n    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n        return r1.composeInverseInternal(r2).getAngle();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static boolean isPrime(int n)"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static int nextPrime(int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int smallTrialDivision(int n, final List<Integer> factors)"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors)"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static List<Integer> trialDivision(int n)"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static boolean millerRabinPrimeTest(final int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int rhoBrent(final int n)"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int gcdPositive(int a, int b)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "public static GaussianCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "public static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights)"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights)"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter)"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker)"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "public static HarmonicCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "public static PolynomialCurveFitter create(int degree)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction compose(final UnivariateFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction add(final UnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction multiply(final UnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue)"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f)"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f)"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f)"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f)"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double midpoint(double a, double b)"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isSequence(final double start, final double mid, final double end)"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "public static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createConstant(final double value)"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createVariable(final int idx, final double value)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient hypot(final SparseGradient x, final SparseGradient y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient pow(final double a, final SparseGradient x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient atan2(final SparseGradient y, final SparseGradient x)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure pow(final double a, final DerivativeStructure x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "public static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createChebyshevPolynomial(final int degree)"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createHermitePolynomial(final int degree)"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLaguerrePolynomial(final int degree)"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLegendrePolynomial(final int degree)"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w)"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static double[] shift(final double[] coefficients, final double shift)"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "protected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(double x, double y, double eps)"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(final double x, final double y, final int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y, float eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, float eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final float x, final float y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsWithRelativeTolerance(double x, double y, double eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, double eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final double x, final double y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, int maxUlps)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale, int roundingMethod)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double representableDelta(double x, double originalDelta)"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor wrap(final IntegerSequence.Incrementor incrementor)"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] scale(double val, final double[] arr)"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double cosAngle(double[] v1, double[] v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(double[] a, double[] b, boolean abort)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(int[] a, int[] b, boolean abort)"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double safeNorm(double[] v)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source, int len)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source, int len)"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOfRange(double[] source, int from, int to)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(float[] x, float[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(float[] x, float[] y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(double[] x, double[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(double[] x, double[] y)"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] natural(int n)"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] sequence(int size, int start, int stride)"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] concatenate(double[]... x)"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] unique(double[] data)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "public static <K, V> Pair<K, V> create(K k, V v)"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowCos(final double x, final double[] result)"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowSin(final double x, final double[] result)"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowexp(final double x, final double[] result)"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double expint(int p, final double[] result)"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double[] slowLog(double xi)"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static String format(double d)"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sqrt(final double a)"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cosh(double x)"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sinh(double x)"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tanh(double x)"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acosh(final double a)"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asinh(double a)"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atanh(double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double signum(final double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float signum(final float a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextUp(final double a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextUp(final float a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextDown(final double a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextDown(final float a)"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double random()"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double exp(double x)"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double expm1(double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(final double x)"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log1p(final double x)"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log10(final double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(double base, double x)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(final double x, final double y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, int e)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, long e)"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sin(double x)"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cos(double x)"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tan(double x)"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan(double x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan2(double y, double x)"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asin(double x)"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acos(double x)"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cbrt(double x)"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toRadians(double x)"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toDegrees(double x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int abs(final int x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long abs(final long x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float abs(final float x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double abs(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ulp(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float ulp(float x)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double scalb(final double d, final int n)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float scalb(final float f, final int n)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextAfter(double d, double direction)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextAfter(final float f, final double direction)"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double floor(double x)"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ceil(double x)"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double rint(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long round(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int round(final float x)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int min(final int a, final int b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long min(final long a, final long b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float min(final float a, final float b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double min(final double a, final double b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int max(final int a, final int b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long max(final long a, final long b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float max(final float a, final float b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double max(final double a, final double b)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double hypot(final double x, final double y)"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double IEEEremainder(double dividend, double divisor)"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int toIntExact(final long n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int incrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long incrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int decrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long decrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int addExact(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long addExact(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int subtractExact(final int a, final int b)"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long subtractExact(final long a, final long b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int multiplyExact(final int a, final int b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long multiplyExact(final long a, final long b)"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorDiv(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorDiv(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorMod(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorMod(final long a, final long b)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double copySign(double magnitude, double sign)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float copySign(float magnitude, float sign)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final double d)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final float f)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "public static BigRealField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "public static final Decimal64Field getInstance()"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double value)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static boolean equals(double x, double y)"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double[] value)"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double normalizeAngle(double a, double center)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T max(final T e1, final T e2)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T min(final T e1, final T e2)"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double reduce(double a, double period, double offset)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static byte copySign(byte magnitude, byte sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static short copySign(short magnitude, short sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int copySign(int magnitude, int sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static long copySign(long magnitude, long sign) throws MathArithmeticException"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos)"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos)"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(int start, int end)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(final int start, final int max, final int step)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Incrementor create()"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor create()"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntA()"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntB()"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracA()"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracB()"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[][] loadLnMant()"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static Iterator<int[]> combinationsIterator(int n, int k)"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int addAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long addAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int gcd(int p, int q) throws MathArithmeticException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long gcd(final long p, final long q) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int lcm(int a, int b) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long lcm(long a, long b) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int mulAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long mulAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int subAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long subAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static boolean isPowerOfTwo(long n)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(Locale locale)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "public static ComplexField getInstance()"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion multiply(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion add(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion subtract(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static double dotProduct(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart, double imaginaryPart)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart)"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex[] convertToComplex(double[] real)"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance(final Locale locale)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(final int rows, final int columns)"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealIdentityMatrix(int dimension)"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension)"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal)"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal)"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static boolean isSymmetric(RealMatrix matrix, double eps)"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m)"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m)"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix blockInverse(RealMatrix m, int splitIndex)"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] createBlocksLayout(final int rows, final int columns)"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "public static RealVector unmodifiableRealVector(final RealVector v)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance(final Locale locale)"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "public static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getStirlingError(double z)"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getDeviancePart(double x, double mu)"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double logBinomialProbability(int x, int n, double p, double q)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper2(final double x)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper2(final double x)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "public static MaxIter unlimited()"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "public static SimpleBounds unbounded(int dim)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "public static MaxEval unlimited()"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x)"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfc(double x)"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x1, double x2)"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfInv(final double x)"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfcInv(final double x)"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static BesselJResult rjBesl(double x, double alpha, int nb)"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma(double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(double a, double x)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double digamma(double x)"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double trigamma(double x)"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double lanczos(final double x)"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double invGamma1pm1(final double x)"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double gamma(final double x)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, double epsilon)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, int maxIterations)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(double a, double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(final double p, final double q)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "public static DummyStepHandler getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "public static AdamsNordsieckTransformer getInstance(final int nSteps)"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "public static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps)"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] normalize(final double[] sample)"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample) throws MathIllegalArgumentException"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample, final int begin, final int length)"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double exactP(double d, int m, int n, boolean strict)"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double approximateP(double d, int n, int m)"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double monteCarloP(double d, int n, int m, boolean strict, int iterations)"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "public static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics)"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final double min, final double max)"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc)"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final DfpField field, final String a)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final Dfp a)"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp splitPow(final Dfp[] base, int a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp base, int a)"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp exp(final Dfp a)"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp expInternal(final Dfp a)"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp log(Dfp a)"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] logInternal(final Dfp[] a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp x, final Dfp y)"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp sinInternal(Dfp[] a)"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp cosInternal(Dfp[] a)"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp sin(final Dfp a)"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp cos(Dfp a)"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp tan(final Dfp a)"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp atanInternal(final Dfp a)"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp atan(final Dfp a)"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp asin(final Dfp a)"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp acos(Dfp a)"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static Dfp copysign(final Dfp x, final Dfp y)"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeExp(final Dfp a, final Dfp one)"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two)"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "public static synchronized RandomGenerator getRandomGenerator()"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> randomPermutation(final int l)"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> identityPermutation(final int l)"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator)"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "public static List<Integer> randomBinaryRepresentation(int length)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static double distance(Rotation r1, Rotation r2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "public static Euclidean3D getInstance()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double dotProduct(Vector3D v1, Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance1(Vector3D v1, Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceInf(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceSq(Vector3D v1, Vector3D v2)"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "public static Euclidean1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance(final Locale locale)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distance(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceInf(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceSq(Vector1D p1, Vector1D p2)"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distance(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceInf(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceSq(Vector2D p1, Vector2D p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "public static Euclidean2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static double distance(S1Point p1, S1Point p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "public static Sphere1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "public static Sphere2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "public static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static double distance(S2Point p1, S2Point p2)"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "public static Random createAdaptor(RandomGenerator randomGenerator)"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static RandomGenerator createRandomGenerator(final Random rng)"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static long convertToLong(int[] seed)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static String formatBigFraction(final BigFraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static Fraction getReducedFraction(int numerator, int denominator)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static BigFraction getReducedFraction(final int numerator, final int denominator)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static String formatFraction(Fraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "public static FractionField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "public static BigFractionField getInstance()"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "public static Object[] flatten(Object[] array)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[] scaleArray(double[] f, double d)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] scaleArray(Complex[] f, double d)"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[][] createRealImaginaryArray(final Complex[] dataC)"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static int exactLog2(final int n) throws MathIllegalArgumentException"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "static final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "public static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "public static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "public static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "public static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "protected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "static final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "static final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "static final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "static final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "1",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "r",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation"
            ],
            [
                "convention",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationConvention"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final FieldRotation<T> r)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final Vector3D u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final Rotation r)"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ3()"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getAngle()"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ1()"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final Rotation r)"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ2()"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[][] getMatrix()"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final Vector3D u)"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> revert()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order) throws CardanEulerSingularityException"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final FieldRotation<T> r)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final FieldVector3D<T> u)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ0()"
            ],
            [
                "toRotation",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public Rotation toRotation()"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis(final RotationConvention convention)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u)"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order, RotationConvention convention) throws CardanEulerSingularityException"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ3()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D getAxis()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D applyTo(Vector3D arg0)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D getAxis(RotationConvention arg0)"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double[] getAngles(RotationOrder arg0) throws CardanEulerSingularityException"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ0()"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ1()"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getAngle()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Vector3D applyInverseTo(Vector3D arg0)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation compose(Rotation arg0, RotationConvention arg1)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation composeInverse(Rotation arg0, RotationConvention arg1)"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation revert()"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double[][] getMatrix()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation applyTo(Rotation arg0)"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double getQ2()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public double[] getAngles(RotationOrder arg0, RotationConvention arg1) throws CardanEulerSingularityException"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public Rotation applyInverseTo(Rotation arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Enum",
                "public final int hashCode()"
            ],
            [
                "describeConstable",
                "java.lang",
                "Enum",
                "public final Optional<Enum.EnumDesc<E>> describeConstable()"
            ],
            [
                "getDeclaringClass",
                "java.lang",
                "Enum",
                "public final Class<E> getDeclaringClass()"
            ],
            [
                "clone",
                "java.lang",
                "Enum",
                "protected final Object clone() throws CloneNotSupportedException"
            ],
            [
                "ordinal",
                "java.lang",
                "Enum",
                "public final int ordinal()"
            ],
            [
                "toString",
                "java.lang",
                "Enum",
                "public String toString()"
            ],
            [
                "compareTo",
                "java.lang",
                "Enum",
                "public final int compareTo(E arg0)"
            ],
            [
                "name",
                "java.lang",
                "Enum",
                "public final String name()"
            ],
            [
                "equals",
                "java.lang",
                "Enum",
                "public final boolean equals(Object arg0)"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 23708,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.geometry.euclidean.threed",
        "className": "FieldRotation",
        "javadocTag": "@throws NotARotationMatrixException if the matrix cannot be\northogonalized with the given threshold after 10 iterations",
        "methodJavadoc": "    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @throws NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */",
        "methodSourceCode": "private T[][] orthogonalizeMatrix(final T[][] m, final double threshold) throws NotARotationMatrixException{\n    T x00 = m[0][0];\n    T x01 = m[0][1];\n    T x02 = m[0][2];\n    T x10 = m[1][0];\n    T x11 = m[1][1];\n    T x12 = m[1][2];\n    T x20 = m[2][0];\n    T x21 = m[2][1];\n    T x22 = m[2][2];\n    double fn = 0;\n    double fn1;\n    final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n    // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n    int i = 0;\n    while (++i < 11) {\n        // Mt.Xn\n        final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n        final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n        final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n        final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n        final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n        final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n        final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n        final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n        final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n        // Xn+1\n        o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n        o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n        o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n        o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n        o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n        o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n        o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n        o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n        o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n        // correction on each elements\n        final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n        final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n        final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n        final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n        final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n        final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n        final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n        final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n        final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n        // Frobenius norm of the correction\n        fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 + corr10 * corr10 + corr11 * corr11 + corr12 * corr12 + corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n        // convergence test\n        if (FastMath.abs(fn1 - fn) <= threshold) {\n            return o;\n        }\n        // prepare next iteration\n        x00 = o[0][0];\n        x01 = o[0][1];\n        x02 = o[0][2];\n        x10 = o[1][0];\n        x11 = o[1][1];\n        x12 = o[1][2];\n        x20 = o[2][0];\n        x21 = o[2][1];\n        x22 = o[2][2];\n        fn = fn1;\n    }\n    // the algorithm did not converge after 10 iterations\n    throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX, i - 1);\n}",
        "classJavadoc": "/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.RealFieldElement;\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */\n\npublic class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 20130224l;\n\n    /** Scalar coordinate of the quaternion. */\n    private final T q0;\n\n    /** First coordinate of the vectorial part of the quaternion. */\n    private final T q1;\n\n    /** Second coordinate of the vectorial part of the quaternion. */\n    private final T q2;\n\n    /** Third coordinate of the vectorial part of the quaternion. */\n    private final T q3;\n\n    /** Build a rotation from the quaternion coordinates.\n     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n     * the constructor can normalize it in a preprocessing step.</p>\n     * <p>Note that some conventions put the scalar part of the quaternion\n     * as the 4<sup>th</sup> component and the vector part as the first three\n     * components. This is <em>not</em> our convention. We put the scalar part\n     * as the first component.</p>\n     * @param q0 scalar part of the quaternion\n     * @param q1 first coordinate of the vectorial part of the quaternion\n     * @param q2 second coordinate of the vectorial part of the quaternion\n     * @param q3 third coordinate of the vectorial part of the quaternion\n     * @param needsNormalization if true, the coordinates are considered\n     * not to be normalized, a normalization preprocessing step is performed\n     * before using them\n     */\n    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n\n        if (needsNormalization) {\n            // normalization preprocessing\n            final T inv =\n                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n            this.q0 = inv.multiply(q0);\n            this.q1 = inv.multiply(q1);\n            this.q2 = inv.multiply(q2);\n            this.q3 = inv.multiply(q3);\n        } else {\n            this.q0 = q0;\n            this.q1 = q1;\n            this.q2 = q2;\n            this.q3 = q3;\n        }\n\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}\n     */\n    @Deprecated\n    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n        throws MathIllegalArgumentException {\n        this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @param convention convention to use for the semantics of the angle\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @since 3.6\n     */\n    public FieldRotation(final FieldVector3D<T> axis, final T angle, final RotationConvention convention)\n        throws MathIllegalArgumentException {\n\n        final T norm = axis.getNorm();\n        if (norm.getReal() == 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n        }\n\n        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);\n        final T coeff = halfAngle.sin().divide(norm);\n\n        q0 = halfAngle.cos();\n        q1 = coeff.multiply(axis.getX());\n        q2 = coeff.multiply(axis.getY());\n        q3 = coeff.multiply(axis.getZ());\n\n    }\n\n    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @exception NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */\n    public FieldRotation(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        // dimension check\n        if ((m.length != 3) || (m[0].length != 3) ||\n                (m[1].length != 3) || (m[2].length != 3)) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                  m.length, m[0].length);\n        }\n\n        // compute a \"close\" orthogonal matrix\n        final T[][] ort = orthogonalizeMatrix(m, threshold);\n\n        // check the sign of the determinant\n        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n        final T det =\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n        if (det.getReal() < 0.0) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n                                                  det);\n        }\n\n        final T[] quat = mat2quat(ort);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build the rotation that transforms a pair of vectors into another pair.\n\n     * <p>Except for possible scale factors, if the instance were applied to\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n     * not the same as the angular separation between v<sub>1</sub> and\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>,\n     * +v<sub>2</sub>) half-plane.</p>\n\n     * @param u1 first vector of the origin pair\n     * @param u2 second vector of the origin pair\n     * @param v1 desired image of u1 by the rotation\n     * @param v2 desired image of u2 by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\n     */\n    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n        throws MathArithmeticException {\n\n        // build orthonormalized base from u1, u2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n        u1 = u1.normalize();\n\n        // build an orthonormalized base from v1, v2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n        v1 = v1.normalize();\n\n        // buid a matrix transforming the first base into the second one\n        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n\n        T[] quat = mat2quat(array);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build one of the rotations that transform one vector into another one.\n\n     * <p>Except for a possible scale factor, if the instance were\n     * applied to the vector u it will produce the vector v. There is an\n     * infinite number of such rotations, this constructor choose the\n     * one with the smallest associated angle (i.e. the one whose axis\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\n     * arbitrary rotation axis is chosen.</p>\n\n     * @param u origin vector\n     * @param v desired image of u by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero\n     */\n    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n\n        final T normProduct = u.getNorm().multiply(v.getNorm());\n        if (normProduct.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n        }\n\n        final T dot = FieldVector3D.dotProduct(u, v);\n\n        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n            // special case u = -v: we select a PI angle rotation around\n            // an arbitrary vector orthogonal to u\n            final FieldVector3D<T> w = u.orthogonal();\n            q0 = normProduct.getField().getZero();\n            q1 = w.getX().negate();\n            q2 = w.getY().negate();\n            q3 = w.getZ().negate();\n        } else {\n            // general case: (u, v) defines a plane, we select\n            // the shortest possible rotation: axis orthogonal to this plane\n            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n            q1 = coeff.multiply(q.getX());\n            q2 = coeff.multiply(q.getY());\n            q3 = coeff.multiply(q.getZ());\n        }\n\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to use\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(RotationOrder, RotationConvention,\n     * RealFieldElement, RealFieldElement, RealFieldElement)}\n     */\n    @Deprecated\n    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to compose, from left to right\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\n     * @param convention convention to use for the semantics of the angle\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @since 3.6\n     */\n    public FieldRotation(final RotationOrder order, final RotationConvention convention,\n                         final T alpha1, final T alpha2, final T alpha3) {\n        final T one = alpha1.getField().getOne();\n        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1, convention);\n        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2, convention);\n        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3, convention);\n        final FieldRotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\n        q0 = composed.q0;\n        q1 = composed.q1;\n        q2 = composed.q2;\n        q3 = composed.q3;\n    }\n\n    /** Convert an orthogonal rotation matrix to a quaternion.\n     * @param ort orthogonal rotation matrix\n     * @return quaternion corresponding to the matrix\n     */\n    private T[] mat2quat(final T[][] ort) {\n\n        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n\n        // There are different ways to compute the quaternions elements\n        // from the matrix. They all involve computing one element from\n        // the diagonal of the matrix, and computing the three other ones\n        // using a formula involving a division by the first element,\n        // which unfortunately can be zero. Since the norm of the\n        // quaternion is 1, we know at least one element has an absolute\n        // value greater or equal to 0.5, so it is always possible to\n        // select the right formula and avoid division by zero and even\n        // numerical inaccuracy. Checking the elements in turn and using\n        // the first one greater than 0.45 is safe (this leads to a simple\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n        if (s.getReal() > -0.19) {\n            // compute q0 and deduce q1, q2 and q3\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n            T inv = quat[0].reciprocal().multiply(0.25);\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n        } else {\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n            if (s.getReal() > -0.19) {\n                // compute q1 and deduce q0, q2 and q3\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n                T inv = quat[1].reciprocal().multiply(0.25);\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n            } else {\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n                if (s.getReal() > -0.19) {\n                    // compute q2 and deduce q0, q1 and q3\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[2].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n                } else {\n                    // compute q3 and deduce q0, q1 and q2\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[3].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n                }\n            }\n        }\n\n        return quat;\n\n    }\n\n    /** Revert a rotation.\n     * Build a rotation which reverse the effect of another\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n     * instance is not changed.\n     * @return a new rotation whose effect is the reverse of the effect\n     * of the instance\n     */\n    public FieldRotation<T> revert() {\n        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n    }\n\n    /** Get the scalar coordinate of the quaternion.\n     * @return scalar coordinate of the quaternion\n     */\n    public T getQ0() {\n        return q0;\n    }\n\n    /** Get the first coordinate of the vectorial part of the quaternion.\n     * @return first coordinate of the vectorial part of the quaternion\n     */\n    public T getQ1() {\n        return q1;\n    }\n\n    /** Get the second coordinate of the vectorial part of the quaternion.\n     * @return second coordinate of the vectorial part of the quaternion\n     */\n    public T getQ2() {\n        return q2;\n    }\n\n    /** Get the third coordinate of the vectorial part of the quaternion.\n     * @return third coordinate of the vectorial part of the quaternion\n     */\n    public T getQ3() {\n        return q3;\n    }\n\n    /** Get the normalized axis of the rotation.\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}\n     */\n    @Deprecated\n    public FieldVector3D<T> getAxis() {\n        return getAxis(RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the normalized axis of the rotation.\n     * <p>\n     * Note that as {@link #getAngle()} always returns an angle\n     * between 0 and &pi;, changing the convention changes the\n     * direction of the axis, not the sign of the angle.\n     * </p>\n     * @param convention convention to use for the semantics of the angle\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @since 3.6\n     */\n    public FieldVector3D<T> getAxis(final RotationConvention convention) {\n        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n        if (squaredSine.getReal() == 0) {\n            final Field<T> field = squaredSine.getField();\n            return new FieldVector3D<T>(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),\n                                        field.getZero(),\n                                        field.getZero());\n        } else {\n            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n            if (q0.getReal() < 0) {\n                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);\n                return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n            }\n            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);\n            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n        }\n    }\n\n    /** Get the angle of the rotation.\n     * @return angle of the rotation (between 0 and &pi;)\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     */\n    public T getAngle() {\n        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n        } else if (q0.getReal() < 0) {\n            return q0.negate().acos().multiply(2);\n        }\n        return q0.acos().multiply(2);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}\n     */\n    @Deprecated\n    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n        return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @param convention convention to use for the semantics of the angle\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @since 3.6\n     */\n    public T[] getAngles(final RotationOrder order, RotationConvention convention)\n        throws CardanEulerSingularityException {\n\n        if (convention == RotationConvention.VECTOR_OPERATOR) {\n            if (order == RotationOrder.XYZ) {\n\n                // r (+K) coordinates are :\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (+I) coordinates are :\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                                  v2.getZ().asin(),\n                                  v2.getY().negate().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (+J) coordinates are :\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n                // (-r) (+I) coordinates are :\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getY().asin().negate(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (+K) coordinates are :\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getZ().asin().negate(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (+I) coordinates are :\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                                  v2.getX().asin(),\n                                  v2.getZ().negate().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (+J) coordinates are :\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().negate().atan2(v1.getY()),\n                                  v2.getY().asin(),\n                                  v2.getX().negate().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getX().asin().negate(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n                // (-r) (+I) coordinates are :\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (+I) coordinates are :\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n                // (-r) (+I) coordinates are :\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getX().acos(),\n                                  v2.getZ().atan2(v2.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (+J) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // (-r) (+J) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getY().acos(),\n                                  v2.getX().atan2(v2.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (+J) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                                  v2.getY().acos(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (+K) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // (-r) (+K) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (+K) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getZ().acos(),\n                                  v2.getY().atan2(v2.getX().negate()));\n\n            }\n        } else {\n            if (order == RotationOrder.XYZ) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().negate().atan2(v2.getZ()),\n                                  v2.getX().asin(),\n                                  v1.getY().negate().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().asin().negate(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().asin().negate(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().negate().atan2(v2.getX()),\n                                  v2.getY().asin(),\n                                  v1.getZ().negate().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().negate().atan2(v2.getY()),\n                                  v2.getZ().asin(),\n                                  v1.getX().negate().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().asin().negate(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().acos(),\n                                  v1.getZ().atan2(v1.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().acos(),\n                                  v1.getX().atan2(v1.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getX().negate()),\n                                  v2.getY().acos(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (Vector3D.plusK) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (Vector3D.plusK) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().acos(),\n                                  v1.getY().atan2(v1.getX().negate()));\n\n            }\n        }\n\n    }\n\n    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */\n    private T[] buildArray(final T a0, final T a1, final T a2) {\n        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n        array[0] = a0;\n        array[1] = a1;\n        array[2] = a2;\n        return array;\n    }\n\n    /** Create a constant vector.\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @return a constant vector\n     */\n    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n        final T zero = q0.getField().getZero();\n        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n    }\n\n    /** Get the 3X3 matrix corresponding to the instance\n     * @return the matrix corresponding to the instance\n     */\n    public T[][] getMatrix() {\n\n        // products\n        final T q0q0  = q0.multiply(q0);\n        final T q0q1  = q0.multiply(q1);\n        final T q0q2  = q0.multiply(q2);\n        final T q0q3  = q0.multiply(q3);\n        final T q1q1  = q1.multiply(q1);\n        final T q1q2  = q1.multiply(q2);\n        final T q1q3  = q1.multiply(q3);\n        final T q2q2  = q2.multiply(q2);\n        final T q2q3  = q2.multiply(q3);\n        final T q3q3  = q3.multiply(q3);\n\n        // create the matrix\n        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n\n        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n        m [2][0] = q1q3.add(q0q2).multiply(2);\n\n        m [0][1] = q1q2.add(q0q3).multiply(2);\n        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n\n        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n        m [1][2] = q2q3.add(q0q1).multiply(2);\n        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n\n        return m;\n\n    }\n\n    /** Convert to a constant vector without derivatives.\n     * @return a constant vector\n     */\n    public Rotation toRotation() {\n        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n\n        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyInverseTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyInverseTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the inverse of the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n        final double m0 = -r.getQ0();\n\n        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(FieldRotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : r.composeInternal(this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n                                    false);\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(Rotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final Rotation r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : applyTo(r, this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n                        q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n                        false);\n    }\n\n    /** Apply a rotation to another rotation.\n     * Applying a rotation to another rotation is computing the composition\n     * in an order compliant with the following rule : let u be any\n     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n     * where comp = applyTo(rOuter, rInner).\n     * @param r1 rotation to apply\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(FieldRotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : r.composeInternal(revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(Rotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final Rotation r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : applyTo(r, revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n                                    false);\n    }\n\n    /** Apply the inverse of a rotation to another rotation.\n     * Applying the inverse of a rotation to another rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n     * let w be the inverse image of v by rOuter\n     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n     * comp = applyInverseTo(rOuter, rInner).\n     * @param rOuter rotation to apply the rotation to\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n                                    false);\n    }\n\n    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @exception NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */\n    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        T x00 = m[0][0];\n        T x01 = m[0][1];\n        T x02 = m[0][2];\n        T x10 = m[1][0];\n        T x11 = m[1][1];\n        T x12 = m[1][2];\n        T x20 = m[2][0];\n        T x21 = m[2][1];\n        T x22 = m[2][2];\n        double fn = 0;\n        double fn1;\n\n        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n        int i = 0;\n        while (++i < 11) {\n\n            // Mt.Xn\n            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n\n            // Xn+1\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n\n            // correction on each elements\n            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n\n            // Frobenius norm of the correction\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n            // convergence test\n            if (FastMath.abs(fn1 - fn) <= threshold) {\n                return o;\n            }\n\n            // prepare next iteration\n            x00 = o[0][0];\n            x01 = o[0][1];\n            x02 = o[0][2];\n            x10 = o[1][0];\n            x11 = o[1][1];\n            x12 = o[1][2];\n            x20 = o[2][0];\n            x21 = o[2][1];\n            x22 = o[2][2];\n            fn  = fn1;\n\n        }\n\n        // the algorithm did not converge after 10 iterations\n        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n                                              i - 1);\n\n    }\n\n    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */\n    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n        return r1.composeInverseInternal(r2).getAngle();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static boolean isPrime(int n)"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static int nextPrime(int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int smallTrialDivision(int n, final List<Integer> factors)"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors)"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static List<Integer> trialDivision(int n)"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static boolean millerRabinPrimeTest(final int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int rhoBrent(final int n)"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int gcdPositive(int a, int b)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "public static GaussianCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "public static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights)"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights)"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter)"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker)"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "public static HarmonicCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "public static PolynomialCurveFitter create(int degree)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction compose(final UnivariateFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction add(final UnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction multiply(final UnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue)"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f)"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f)"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f)"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f)"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double midpoint(double a, double b)"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isSequence(final double start, final double mid, final double end)"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "public static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createConstant(final double value)"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createVariable(final int idx, final double value)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient hypot(final SparseGradient x, final SparseGradient y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient pow(final double a, final SparseGradient x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient atan2(final SparseGradient y, final SparseGradient x)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure pow(final double a, final DerivativeStructure x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "public static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createChebyshevPolynomial(final int degree)"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createHermitePolynomial(final int degree)"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLaguerrePolynomial(final int degree)"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLegendrePolynomial(final int degree)"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w)"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static double[] shift(final double[] coefficients, final double shift)"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "protected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(double x, double y, double eps)"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(final double x, final double y, final int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y, float eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, float eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final float x, final float y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsWithRelativeTolerance(double x, double y, double eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, double eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final double x, final double y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, int maxUlps)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale, int roundingMethod)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double representableDelta(double x, double originalDelta)"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor wrap(final IntegerSequence.Incrementor incrementor)"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] scale(double val, final double[] arr)"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double cosAngle(double[] v1, double[] v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(double[] a, double[] b, boolean abort)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(int[] a, int[] b, boolean abort)"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double safeNorm(double[] v)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source, int len)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source, int len)"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOfRange(double[] source, int from, int to)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(float[] x, float[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(float[] x, float[] y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(double[] x, double[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(double[] x, double[] y)"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] natural(int n)"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] sequence(int size, int start, int stride)"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] concatenate(double[]... x)"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] unique(double[] data)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "public static <K, V> Pair<K, V> create(K k, V v)"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowCos(final double x, final double[] result)"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowSin(final double x, final double[] result)"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowexp(final double x, final double[] result)"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double expint(int p, final double[] result)"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double[] slowLog(double xi)"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static String format(double d)"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sqrt(final double a)"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cosh(double x)"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sinh(double x)"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tanh(double x)"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acosh(final double a)"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asinh(double a)"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atanh(double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double signum(final double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float signum(final float a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextUp(final double a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextUp(final float a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextDown(final double a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextDown(final float a)"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double random()"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double exp(double x)"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double expm1(double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(final double x)"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log1p(final double x)"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log10(final double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(double base, double x)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(final double x, final double y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, int e)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, long e)"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sin(double x)"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cos(double x)"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tan(double x)"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan(double x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan2(double y, double x)"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asin(double x)"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acos(double x)"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cbrt(double x)"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toRadians(double x)"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toDegrees(double x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int abs(final int x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long abs(final long x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float abs(final float x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double abs(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ulp(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float ulp(float x)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double scalb(final double d, final int n)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float scalb(final float f, final int n)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextAfter(double d, double direction)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextAfter(final float f, final double direction)"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double floor(double x)"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ceil(double x)"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double rint(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long round(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int round(final float x)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int min(final int a, final int b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long min(final long a, final long b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float min(final float a, final float b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double min(final double a, final double b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int max(final int a, final int b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long max(final long a, final long b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float max(final float a, final float b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double max(final double a, final double b)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double hypot(final double x, final double y)"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double IEEEremainder(double dividend, double divisor)"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int toIntExact(final long n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int incrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long incrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int decrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long decrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int addExact(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long addExact(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int subtractExact(final int a, final int b)"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long subtractExact(final long a, final long b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int multiplyExact(final int a, final int b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long multiplyExact(final long a, final long b)"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorDiv(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorDiv(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorMod(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorMod(final long a, final long b)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double copySign(double magnitude, double sign)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float copySign(float magnitude, float sign)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final double d)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final float f)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "public static BigRealField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "public static final Decimal64Field getInstance()"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double value)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static boolean equals(double x, double y)"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double[] value)"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double normalizeAngle(double a, double center)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T max(final T e1, final T e2)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T min(final T e1, final T e2)"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double reduce(double a, double period, double offset)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static byte copySign(byte magnitude, byte sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static short copySign(short magnitude, short sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int copySign(int magnitude, int sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static long copySign(long magnitude, long sign) throws MathArithmeticException"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos)"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos)"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(int start, int end)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(final int start, final int max, final int step)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Incrementor create()"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor create()"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntA()"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntB()"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracA()"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracB()"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[][] loadLnMant()"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static Iterator<int[]> combinationsIterator(int n, int k)"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int addAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long addAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int gcd(int p, int q) throws MathArithmeticException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long gcd(final long p, final long q) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int lcm(int a, int b) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long lcm(long a, long b) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int mulAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long mulAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int subAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long subAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static boolean isPowerOfTwo(long n)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(Locale locale)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "public static ComplexField getInstance()"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion multiply(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion add(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion subtract(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static double dotProduct(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart, double imaginaryPart)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart)"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex[] convertToComplex(double[] real)"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance(final Locale locale)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(final int rows, final int columns)"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealIdentityMatrix(int dimension)"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension)"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal)"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal)"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static boolean isSymmetric(RealMatrix matrix, double eps)"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m)"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m)"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix blockInverse(RealMatrix m, int splitIndex)"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] createBlocksLayout(final int rows, final int columns)"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "public static RealVector unmodifiableRealVector(final RealVector v)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance(final Locale locale)"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "public static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getStirlingError(double z)"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getDeviancePart(double x, double mu)"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double logBinomialProbability(int x, int n, double p, double q)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper2(final double x)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper2(final double x)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "public static MaxIter unlimited()"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "public static SimpleBounds unbounded(int dim)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "public static MaxEval unlimited()"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x)"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfc(double x)"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x1, double x2)"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfInv(final double x)"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfcInv(final double x)"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static BesselJResult rjBesl(double x, double alpha, int nb)"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma(double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(double a, double x)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double digamma(double x)"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double trigamma(double x)"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double lanczos(final double x)"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double invGamma1pm1(final double x)"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double gamma(final double x)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, double epsilon)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, int maxIterations)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(double a, double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(final double p, final double q)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "public static DummyStepHandler getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "public static AdamsNordsieckTransformer getInstance(final int nSteps)"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "public static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps)"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] normalize(final double[] sample)"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample) throws MathIllegalArgumentException"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample, final int begin, final int length)"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double exactP(double d, int m, int n, boolean strict)"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double approximateP(double d, int n, int m)"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double monteCarloP(double d, int n, int m, boolean strict, int iterations)"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "public static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics)"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final double min, final double max)"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc)"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final DfpField field, final String a)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final Dfp a)"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp splitPow(final Dfp[] base, int a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp base, int a)"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp exp(final Dfp a)"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp expInternal(final Dfp a)"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp log(Dfp a)"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] logInternal(final Dfp[] a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp x, final Dfp y)"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp sinInternal(Dfp[] a)"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp cosInternal(Dfp[] a)"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp sin(final Dfp a)"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp cos(Dfp a)"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp tan(final Dfp a)"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp atanInternal(final Dfp a)"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp atan(final Dfp a)"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp asin(final Dfp a)"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp acos(Dfp a)"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static Dfp copysign(final Dfp x, final Dfp y)"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeExp(final Dfp a, final Dfp one)"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two)"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "public static synchronized RandomGenerator getRandomGenerator()"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> randomPermutation(final int l)"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> identityPermutation(final int l)"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator)"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "public static List<Integer> randomBinaryRepresentation(int length)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static double distance(Rotation r1, Rotation r2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "public static Euclidean3D getInstance()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double dotProduct(Vector3D v1, Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance1(Vector3D v1, Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceInf(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceSq(Vector3D v1, Vector3D v2)"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "public static Euclidean1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance(final Locale locale)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distance(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceInf(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceSq(Vector1D p1, Vector1D p2)"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distance(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceInf(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceSq(Vector2D p1, Vector2D p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "public static Euclidean2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static double distance(S1Point p1, S1Point p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "public static Sphere1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "public static Sphere2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "public static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static double distance(S2Point p1, S2Point p2)"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "public static Random createAdaptor(RandomGenerator randomGenerator)"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static RandomGenerator createRandomGenerator(final Random rng)"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static long convertToLong(int[] seed)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static String formatBigFraction(final BigFraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static Fraction getReducedFraction(int numerator, int denominator)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static BigFraction getReducedFraction(final int numerator, final int denominator)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static String formatFraction(Fraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "public static FractionField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "public static BigFractionField getInstance()"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "public static Object[] flatten(Object[] array)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[] scaleArray(double[] f, double d)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] scaleArray(Complex[] f, double d)"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[][] createRealImaginaryArray(final Complex[] dataC)"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static int exactLog2(final int n) throws MathIllegalArgumentException"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "static final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "public static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "public static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "public static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "public static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "protected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "static final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "static final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "static final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "static final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "3",
                "int"
            ],
            [
                "3",
                "int"
            ],
            [
                "10",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "m",
                "",
                "RealFieldElement[][]"
            ],
            [
                "threshold",
                "",
                "double"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ3()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u)"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getAngle()"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[][] getMatrix()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final Rotation r)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final FieldRotation<T> r)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final FieldRotation<T> r)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final Vector3D u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final Vector3D u)"
            ],
            [
                "toRotation",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public Rotation toRotation()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order, RotationConvention convention) throws CardanEulerSingularityException"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ1()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis(final RotationConvention convention)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final Rotation r)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final FieldVector3D<T> u)"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> revert()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ0()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order) throws CardanEulerSingularityException"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ2()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis()"
            ],
            [
                "equals",
                "",
                "T[][]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "T[][]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "T[][]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "T[][]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "T[][]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "length",
                "",
                "T[][]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 23709,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.geometry.euclidean.threed",
        "className": "FieldRotation",
        "javadocTag": "@param r1 first rotation",
        "methodJavadoc": "    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */",
        "methodSourceCode": "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2){\n    return r1.composeInverseInternal(r2).getAngle();\n}",
        "classJavadoc": "/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.RealFieldElement;\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */\n\npublic class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 20130224l;\n\n    /** Scalar coordinate of the quaternion. */\n    private final T q0;\n\n    /** First coordinate of the vectorial part of the quaternion. */\n    private final T q1;\n\n    /** Second coordinate of the vectorial part of the quaternion. */\n    private final T q2;\n\n    /** Third coordinate of the vectorial part of the quaternion. */\n    private final T q3;\n\n    /** Build a rotation from the quaternion coordinates.\n     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n     * the constructor can normalize it in a preprocessing step.</p>\n     * <p>Note that some conventions put the scalar part of the quaternion\n     * as the 4<sup>th</sup> component and the vector part as the first three\n     * components. This is <em>not</em> our convention. We put the scalar part\n     * as the first component.</p>\n     * @param q0 scalar part of the quaternion\n     * @param q1 first coordinate of the vectorial part of the quaternion\n     * @param q2 second coordinate of the vectorial part of the quaternion\n     * @param q3 third coordinate of the vectorial part of the quaternion\n     * @param needsNormalization if true, the coordinates are considered\n     * not to be normalized, a normalization preprocessing step is performed\n     * before using them\n     */\n    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n\n        if (needsNormalization) {\n            // normalization preprocessing\n            final T inv =\n                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n            this.q0 = inv.multiply(q0);\n            this.q1 = inv.multiply(q1);\n            this.q2 = inv.multiply(q2);\n            this.q3 = inv.multiply(q3);\n        } else {\n            this.q0 = q0;\n            this.q1 = q1;\n            this.q2 = q2;\n            this.q3 = q3;\n        }\n\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}\n     */\n    @Deprecated\n    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n        throws MathIllegalArgumentException {\n        this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @param convention convention to use for the semantics of the angle\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @since 3.6\n     */\n    public FieldRotation(final FieldVector3D<T> axis, final T angle, final RotationConvention convention)\n        throws MathIllegalArgumentException {\n\n        final T norm = axis.getNorm();\n        if (norm.getReal() == 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n        }\n\n        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);\n        final T coeff = halfAngle.sin().divide(norm);\n\n        q0 = halfAngle.cos();\n        q1 = coeff.multiply(axis.getX());\n        q2 = coeff.multiply(axis.getY());\n        q3 = coeff.multiply(axis.getZ());\n\n    }\n\n    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @exception NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */\n    public FieldRotation(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        // dimension check\n        if ((m.length != 3) || (m[0].length != 3) ||\n                (m[1].length != 3) || (m[2].length != 3)) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                  m.length, m[0].length);\n        }\n\n        // compute a \"close\" orthogonal matrix\n        final T[][] ort = orthogonalizeMatrix(m, threshold);\n\n        // check the sign of the determinant\n        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n        final T det =\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n        if (det.getReal() < 0.0) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n                                                  det);\n        }\n\n        final T[] quat = mat2quat(ort);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build the rotation that transforms a pair of vectors into another pair.\n\n     * <p>Except for possible scale factors, if the instance were applied to\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n     * not the same as the angular separation between v<sub>1</sub> and\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>,\n     * +v<sub>2</sub>) half-plane.</p>\n\n     * @param u1 first vector of the origin pair\n     * @param u2 second vector of the origin pair\n     * @param v1 desired image of u1 by the rotation\n     * @param v2 desired image of u2 by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\n     */\n    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n        throws MathArithmeticException {\n\n        // build orthonormalized base from u1, u2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n        u1 = u1.normalize();\n\n        // build an orthonormalized base from v1, v2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n        v1 = v1.normalize();\n\n        // buid a matrix transforming the first base into the second one\n        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n\n        T[] quat = mat2quat(array);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build one of the rotations that transform one vector into another one.\n\n     * <p>Except for a possible scale factor, if the instance were\n     * applied to the vector u it will produce the vector v. There is an\n     * infinite number of such rotations, this constructor choose the\n     * one with the smallest associated angle (i.e. the one whose axis\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\n     * arbitrary rotation axis is chosen.</p>\n\n     * @param u origin vector\n     * @param v desired image of u by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero\n     */\n    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n\n        final T normProduct = u.getNorm().multiply(v.getNorm());\n        if (normProduct.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n        }\n\n        final T dot = FieldVector3D.dotProduct(u, v);\n\n        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n            // special case u = -v: we select a PI angle rotation around\n            // an arbitrary vector orthogonal to u\n            final FieldVector3D<T> w = u.orthogonal();\n            q0 = normProduct.getField().getZero();\n            q1 = w.getX().negate();\n            q2 = w.getY().negate();\n            q3 = w.getZ().negate();\n        } else {\n            // general case: (u, v) defines a plane, we select\n            // the shortest possible rotation: axis orthogonal to this plane\n            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n            q1 = coeff.multiply(q.getX());\n            q2 = coeff.multiply(q.getY());\n            q3 = coeff.multiply(q.getZ());\n        }\n\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to use\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(RotationOrder, RotationConvention,\n     * RealFieldElement, RealFieldElement, RealFieldElement)}\n     */\n    @Deprecated\n    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to compose, from left to right\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\n     * @param convention convention to use for the semantics of the angle\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @since 3.6\n     */\n    public FieldRotation(final RotationOrder order, final RotationConvention convention,\n                         final T alpha1, final T alpha2, final T alpha3) {\n        final T one = alpha1.getField().getOne();\n        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1, convention);\n        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2, convention);\n        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3, convention);\n        final FieldRotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\n        q0 = composed.q0;\n        q1 = composed.q1;\n        q2 = composed.q2;\n        q3 = composed.q3;\n    }\n\n    /** Convert an orthogonal rotation matrix to a quaternion.\n     * @param ort orthogonal rotation matrix\n     * @return quaternion corresponding to the matrix\n     */\n    private T[] mat2quat(final T[][] ort) {\n\n        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n\n        // There are different ways to compute the quaternions elements\n        // from the matrix. They all involve computing one element from\n        // the diagonal of the matrix, and computing the three other ones\n        // using a formula involving a division by the first element,\n        // which unfortunately can be zero. Since the norm of the\n        // quaternion is 1, we know at least one element has an absolute\n        // value greater or equal to 0.5, so it is always possible to\n        // select the right formula and avoid division by zero and even\n        // numerical inaccuracy. Checking the elements in turn and using\n        // the first one greater than 0.45 is safe (this leads to a simple\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n        if (s.getReal() > -0.19) {\n            // compute q0 and deduce q1, q2 and q3\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n            T inv = quat[0].reciprocal().multiply(0.25);\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n        } else {\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n            if (s.getReal() > -0.19) {\n                // compute q1 and deduce q0, q2 and q3\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n                T inv = quat[1].reciprocal().multiply(0.25);\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n            } else {\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n                if (s.getReal() > -0.19) {\n                    // compute q2 and deduce q0, q1 and q3\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[2].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n                } else {\n                    // compute q3 and deduce q0, q1 and q2\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[3].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n                }\n            }\n        }\n\n        return quat;\n\n    }\n\n    /** Revert a rotation.\n     * Build a rotation which reverse the effect of another\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n     * instance is not changed.\n     * @return a new rotation whose effect is the reverse of the effect\n     * of the instance\n     */\n    public FieldRotation<T> revert() {\n        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n    }\n\n    /** Get the scalar coordinate of the quaternion.\n     * @return scalar coordinate of the quaternion\n     */\n    public T getQ0() {\n        return q0;\n    }\n\n    /** Get the first coordinate of the vectorial part of the quaternion.\n     * @return first coordinate of the vectorial part of the quaternion\n     */\n    public T getQ1() {\n        return q1;\n    }\n\n    /** Get the second coordinate of the vectorial part of the quaternion.\n     * @return second coordinate of the vectorial part of the quaternion\n     */\n    public T getQ2() {\n        return q2;\n    }\n\n    /** Get the third coordinate of the vectorial part of the quaternion.\n     * @return third coordinate of the vectorial part of the quaternion\n     */\n    public T getQ3() {\n        return q3;\n    }\n\n    /** Get the normalized axis of the rotation.\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}\n     */\n    @Deprecated\n    public FieldVector3D<T> getAxis() {\n        return getAxis(RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the normalized axis of the rotation.\n     * <p>\n     * Note that as {@link #getAngle()} always returns an angle\n     * between 0 and &pi;, changing the convention changes the\n     * direction of the axis, not the sign of the angle.\n     * </p>\n     * @param convention convention to use for the semantics of the angle\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @since 3.6\n     */\n    public FieldVector3D<T> getAxis(final RotationConvention convention) {\n        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n        if (squaredSine.getReal() == 0) {\n            final Field<T> field = squaredSine.getField();\n            return new FieldVector3D<T>(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),\n                                        field.getZero(),\n                                        field.getZero());\n        } else {\n            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n            if (q0.getReal() < 0) {\n                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);\n                return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n            }\n            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);\n            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n        }\n    }\n\n    /** Get the angle of the rotation.\n     * @return angle of the rotation (between 0 and &pi;)\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     */\n    public T getAngle() {\n        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n        } else if (q0.getReal() < 0) {\n            return q0.negate().acos().multiply(2);\n        }\n        return q0.acos().multiply(2);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}\n     */\n    @Deprecated\n    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n        return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @param convention convention to use for the semantics of the angle\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @since 3.6\n     */\n    public T[] getAngles(final RotationOrder order, RotationConvention convention)\n        throws CardanEulerSingularityException {\n\n        if (convention == RotationConvention.VECTOR_OPERATOR) {\n            if (order == RotationOrder.XYZ) {\n\n                // r (+K) coordinates are :\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (+I) coordinates are :\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                                  v2.getZ().asin(),\n                                  v2.getY().negate().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (+J) coordinates are :\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n                // (-r) (+I) coordinates are :\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getY().asin().negate(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (+K) coordinates are :\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getZ().asin().negate(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (+I) coordinates are :\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                                  v2.getX().asin(),\n                                  v2.getZ().negate().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (+J) coordinates are :\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().negate().atan2(v1.getY()),\n                                  v2.getY().asin(),\n                                  v2.getX().negate().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getX().asin().negate(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n                // (-r) (+I) coordinates are :\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (+I) coordinates are :\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n                // (-r) (+I) coordinates are :\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getX().acos(),\n                                  v2.getZ().atan2(v2.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (+J) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // (-r) (+J) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getY().acos(),\n                                  v2.getX().atan2(v2.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (+J) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                                  v2.getY().acos(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (+K) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // (-r) (+K) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (+K) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getZ().acos(),\n                                  v2.getY().atan2(v2.getX().negate()));\n\n            }\n        } else {\n            if (order == RotationOrder.XYZ) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().negate().atan2(v2.getZ()),\n                                  v2.getX().asin(),\n                                  v1.getY().negate().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().asin().negate(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().asin().negate(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().negate().atan2(v2.getX()),\n                                  v2.getY().asin(),\n                                  v1.getZ().negate().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().negate().atan2(v2.getY()),\n                                  v2.getZ().asin(),\n                                  v1.getX().negate().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().asin().negate(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().acos(),\n                                  v1.getZ().atan2(v1.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().acos(),\n                                  v1.getX().atan2(v1.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getX().negate()),\n                                  v2.getY().acos(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (Vector3D.plusK) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (Vector3D.plusK) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().acos(),\n                                  v1.getY().atan2(v1.getX().negate()));\n\n            }\n        }\n\n    }\n\n    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */\n    private T[] buildArray(final T a0, final T a1, final T a2) {\n        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n        array[0] = a0;\n        array[1] = a1;\n        array[2] = a2;\n        return array;\n    }\n\n    /** Create a constant vector.\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @return a constant vector\n     */\n    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n        final T zero = q0.getField().getZero();\n        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n    }\n\n    /** Get the 3X3 matrix corresponding to the instance\n     * @return the matrix corresponding to the instance\n     */\n    public T[][] getMatrix() {\n\n        // products\n        final T q0q0  = q0.multiply(q0);\n        final T q0q1  = q0.multiply(q1);\n        final T q0q2  = q0.multiply(q2);\n        final T q0q3  = q0.multiply(q3);\n        final T q1q1  = q1.multiply(q1);\n        final T q1q2  = q1.multiply(q2);\n        final T q1q3  = q1.multiply(q3);\n        final T q2q2  = q2.multiply(q2);\n        final T q2q3  = q2.multiply(q3);\n        final T q3q3  = q3.multiply(q3);\n\n        // create the matrix\n        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n\n        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n        m [2][0] = q1q3.add(q0q2).multiply(2);\n\n        m [0][1] = q1q2.add(q0q3).multiply(2);\n        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n\n        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n        m [1][2] = q2q3.add(q0q1).multiply(2);\n        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n\n        return m;\n\n    }\n\n    /** Convert to a constant vector without derivatives.\n     * @return a constant vector\n     */\n    public Rotation toRotation() {\n        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n\n        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyInverseTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyInverseTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the inverse of the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n        final double m0 = -r.getQ0();\n\n        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(FieldRotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : r.composeInternal(this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n                                    false);\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(Rotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final Rotation r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : applyTo(r, this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n                        q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n                        false);\n    }\n\n    /** Apply a rotation to another rotation.\n     * Applying a rotation to another rotation is computing the composition\n     * in an order compliant with the following rule : let u be any\n     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n     * where comp = applyTo(rOuter, rInner).\n     * @param r1 rotation to apply\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(FieldRotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : r.composeInternal(revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(Rotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final Rotation r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : applyTo(r, revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n                                    false);\n    }\n\n    /** Apply the inverse of a rotation to another rotation.\n     * Applying the inverse of a rotation to another rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n     * let w be the inverse image of v by rOuter\n     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n     * comp = applyInverseTo(rOuter, rInner).\n     * @param rOuter rotation to apply the rotation to\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n                                    false);\n    }\n\n    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @exception NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */\n    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        T x00 = m[0][0];\n        T x01 = m[0][1];\n        T x02 = m[0][2];\n        T x10 = m[1][0];\n        T x11 = m[1][1];\n        T x12 = m[1][2];\n        T x20 = m[2][0];\n        T x21 = m[2][1];\n        T x22 = m[2][2];\n        double fn = 0;\n        double fn1;\n\n        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n        int i = 0;\n        while (++i < 11) {\n\n            // Mt.Xn\n            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n\n            // Xn+1\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n\n            // correction on each elements\n            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n\n            // Frobenius norm of the correction\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n            // convergence test\n            if (FastMath.abs(fn1 - fn) <= threshold) {\n                return o;\n            }\n\n            // prepare next iteration\n            x00 = o[0][0];\n            x01 = o[0][1];\n            x02 = o[0][2];\n            x10 = o[1][0];\n            x11 = o[1][1];\n            x12 = o[1][2];\n            x20 = o[2][0];\n            x21 = o[2][1];\n            x22 = o[2][2];\n            fn  = fn1;\n\n        }\n\n        // the algorithm did not converge after 10 iterations\n        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n                                              i - 1);\n\n    }\n\n    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */\n    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n        return r1.composeInverseInternal(r2).getAngle();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static boolean isPrime(int n)"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static int nextPrime(int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int smallTrialDivision(int n, final List<Integer> factors)"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors)"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static List<Integer> trialDivision(int n)"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static boolean millerRabinPrimeTest(final int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int rhoBrent(final int n)"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int gcdPositive(int a, int b)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "public static GaussianCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "public static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights)"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights)"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter)"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker)"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "public static HarmonicCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "public static PolynomialCurveFitter create(int degree)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction compose(final UnivariateFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction add(final UnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction multiply(final UnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue)"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f)"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f)"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f)"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f)"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double midpoint(double a, double b)"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isSequence(final double start, final double mid, final double end)"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "public static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createConstant(final double value)"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createVariable(final int idx, final double value)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient hypot(final SparseGradient x, final SparseGradient y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient pow(final double a, final SparseGradient x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient atan2(final SparseGradient y, final SparseGradient x)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure pow(final double a, final DerivativeStructure x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "public static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createChebyshevPolynomial(final int degree)"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createHermitePolynomial(final int degree)"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLaguerrePolynomial(final int degree)"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLegendrePolynomial(final int degree)"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w)"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static double[] shift(final double[] coefficients, final double shift)"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "protected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(double x, double y, double eps)"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(final double x, final double y, final int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y, float eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, float eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final float x, final float y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsWithRelativeTolerance(double x, double y, double eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, double eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final double x, final double y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, int maxUlps)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale, int roundingMethod)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double representableDelta(double x, double originalDelta)"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor wrap(final IntegerSequence.Incrementor incrementor)"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] scale(double val, final double[] arr)"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double cosAngle(double[] v1, double[] v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(double[] a, double[] b, boolean abort)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(int[] a, int[] b, boolean abort)"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double safeNorm(double[] v)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source, int len)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source, int len)"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOfRange(double[] source, int from, int to)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(float[] x, float[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(float[] x, float[] y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(double[] x, double[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(double[] x, double[] y)"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] natural(int n)"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] sequence(int size, int start, int stride)"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] concatenate(double[]... x)"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] unique(double[] data)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "public static <K, V> Pair<K, V> create(K k, V v)"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowCos(final double x, final double[] result)"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowSin(final double x, final double[] result)"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowexp(final double x, final double[] result)"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double expint(int p, final double[] result)"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double[] slowLog(double xi)"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static String format(double d)"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sqrt(final double a)"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cosh(double x)"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sinh(double x)"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tanh(double x)"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acosh(final double a)"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asinh(double a)"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atanh(double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double signum(final double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float signum(final float a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextUp(final double a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextUp(final float a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextDown(final double a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextDown(final float a)"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double random()"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double exp(double x)"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double expm1(double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(final double x)"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log1p(final double x)"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log10(final double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(double base, double x)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(final double x, final double y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, int e)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, long e)"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sin(double x)"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cos(double x)"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tan(double x)"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan(double x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan2(double y, double x)"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asin(double x)"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acos(double x)"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cbrt(double x)"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toRadians(double x)"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toDegrees(double x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int abs(final int x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long abs(final long x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float abs(final float x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double abs(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ulp(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float ulp(float x)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double scalb(final double d, final int n)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float scalb(final float f, final int n)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextAfter(double d, double direction)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextAfter(final float f, final double direction)"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double floor(double x)"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ceil(double x)"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double rint(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long round(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int round(final float x)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int min(final int a, final int b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long min(final long a, final long b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float min(final float a, final float b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double min(final double a, final double b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int max(final int a, final int b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long max(final long a, final long b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float max(final float a, final float b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double max(final double a, final double b)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double hypot(final double x, final double y)"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double IEEEremainder(double dividend, double divisor)"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int toIntExact(final long n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int incrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long incrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int decrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long decrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int addExact(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long addExact(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int subtractExact(final int a, final int b)"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long subtractExact(final long a, final long b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int multiplyExact(final int a, final int b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long multiplyExact(final long a, final long b)"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorDiv(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorDiv(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorMod(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorMod(final long a, final long b)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double copySign(double magnitude, double sign)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float copySign(float magnitude, float sign)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final double d)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final float f)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "public static BigRealField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "public static final Decimal64Field getInstance()"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double value)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static boolean equals(double x, double y)"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double[] value)"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double normalizeAngle(double a, double center)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T max(final T e1, final T e2)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T min(final T e1, final T e2)"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double reduce(double a, double period, double offset)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static byte copySign(byte magnitude, byte sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static short copySign(short magnitude, short sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int copySign(int magnitude, int sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static long copySign(long magnitude, long sign) throws MathArithmeticException"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos)"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos)"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(int start, int end)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(final int start, final int max, final int step)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Incrementor create()"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor create()"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntA()"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntB()"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracA()"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracB()"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[][] loadLnMant()"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static Iterator<int[]> combinationsIterator(int n, int k)"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int addAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long addAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int gcd(int p, int q) throws MathArithmeticException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long gcd(final long p, final long q) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int lcm(int a, int b) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long lcm(long a, long b) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int mulAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long mulAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int subAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long subAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static boolean isPowerOfTwo(long n)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(Locale locale)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "public static ComplexField getInstance()"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion multiply(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion add(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion subtract(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static double dotProduct(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart, double imaginaryPart)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart)"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex[] convertToComplex(double[] real)"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance(final Locale locale)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(final int rows, final int columns)"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealIdentityMatrix(int dimension)"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension)"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal)"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal)"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static boolean isSymmetric(RealMatrix matrix, double eps)"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m)"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m)"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix blockInverse(RealMatrix m, int splitIndex)"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] createBlocksLayout(final int rows, final int columns)"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "public static RealVector unmodifiableRealVector(final RealVector v)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance(final Locale locale)"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "public static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getStirlingError(double z)"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getDeviancePart(double x, double mu)"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double logBinomialProbability(int x, int n, double p, double q)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper2(final double x)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper2(final double x)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "public static MaxIter unlimited()"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "public static SimpleBounds unbounded(int dim)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "public static MaxEval unlimited()"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x)"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfc(double x)"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x1, double x2)"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfInv(final double x)"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfcInv(final double x)"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static BesselJResult rjBesl(double x, double alpha, int nb)"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma(double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(double a, double x)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double digamma(double x)"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double trigamma(double x)"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double lanczos(final double x)"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double invGamma1pm1(final double x)"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double gamma(final double x)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, double epsilon)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, int maxIterations)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(double a, double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(final double p, final double q)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "public static DummyStepHandler getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "public static AdamsNordsieckTransformer getInstance(final int nSteps)"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "public static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps)"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] normalize(final double[] sample)"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample) throws MathIllegalArgumentException"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample, final int begin, final int length)"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double exactP(double d, int m, int n, boolean strict)"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double approximateP(double d, int n, int m)"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double monteCarloP(double d, int n, int m, boolean strict, int iterations)"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "public static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics)"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final double min, final double max)"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc)"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final DfpField field, final String a)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final Dfp a)"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp splitPow(final Dfp[] base, int a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp base, int a)"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp exp(final Dfp a)"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp expInternal(final Dfp a)"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp log(Dfp a)"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] logInternal(final Dfp[] a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp x, final Dfp y)"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp sinInternal(Dfp[] a)"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp cosInternal(Dfp[] a)"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp sin(final Dfp a)"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp cos(Dfp a)"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp tan(final Dfp a)"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp atanInternal(final Dfp a)"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp atan(final Dfp a)"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp asin(final Dfp a)"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp acos(Dfp a)"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static Dfp copysign(final Dfp x, final Dfp y)"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeExp(final Dfp a, final Dfp one)"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two)"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "public static synchronized RandomGenerator getRandomGenerator()"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> randomPermutation(final int l)"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> identityPermutation(final int l)"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator)"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "public static List<Integer> randomBinaryRepresentation(int length)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static double distance(Rotation r1, Rotation r2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "public static Euclidean3D getInstance()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double dotProduct(Vector3D v1, Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance1(Vector3D v1, Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceInf(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceSq(Vector3D v1, Vector3D v2)"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "public static Euclidean1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance(final Locale locale)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distance(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceInf(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceSq(Vector1D p1, Vector1D p2)"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distance(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceInf(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceSq(Vector2D p1, Vector2D p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "public static Euclidean2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static double distance(S1Point p1, S1Point p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "public static Sphere1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "public static Sphere2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "public static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static double distance(S2Point p1, S2Point p2)"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "public static Random createAdaptor(RandomGenerator randomGenerator)"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static RandomGenerator createRandomGenerator(final Random rng)"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static long convertToLong(int[] seed)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static String formatBigFraction(final BigFraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static Fraction getReducedFraction(int numerator, int denominator)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static BigFraction getReducedFraction(final int numerator, final int denominator)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static String formatFraction(Fraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "public static FractionField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "public static BigFractionField getInstance()"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "public static Object[] flatten(Object[] array)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[] scaleArray(double[] f, double d)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] scaleArray(Complex[] f, double d)"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[][] createRealImaginaryArray(final Complex[] dataC)"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static int exactLog2(final int n) throws MathIllegalArgumentException"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "static final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "public static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "public static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "public static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "public static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "protected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "static final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "static final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "static final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "static final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "0",
                "int"
            ],
            [
                "0.36",
                "double"
            ],
            [
                "0.48",
                "double"
            ],
            [
                "-0.48",
                "double"
            ],
            [
                "-0.64",
                "double"
            ],
            [
                "-0.36",
                "double"
            ],
            [
                "-0.48",
                "double"
            ],
            [
                "0.48",
                "double"
            ],
            [
                "0.64",
                "double"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "r1",
                "org.apache.commons.math3.geometry.euclidean.threed.FieldRotation",
                "FieldRotation<T>"
            ],
            [
                "r2",
                "org.apache.commons.math3.geometry.euclidean.threed.FieldRotation",
                "FieldRotation<T>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis(final RotationConvention convention)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u)"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ1()"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ3()"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> revert()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order) throws CardanEulerSingularityException"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final Rotation r)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final Rotation r)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final Vector3D u)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final FieldVector3D<T> u)"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ2()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final FieldRotation<T> r)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order, RotationConvention convention) throws CardanEulerSingularityException"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final FieldRotation<T> r)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final Vector3D u)"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ0()"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[][] getMatrix()"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getAngle()"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention)"
            ],
            [
                "toRotation",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public Rotation toRotation()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 23727,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.geometry.euclidean.threed",
        "className": "FieldRotation",
        "javadocTag": "@throws NotARotationMatrixException if the matrix is not a 3X3\nmatrix, or if it cannot be transformed into an orthogonal matrix\nwith the given threshold, or if the determinant of the resulting\northogonal matrix is negative",
        "methodJavadoc": "    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @throws NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */",
        "methodSourceCode": "public FieldRotation(final T[][] m, final double threshold) throws NotARotationMatrixException{\n    // dimension check\n    if ((m.length != 3) || (m[0].length != 3) || (m[1].length != 3) || (m[2].length != 3)) {\n        throw new NotARotationMatrixException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS, m.length, m[0].length);\n    }\n    // compute a \"close\" orthogonal matrix\n    final T[][] ort = orthogonalizeMatrix(m, threshold);\n    // check the sign of the determinant\n    final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n    final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n    final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n    final T det = ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n    if (det.getReal() < 0.0) {\n        throw new NotARotationMatrixException(LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);\n    }\n    final T[] quat = mat2quat(ort);\n    q0 = quat[0];\n    q1 = quat[1];\n    q2 = quat[2];\n    q3 = quat[3];\n}",
        "classJavadoc": "/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.RealFieldElement;\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathArrays;\n\n/**\n * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n * <p>Instance of this class are guaranteed to be immutable.</p>\n *\n * @param <T> the type of the field elements\n * @see FieldVector3D\n * @see RotationOrder\n * @since 3.2\n */\n\npublic class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = 20130224l;\n\n    /** Scalar coordinate of the quaternion. */\n    private final T q0;\n\n    /** First coordinate of the vectorial part of the quaternion. */\n    private final T q1;\n\n    /** Second coordinate of the vectorial part of the quaternion. */\n    private final T q2;\n\n    /** Third coordinate of the vectorial part of the quaternion. */\n    private final T q3;\n\n    /** Build a rotation from the quaternion coordinates.\n     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n     * the constructor can normalize it in a preprocessing step.</p>\n     * <p>Note that some conventions put the scalar part of the quaternion\n     * as the 4<sup>th</sup> component and the vector part as the first three\n     * components. This is <em>not</em> our convention. We put the scalar part\n     * as the first component.</p>\n     * @param q0 scalar part of the quaternion\n     * @param q1 first coordinate of the vectorial part of the quaternion\n     * @param q2 second coordinate of the vectorial part of the quaternion\n     * @param q3 third coordinate of the vectorial part of the quaternion\n     * @param needsNormalization if true, the coordinates are considered\n     * not to be normalized, a normalization preprocessing step is performed\n     * before using them\n     */\n    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n\n        if (needsNormalization) {\n            // normalization preprocessing\n            final T inv =\n                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n            this.q0 = inv.multiply(q0);\n            this.q1 = inv.multiply(q1);\n            this.q2 = inv.multiply(q2);\n            this.q3 = inv.multiply(q3);\n        } else {\n            this.q0 = q0;\n            this.q1 = q1;\n            this.q2 = q2;\n            this.q3 = q3;\n        }\n\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(FieldVector3D, RealFieldElement, RotationConvention)}\n     */\n    @Deprecated\n    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n        throws MathIllegalArgumentException {\n        this(axis, angle, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Build a rotation from an axis and an angle.\n     * <p>We use the convention that angles are oriented according to\n     * the effect of the rotation on vectors around the axis. That means\n     * that if (i, j, k) is a direct frame and if we first provide +k as\n     * the axis and &pi;/2 as the angle to this constructor, and then\n     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n     * +j.</p>\n     * <p>Another way to represent our convention is to say that a rotation\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\n     * rotation build from quaternion components { cos(-&theta;/2),\n     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n     * Note the minus sign on the angle!</p>\n     * <p>On the one hand this convention is consistent with a vectorial\n     * perspective (moving vectors in fixed frames), on the other hand it\n     * is different from conventions with a frame perspective (fixed vectors\n     * viewed from different frames) like the ones used for example in spacecraft\n     * attitude community or in the graphics community.</p>\n     * @param axis axis around which to rotate\n     * @param angle rotation angle.\n     * @param convention convention to use for the semantics of the angle\n     * @exception MathIllegalArgumentException if the axis norm is zero\n     * @since 3.6\n     */\n    public FieldRotation(final FieldVector3D<T> axis, final T angle, final RotationConvention convention)\n        throws MathIllegalArgumentException {\n\n        final T norm = axis.getNorm();\n        if (norm.getReal() == 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n        }\n\n        final T halfAngle = angle.multiply(convention == RotationConvention.VECTOR_OPERATOR ? -0.5 : 0.5);\n        final T coeff = halfAngle.sin().divide(norm);\n\n        q0 = halfAngle.cos();\n        q1 = coeff.multiply(axis.getX());\n        q2 = coeff.multiply(axis.getY());\n        q3 = coeff.multiply(axis.getZ());\n\n    }\n\n    /** Build a rotation from a 3X3 matrix.\n\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\n     * coefficients. The module of the determinant of unit matrices is\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\n     * positive determinant (+1) are rotation matrices.</p>\n\n     * <p>When a rotation is defined by a matrix with truncated values\n     * (typically when it is extracted from a technical sheet where only\n     * four to five significant digits are available), the matrix is not\n     * orthogonal anymore. This constructor handles this case\n     * transparently by using a copy of the given matrix and applying a\n     * correction to the copy in order to perfect its orthogonality. If\n     * the Frobenius norm of the correction needed is above the given\n     * threshold, then the matrix is considered to be too far from a\n     * true rotation matrix and an exception is thrown.<p>\n\n     * @param m rotation matrix\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n\n     * @exception NotARotationMatrixException if the matrix is not a 3X3\n     * matrix, or if it cannot be transformed into an orthogonal matrix\n     * with the given threshold, or if the determinant of the resulting\n     * orthogonal matrix is negative\n\n     */\n    public FieldRotation(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        // dimension check\n        if ((m.length != 3) || (m[0].length != 3) ||\n                (m[1].length != 3) || (m[2].length != 3)) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                  m.length, m[0].length);\n        }\n\n        // compute a \"close\" orthogonal matrix\n        final T[][] ort = orthogonalizeMatrix(m, threshold);\n\n        // check the sign of the determinant\n        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n        final T det =\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n        if (det.getReal() < 0.0) {\n            throw new NotARotationMatrixException(\n                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n                                                  det);\n        }\n\n        final T[] quat = mat2quat(ort);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build the rotation that transforms a pair of vectors into another pair.\n\n     * <p>Except for possible scale factors, if the instance were applied to\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n     * not the same as the angular separation between v<sub>1</sub> and\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>,\n     * +v<sub>2</sub>) half-plane.</p>\n\n     * @param u1 first vector of the origin pair\n     * @param u2 second vector of the origin pair\n     * @param v1 desired image of u1 by the rotation\n     * @param v2 desired image of u2 by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n     * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\n     */\n    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n        throws MathArithmeticException {\n\n        // build orthonormalized base from u1, u2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n        u1 = u1.normalize();\n\n        // build an orthonormalized base from v1, v2\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\n        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n        v1 = v1.normalize();\n\n        // buid a matrix transforming the first base into the second one\n        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n\n        T[] quat = mat2quat(array);\n        q0 = quat[0];\n        q1 = quat[1];\n        q2 = quat[2];\n        q3 = quat[3];\n\n    }\n\n    /** Build one of the rotations that transform one vector into another one.\n\n     * <p>Except for a possible scale factor, if the instance were\n     * applied to the vector u it will produce the vector v. There is an\n     * infinite number of such rotations, this constructor choose the\n     * one with the smallest associated angle (i.e. the one whose axis\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\n     * arbitrary rotation axis is chosen.</p>\n\n     * @param u origin vector\n     * @param v desired image of u by the rotation\n     * @exception MathArithmeticException if the norm of one of the vectors is zero\n     */\n    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n\n        final T normProduct = u.getNorm().multiply(v.getNorm());\n        if (normProduct.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n        }\n\n        final T dot = FieldVector3D.dotProduct(u, v);\n\n        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n            // special case u = -v: we select a PI angle rotation around\n            // an arbitrary vector orthogonal to u\n            final FieldVector3D<T> w = u.orthogonal();\n            q0 = normProduct.getField().getZero();\n            q1 = w.getX().negate();\n            q2 = w.getY().negate();\n            q3 = w.getZ().negate();\n        } else {\n            // general case: (u, v) defines a plane, we select\n            // the shortest possible rotation: axis orthogonal to this plane\n            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n            q1 = coeff.multiply(q.getX());\n            q2 = coeff.multiply(q.getY());\n            q3 = coeff.multiply(q.getZ());\n        }\n\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to use\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @deprecated as of 3.6, replaced with {@link\n     * #FieldRotation(RotationOrder, RotationConvention,\n     * RealFieldElement, RealFieldElement, RealFieldElement)}\n     */\n    @Deprecated\n    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n        this(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3);\n    }\n\n    /** Build a rotation from three Cardan or Euler elementary rotations.\n\n     * <p>Cardan rotations are three successive rotations around the\n     * canonical axes X, Y and Z, each axis being used once. There are\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n     * rotations are three successive rotations around the canonical\n     * axes X, Y and Z, the first and last rotations being around the\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n     * <p>Beware that many people routinely use the term Euler angles even\n     * for what really are Cardan angles (this confusion is especially\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n     * are often wrongly tagged as Euler angles).</p>\n\n     * @param order order of rotations to compose, from left to right\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\n     * @param convention convention to use for the semantics of the angle\n     * @param alpha1 angle of the first elementary rotation\n     * @param alpha2 angle of the second elementary rotation\n     * @param alpha3 angle of the third elementary rotation\n     * @since 3.6\n     */\n    public FieldRotation(final RotationOrder order, final RotationConvention convention,\n                         final T alpha1, final T alpha2, final T alpha3) {\n        final T one = alpha1.getField().getOne();\n        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1, convention);\n        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2, convention);\n        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3, convention);\n        final FieldRotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\n        q0 = composed.q0;\n        q1 = composed.q1;\n        q2 = composed.q2;\n        q3 = composed.q3;\n    }\n\n    /** Convert an orthogonal rotation matrix to a quaternion.\n     * @param ort orthogonal rotation matrix\n     * @return quaternion corresponding to the matrix\n     */\n    private T[] mat2quat(final T[][] ort) {\n\n        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n\n        // There are different ways to compute the quaternions elements\n        // from the matrix. They all involve computing one element from\n        // the diagonal of the matrix, and computing the three other ones\n        // using a formula involving a division by the first element,\n        // which unfortunately can be zero. Since the norm of the\n        // quaternion is 1, we know at least one element has an absolute\n        // value greater or equal to 0.5, so it is always possible to\n        // select the right formula and avoid division by zero and even\n        // numerical inaccuracy. Checking the elements in turn and using\n        // the first one greater than 0.45 is safe (this leads to a simple\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n        if (s.getReal() > -0.19) {\n            // compute q0 and deduce q1, q2 and q3\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n            T inv = quat[0].reciprocal().multiply(0.25);\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n        } else {\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n            if (s.getReal() > -0.19) {\n                // compute q1 and deduce q0, q2 and q3\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n                T inv = quat[1].reciprocal().multiply(0.25);\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n            } else {\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n                if (s.getReal() > -0.19) {\n                    // compute q2 and deduce q0, q1 and q3\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[2].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n                } else {\n                    // compute q3 and deduce q0, q1 and q2\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n                    T inv = quat[3].reciprocal().multiply(0.25);\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n                }\n            }\n        }\n\n        return quat;\n\n    }\n\n    /** Revert a rotation.\n     * Build a rotation which reverse the effect of another\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n     * instance is not changed.\n     * @return a new rotation whose effect is the reverse of the effect\n     * of the instance\n     */\n    public FieldRotation<T> revert() {\n        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n    }\n\n    /** Get the scalar coordinate of the quaternion.\n     * @return scalar coordinate of the quaternion\n     */\n    public T getQ0() {\n        return q0;\n    }\n\n    /** Get the first coordinate of the vectorial part of the quaternion.\n     * @return first coordinate of the vectorial part of the quaternion\n     */\n    public T getQ1() {\n        return q1;\n    }\n\n    /** Get the second coordinate of the vectorial part of the quaternion.\n     * @return second coordinate of the vectorial part of the quaternion\n     */\n    public T getQ2() {\n        return q2;\n    }\n\n    /** Get the third coordinate of the vectorial part of the quaternion.\n     * @return third coordinate of the vectorial part of the quaternion\n     */\n    public T getQ3() {\n        return q3;\n    }\n\n    /** Get the normalized axis of the rotation.\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @deprecated as of 3.6, replaced with {@link #getAxis(RotationConvention)}\n     */\n    @Deprecated\n    public FieldVector3D<T> getAxis() {\n        return getAxis(RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the normalized axis of the rotation.\n     * <p>\n     * Note that as {@link #getAngle()} always returns an angle\n     * between 0 and &pi;, changing the convention changes the\n     * direction of the axis, not the sign of the angle.\n     * </p>\n     * @param convention convention to use for the semantics of the angle\n     * @return normalized axis of the rotation\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     * @since 3.6\n     */\n    public FieldVector3D<T> getAxis(final RotationConvention convention) {\n        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n        if (squaredSine.getReal() == 0) {\n            final Field<T> field = squaredSine.getField();\n            return new FieldVector3D<T>(convention == RotationConvention.VECTOR_OPERATOR ? field.getOne(): field.getOne().negate(),\n                                        field.getZero(),\n                                        field.getZero());\n        } else {\n            final double sgn = convention == RotationConvention.VECTOR_OPERATOR ? +1 : -1;\n            if (q0.getReal() < 0) {\n                T inverse = squaredSine.sqrt().reciprocal().multiply(sgn);\n                return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n            }\n            final T inverse = squaredSine.sqrt().reciprocal().negate().multiply(sgn);\n            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n        }\n    }\n\n    /** Get the angle of the rotation.\n     * @return angle of the rotation (between 0 and &pi;)\n     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n     */\n    public T getAngle() {\n        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n        } else if (q0.getReal() < 0) {\n            return q0.negate().acos().multiply(2);\n        }\n        return q0.acos().multiply(2);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @deprecated as of 3.6, replaced with {@link #getAngles(RotationOrder, RotationConvention)}\n     */\n    @Deprecated\n    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n        return getAngles(order, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Get the Cardan or Euler angles corresponding to the instance.\n\n     * <p>The equations show that each rotation can be defined by two\n     * different values of the Cardan or Euler angles set. For example\n     * if Cardan angles are used, the rotation defined by the angles\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n     * the following arbitrary choices:</p>\n     * <ul>\n     *   <li>for Cardan angles, the chosen set is the one for which the\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n     *   positive),</li>\n     *   <li>for Euler angles, the chosen set is the one for which the\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n     * </ul>\n\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\n     * of them have singularities. This means that if the instance is\n     * too close to the singularities corresponding to the given\n     * rotation order, it will be impossible to retrieve the angles. For\n     * Cardan angles, this is often called gimbal lock. There is\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n     * with Cardan and Euler representation (but not a problem with the\n     * rotation itself, which is perfectly well defined). For Cardan\n     * angles, singularities occur when the second angle is close to\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n     * second angle is close to 0 or &pi;, this implies that the identity\n     * rotation is always singular for Euler angles!</p>\n\n     * @param order rotation order to use\n     * @param convention convention to use for the semantics of the angle\n     * @return an array of three angles, in the order specified by the set\n     * @exception CardanEulerSingularityException if the rotation is\n     * singular with respect to the angles set specified\n     * @since 3.6\n     */\n    public T[] getAngles(final RotationOrder order, RotationConvention convention)\n        throws CardanEulerSingularityException {\n\n        if (convention == RotationConvention.VECTOR_OPERATOR) {\n            if (order == RotationOrder.XYZ) {\n\n                // r (+K) coordinates are :\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (+I) coordinates are :\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n                final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                                  v2.getZ().asin(),\n                                  v2.getY().negate().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (+J) coordinates are :\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n                // (-r) (+I) coordinates are :\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getY().asin().negate(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (+K) coordinates are :\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getZ().asin().negate(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (+I) coordinates are :\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n                // (-r) (+J) coordinates are :\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                                  v2.getX().asin(),\n                                  v2.getZ().negate().atan2(v2.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (+J) coordinates are :\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getX().negate().atan2(v1.getY()),\n                                  v2.getY().asin(),\n                                  v2.getX().negate().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getX().asin().negate(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (+I) coordinates are :\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n                // (-r) (+I) coordinates are :\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v2.getY().atan2(v2.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (+I) coordinates are :\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n                // (-r) (+I) coordinates are :\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getY()),\n                                  v2.getX().acos(),\n                                  v2.getZ().atan2(v2.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (+J) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // (-r) (+J) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getZ()),\n                                  v2.getY().acos(),\n                                  v2.getX().atan2(v2.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (+J) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // (-r) (+J) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // and we can choose to have psi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                                  v2.getY().acos(),\n                                  v2.getZ().atan2(v2.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (+K) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // (-r) (+K) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getX().atan2(v1.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v2.getX().atan2(v2.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (+K) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // (-r) (+K) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n                final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v1.getY().atan2(v1.getX()),\n                                  v2.getZ().acos(),\n                                  v2.getY().atan2(v2.getX().negate()));\n\n            }\n        } else {\n            if (order == RotationOrder.XYZ) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().negate().atan2(v2.getZ()),\n                                  v2.getX().asin(),\n                                  v1.getY().negate().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.XZY) {\n\n                // r (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().asin().negate(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.YXZ) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().asin().negate(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.YZX) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getZ().negate().atan2(v2.getX()),\n                                  v2.getY().asin(),\n                                  v1.getZ().negate().atan2(v1.getY()));\n\n            } else if (order == RotationOrder.ZXY) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getX().negate().atan2(v2.getY()),\n                                  v2.getZ().asin(),\n                                  v1.getX().negate().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.ZYX) {\n\n                // r (Vector3D.plusK) coordinates are :\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(true);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().asin().negate(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XYX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getZ().negate()),\n                                  v2.getX().acos(),\n                                  v1.getY().atan2(v1.getZ()));\n\n            } else if (order == RotationOrder.XZX) {\n\n                // r (Vector3D.plusI) coordinates are :\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\n                // (-r) (Vector3D.plusI) coordinates are :\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_I);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_I);\n                if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getY()),\n                                  v2.getX().acos(),\n                                  v1.getZ().atan2(v1.getY().negate()));\n\n            } else if (order == RotationOrder.YXY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getZ()),\n                                  v2.getY().acos(),\n                                  v1.getX().atan2(v1.getZ().negate()));\n\n            } else if (order == RotationOrder.YZY) {\n\n                // r (Vector3D.plusJ) coordinates are :\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n                // (-r) (Vector3D.plusJ) coordinates are :\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n                // and we can choose to have psi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_J);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_J);\n                if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getZ().atan2(v2.getX().negate()),\n                                  v2.getY().acos(),\n                                  v1.getZ().atan2(v1.getX()));\n\n            } else if (order == RotationOrder.ZXZ) {\n\n                // r (Vector3D.plusK) coordinates are :\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n                // and we can choose to have phi in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getX().atan2(v2.getY().negate()),\n                                  v2.getZ().acos(),\n                                  v1.getX().atan2(v1.getY()));\n\n            } else { // last possibility is ZYZ\n\n                // r (Vector3D.plusK) coordinates are :\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n                // (-r) (Vector3D.plusK) coordinates are :\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n                // and we can choose to have theta in the interval [0 ; PI]\n                FieldVector3D<T> v1 = applyTo(Vector3D.PLUS_K);\n                FieldVector3D<T> v2 = applyInverseTo(Vector3D.PLUS_K);\n                if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                    throw new CardanEulerSingularityException(false);\n                }\n                return buildArray(v2.getY().atan2(v2.getX()),\n                                  v2.getZ().acos(),\n                                  v1.getY().atan2(v1.getX().negate()));\n\n            }\n        }\n\n    }\n\n    /** Create a dimension 3 array.\n     * @param a0 first array element\n     * @param a1 second array element\n     * @param a2 third array element\n     * @return new array\n     */\n    private T[] buildArray(final T a0, final T a1, final T a2) {\n        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n        array[0] = a0;\n        array[1] = a1;\n        array[2] = a2;\n        return array;\n    }\n\n    /** Create a constant vector.\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @return a constant vector\n     */\n    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n        final T zero = q0.getField().getZero();\n        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n    }\n\n    /** Get the 3X3 matrix corresponding to the instance\n     * @return the matrix corresponding to the instance\n     */\n    public T[][] getMatrix() {\n\n        // products\n        final T q0q0  = q0.multiply(q0);\n        final T q0q1  = q0.multiply(q1);\n        final T q0q2  = q0.multiply(q2);\n        final T q0q3  = q0.multiply(q3);\n        final T q1q1  = q1.multiply(q1);\n        final T q1q2  = q1.multiply(q2);\n        final T q1q3  = q1.multiply(q3);\n        final T q2q2  = q2.multiply(q2);\n        final T q2q3  = q2.multiply(q3);\n        final T q3q3  = q3.multiply(q3);\n\n        // create the matrix\n        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n\n        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n        m [2][0] = q1q3.add(q0q2).multiply(2);\n\n        m [0][1] = q1q2.add(q0q3).multiply(2);\n        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n\n        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n        m [1][2] = q2q3.add(q0q1).multiply(2);\n        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n\n        return m;\n\n    }\n\n    /** Convert to a constant vector without derivatives.\n     * @return a constant vector\n     */\n    public Rotation toRotation() {\n        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector.\n     * @param u vector to apply the rotation to\n     * @return a new vector which is the image of u by the rotation\n     */\n    public FieldVector3D<T> applyTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n\n        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which is the image of u by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n\n        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector.\n     * @param u vector to apply the inverse of the rotation to\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n\n        final double x = u.getX();\n        final double y = u.getY();\n        final double z = u.getZ();\n\n        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to (it can be the same\n     * array as in)\n     */\n    public void applyInverseTo(final T[] in, final T[] out) {\n\n        final T x = in[0];\n        final T y = in[1];\n        final T z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of the rotation to a vector stored in an array.\n     * @param in an array with three items which stores vector to rotate\n     * @param out an array with three items to put result to\n     */\n    public void applyInverseTo(final double[] in, final T[] out) {\n\n        final double x = in[0];\n        final double y = in[1];\n        final double z = in[2];\n\n        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n        final T m0 = q0.negate();\n\n        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n\n    }\n\n    /** Apply the inverse of a rotation to a vector.\n     * @param r rotation to apply\n     * @param u vector to apply the inverse of the rotation to\n     * @param <T> the type of the field elements\n     * @return a new vector which such that u is its image by the rotation\n     */\n    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n\n        final T x = u.getX();\n        final T y = u.getY();\n        final T z = u.getZ();\n\n        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n        final double m0 = -r.getQ0();\n\n        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(FieldRotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : r.composeInternal(this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n                                    false);\n    }\n\n    /** Apply the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #compose(Rotation, RotationConvention)\n     * compose(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> applyTo(final Rotation r) {\n        return compose(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the instance to a rotation is computing the composition\n     * in an order compliant with the following rule : let {@code u} be any\n     * vector and {@code v} its image by {@code r1} (i.e.\n     * {@code r1.applyTo(u) = v}). Let {@code w} be the image of {@code v} by\n     * rotation {@code r2} (i.e. {@code r2.applyTo(v) = w}). Then\n     * {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public FieldRotation<T> compose(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInternal(r) : applyTo(r, this);\n    }\n\n    /** Compose the instance with another rotation using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the instance\n     * using vector operator convention\n     */\n    private FieldRotation<T> composeInternal(final Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n                        q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n                        q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n                        false);\n    }\n\n    /** Apply a rotation to another rotation.\n     * Applying a rotation to another rotation is computing the composition\n     * in an order compliant with the following rule : let u be any\n     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n     * where comp = applyTo(rOuter, rInner).\n     * @param r1 rotation to apply\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(FieldRotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : r.composeInternal(revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(FieldRotation<T> r) {\n        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n                                    false);\n    }\n\n    /** Apply the inverse of the instance to another rotation.\n     * <p>\n     * Calling this method is equivalent to call\n     * {@link #composeInverse(Rotation, RotationConvention)\n     * composeInverse(r, RotationConvention.VECTOR_OPERATOR)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> applyInverseTo(final Rotation r) {\n        return composeInverse(r, RotationConvention.VECTOR_OPERATOR);\n    }\n\n    /** Compose the inverse of the instance with another rotation.\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#VECTOR_OPERATOR vector operator} convention,\n     * applying the inverse of the instance to a rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\n     * (i.e. {@code r1.applyTo(u) = v}). Let {@code w} be the inverse image\n     * of {@code v} by {@code r2} (i.e. {@code r2.applyInverseTo(v) = w}).\n     * Then {@code w = comp.applyTo(u)}, where\n     * {@code comp = r2.composeInverse(r1)}.\n     * </p>\n     * <p>\n     * If the semantics of the rotations composition corresponds to a\n     * {@link RotationConvention#FRAME_TRANSFORM frame transform} convention,\n     * the application order will be reversed, which means it is the\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\n     * and  {@code comp} as above, {@code comp} could also be computed as\n     * {@code comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM)}.\n     * </p>\n     * @param r rotation to apply the rotation to\n     * @param convention convention to use for the semantics of the angle\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention) {\n        return convention == RotationConvention.VECTOR_OPERATOR ?\n                             composeInverseInternal(r) : applyTo(r, revert());\n    }\n\n    /** Compose the inverse of the instance with another rotation\n     * using vector operator convention.\n     * @param r rotation to apply the rotation to\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance using vector operator convention\n     */\n    private FieldRotation<T> composeInverseInternal(Rotation r) {\n        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n                                    false);\n    }\n\n    /** Apply the inverse of a rotation to another rotation.\n     * Applying the inverse of a rotation to another rotation is computing\n     * the composition in an order compliant with the following rule :\n     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n     * let w be the inverse image of v by rOuter\n     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n     * comp = applyInverseTo(rOuter, rInner).\n     * @param rOuter rotation to apply the rotation to\n     * @param rInner rotation to apply the rotation to\n     * @param <T> the type of the field elements\n     * @return a new rotation which is the composition of r by the inverse\n     * of the instance\n     */\n    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n                                    false);\n    }\n\n    /** Perfect orthogonality on a 3X3 matrix.\n     * @param m initial matrix (not exactly orthogonal)\n     * @param threshold convergence threshold for the iterative\n     * orthogonality correction (convergence is reached when the\n     * difference between two steps of the Frobenius norm of the\n     * correction is below this threshold)\n     * @return an orthogonal matrix close to m\n     * @exception NotARotationMatrixException if the matrix cannot be\n     * orthogonalized with the given threshold after 10 iterations\n     */\n    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n        throws NotARotationMatrixException {\n\n        T x00 = m[0][0];\n        T x01 = m[0][1];\n        T x02 = m[0][2];\n        T x10 = m[1][0];\n        T x11 = m[1][1];\n        T x12 = m[1][2];\n        T x20 = m[2][0];\n        T x21 = m[2][1];\n        T x22 = m[2][2];\n        double fn = 0;\n        double fn1;\n\n        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n        int i = 0;\n        while (++i < 11) {\n\n            // Mt.Xn\n            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n\n            // Xn+1\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n\n            // correction on each elements\n            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n\n            // Frobenius norm of the correction\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n            // convergence test\n            if (FastMath.abs(fn1 - fn) <= threshold) {\n                return o;\n            }\n\n            // prepare next iteration\n            x00 = o[0][0];\n            x01 = o[0][1];\n            x02 = o[0][2];\n            x10 = o[1][0];\n            x11 = o[1][1];\n            x12 = o[1][2];\n            x20 = o[2][0];\n            x21 = o[2][1];\n            x22 = o[2][2];\n            fn  = fn1;\n\n        }\n\n        // the algorithm did not converge after 10 iterations\n        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n                                              i - 1);\n\n    }\n\n    /** Compute the <i>distance</i> between two rotations.\n     * <p>The <i>distance</i> is intended here as a way to check if two\n     * rotations are almost similar (i.e. they transform vectors the same way)\n     * or very different. It is mathematically defined as the angle of\n     * the rotation r that prepended to one of the rotations gives the other\n     * one:</p>\n     * <pre>\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\n     * </pre>\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n     * reached for some v. The distance is equal to 0 if and only if the two\n     * rotations are identical.</p>\n     * <p>Comparing two rotations should always be done using this value rather\n     * than for example comparing the components of the quaternions. It is much\n     * more stable, and has a geometric meaning. Also comparing quaternions\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n     * their components are different (they are exact opposites).</p>\n     * @param r1 first rotation\n     * @param r2 second rotation\n     * @param <T> the type of the field elements\n     * @return <i>distance</i> between r1 and r2\n     */\n    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n        return r1.composeInverseInternal(r2).getAngle();\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static boolean isPrime(int n)"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static int nextPrime(int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int smallTrialDivision(int n, final List<Integer> factors)"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors)"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static List<Integer> trialDivision(int n)"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static boolean millerRabinPrimeTest(final int n)"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "public static List<Integer> primeFactors(int n)"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int rhoBrent(final int n)"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "static int gcdPositive(int a, int b)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "public static GaussianCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "public static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations)"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights)"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights)"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter)"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker)"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "public static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian)"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "public static HarmonicCurveFitter create()"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "public static PolynomialCurveFitter create(int degree)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction compose(final UnivariateFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction add(final UnivariateFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction multiply(final UnivariateFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f)"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue)"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue)"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed)"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f)"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f)"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f)"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f)"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f)"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static double midpoint(double a, double b)"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "public static boolean isSequence(final double start, final double mid, final double end)"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "public static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createConstant(final double value)"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient createVariable(final int idx, final double value)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient hypot(final SparseGradient x, final SparseGradient y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient pow(final double a, final SparseGradient x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "public static SparseGradient atan2(final SparseGradient y, final SparseGradient x)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure pow(final double a, final DerivativeStructure x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "public static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "public static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createChebyshevPolynomial(final int degree)"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createHermitePolynomial(final int degree)"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLaguerrePolynomial(final int degree)"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createLegendrePolynomial(final int degree)"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w)"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "public static double[] shift(final double[] coefficients, final double shift)"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "protected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "protected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(double x, double y, double eps)"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "public static int compareTo(final double x, final double y, final int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(float x, float y, float eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, float eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final float x, final float y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(float x, float y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(double x, double y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsWithRelativeTolerance(double x, double y, double eps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, double eps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equals(final double x, final double y, final int maxUlps)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static boolean equalsIncludingNaN(double x, double y, int maxUlps)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double round(double x, int scale, int roundingMethod)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "public static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "public static double representableDelta(double x, double originalDelta)"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor wrap(final IntegerSequence.Incrementor incrementor)"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] scale(double val, final double[] arr)"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double cosAngle(double[] v1, double[] v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distance(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(double[] a, double[] b, boolean abort)"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkEqualLength(int[] a, int[] b, boolean abort)"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double safeNorm(double[] v)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] copyOf(int[] source, int len)"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOf(double[] source, int len)"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] copyOfRange(double[] source, int from, int to)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3)"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(float[] x, float[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(float[] x, float[] y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equals(double[] x, double[] y)"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean equalsIncludingNaN(double[] x, double[] y)"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] natural(int n)"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static int[] sequence(int size, int start, int stride)"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] concatenate(double[]... x)"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "public static double[] unique(double[] data)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "public static <K, V> Pair<K, V> create(K k, V v)"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowCos(final double x, final double[] result)"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowSin(final double x, final double[] result)"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double slowexp(final double x, final double[] result)"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double expint(int p, final double[] result)"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static double[] slowLog(double xi)"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "static String format(double d)"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sqrt(final double a)"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cosh(double x)"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sinh(double x)"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tanh(double x)"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acosh(final double a)"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asinh(double a)"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atanh(double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double signum(final double a)"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float signum(final float a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextUp(final double a)"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextUp(final float a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextDown(final double a)"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextDown(final float a)"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double random()"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double exp(double x)"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double expm1(double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(final double x)"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log1p(final double x)"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log10(final double x)"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double log(double base, double x)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(final double x, final double y)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, int e)"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double pow(double d, long e)"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double sin(double x)"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cos(double x)"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double tan(double x)"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan(double x)"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double atan2(double y, double x)"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double asin(double x)"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double acos(double x)"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double cbrt(double x)"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toRadians(double x)"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double toDegrees(double x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int abs(final int x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long abs(final long x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float abs(final float x)"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double abs(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ulp(double x)"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float ulp(float x)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double scalb(final double d, final int n)"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float scalb(final float f, final int n)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double nextAfter(double d, double direction)"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float nextAfter(final float f, final double direction)"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double floor(double x)"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double ceil(double x)"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double rint(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long round(double x)"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int round(final float x)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int min(final int a, final int b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long min(final long a, final long b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float min(final float a, final float b)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double min(final double a, final double b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int max(final int a, final int b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long max(final long a, final long b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float max(final float a, final float b)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double max(final double a, final double b)"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double hypot(final double x, final double y)"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double IEEEremainder(double dividend, double divisor)"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int toIntExact(final long n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int incrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long incrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int decrementExact(final int n) throws MathArithmeticException"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long decrementExact(final long n) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int addExact(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long addExact(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int subtractExact(final int a, final int b)"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long subtractExact(final long a, final long b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int multiplyExact(final int a, final int b)"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long multiplyExact(final long a, final long b)"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorDiv(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorDiv(final long a, final long b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int floorMod(final int a, final int b) throws MathArithmeticException"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static long floorMod(final long a, final long b)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static double copySign(double magnitude, double sign)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static float copySign(float magnitude, float sign)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final double d)"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static int getExponent(final float f)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "public static BigRealField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "public static final Decimal64Field getInstance()"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double value)"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static boolean equals(double x, double y)"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int hash(double[] value)"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double normalizeAngle(double a, double center)"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T max(final T e1, final T e2)"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static <T extends RealFieldElement<T>> T min(final T e1, final T e2)"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static double reduce(double a, double period, double offset)"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static byte copySign(byte magnitude, byte sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static short copySign(short magnitude, short sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static int copySign(int magnitude, int sign) throws MathArithmeticException"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static long copySign(long magnitude, long sign) throws MathArithmeticException"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos)"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos)"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(int start, int end)"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Range range(final int start, final int max, final int step)"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "public static Incrementor create()"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "public static Incrementor create()"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntA()"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpIntB()"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracA()"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[] loadExpFracB()"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "static double[][] loadLnMant()"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "public static Iterator<int[]> combinationsIterator(int n, int k)"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int addAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long addAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long factorial(final int n) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialDouble(final int n) throws NotPositiveException"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static double factorialLog(final int n) throws NotPositiveException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int gcd(int p, int q) throws MathArithmeticException"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long gcd(final long p, final long q) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int lcm(int a, int b) throws MathArithmeticException"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long lcm(long a, long b) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int mulAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long mulAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int subAndCheck(int x, int y) throws MathArithmeticException"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long subAndCheck(long a, long b) throws MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static int pow(final int k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long pow(final long k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "public static boolean isPowerOfTwo(long n)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(Locale locale)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "public static ComplexField getInstance()"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion multiply(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion add(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static Quaternion subtract(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static double dotProduct(final Quaternion q1, final Quaternion q2)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, int maxUlps)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y)"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equals(Complex x, Complex y, double eps)"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart, double imaginaryPart)"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static Complex valueOf(double realPart)"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "public static Complex[] convertToComplex(double[] real)"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "public static RealMatrixFormat getInstance(final Locale locale)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(final int rows, final int columns)"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealIdentityMatrix(int dimension)"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension)"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRealDiagonalMatrix(final double[] diagonal)"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal)"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static boolean isSymmetric(RealMatrix matrix, double eps)"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m)"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m)"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix blockInverse(RealMatrix m, int splitIndex)"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static double[][] createBlocksLayout(final int rows, final int columns)"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "public static RealVector unmodifiableRealVector(final RealVector v)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "public static RealVectorFormat getInstance(final Locale locale)"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "public static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns)"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length)"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "static double sample(RandomGenerator random, final double alpha, final double beta)"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getStirlingError(double z)"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double getDeviancePart(double x, double mu)"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "static double logBinomialProbability(int x, int n, double p, double q)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "static double helper2(final double x)"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper1(final double x)"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "static double helper2(final double x)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "public static MaxIter unlimited()"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "protected static double getInvertedCoefficientSum(final RealVector coefficients)"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "public static SimpleBounds unbounded(int dim)"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "public static MaxEval unlimited()"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x)"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfc(double x)"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erf(double x1, double x2)"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfInv(final double x)"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "public static double erfcInv(final double x)"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "public static BesselJResult rjBesl(double x, double alpha, int nb)"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma(double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x)"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(double a, double x)"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations)"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double digamma(double x)"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double trigamma(double x)"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double lanczos(final double x)"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double invGamma1pm1(final double x)"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static double gamma(final double x)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, double epsilon)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, double a, double b, int maxIterations)"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(double a, double b, double epsilon, int maxIterations)"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "public static double logBeta(final double p, final double q)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "public static DummyStepHandler getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "public static AdamsNordsieckTransformer getInstance(final int nSteps)"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "public static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps)"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double variance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values) throws MathIllegalArgumentException"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final double p) throws MathIllegalArgumentException"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] normalize(final double[] sample)"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample) throws MathIllegalArgumentException"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "public static double[] mode(double[] sample, final int begin, final int length)"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "public static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel)"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double exactP(double d, int m, int n, boolean strict)"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double approximateP(double d, int n, int m)"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "public static double monteCarloP(double d, int n, int m, boolean strict, int iterations)"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "public static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics)"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "public static PSquareMarkers newMarkers(final List<Double> initialFive, final double p)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "public static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall)"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "public static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall)"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance)"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance)"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "public static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max)"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer uniform(final double min, final double max)"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc)"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "public static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final DfpField field, final String a)"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] split(final Dfp a)"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b)"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp splitPow(final Dfp[] base, int a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp base, int a)"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp exp(final Dfp a)"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp expInternal(final Dfp a)"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp log(Dfp a)"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp[] logInternal(final Dfp[] a)"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp pow(Dfp x, final Dfp y)"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp sinInternal(Dfp[] a)"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp cosInternal(Dfp[] a)"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp sin(final Dfp a)"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp cos(Dfp a)"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp tan(final Dfp a)"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "protected static Dfp atanInternal(final Dfp a)"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp atan(final Dfp a)"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp asin(final Dfp a)"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "public static Dfp acos(Dfp a)"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static Dfp copysign(final Dfp x, final Dfp y)"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeExp(final Dfp a, final Dfp one)"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two)"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "public static synchronized RandomGenerator getRandomGenerator()"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> randomPermutation(final int l)"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static final List<Double> identityPermutation(final int l)"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator)"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "public static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "public static List<Integer> randomBinaryRepresentation(int length)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "public static Vector3DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static double distance(Rotation r1, Rotation r2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "public static Euclidean3D getInstance()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double dotProduct(Vector3D v1, Vector3D v2)"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance1(Vector3D v1, Vector3D v2)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distance(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceInf(Vector3D v1, Vector3D v2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static double distanceSq(Vector3D v1, Vector3D v2)"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "public static Euclidean1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "public static Vector1DFormat getInstance(final Locale locale)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distance(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceInf(Vector1D p1, Vector1D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static double distanceSq(Vector1D p1, Vector1D p2)"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "public static Collection<Vector2D> reducePoints(final Collection<Vector2D> points)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "public static Vector2DFormat getInstance(final Locale locale)"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distance(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceInf(Vector2D p1, Vector2D p2)"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static double distanceSq(Vector2D p1, Vector2D p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "public static Euclidean2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "public static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static double distance(S1Point p1, S1Point p2)"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "public static Sphere1D getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "public static Sphere2D getInstance()"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "public static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation)"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static double distance(S2Point p1, S2Point p2)"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "public static Random createAdaptor(RandomGenerator randomGenerator)"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static RandomGenerator createRandomGenerator(final Random rng)"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "public static long convertToLong(int[] seed)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static String formatBigFraction(final BigFraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "public static BigFractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static Fraction getReducedFraction(int numerator, int denominator)"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static BigFraction getReducedFraction(final int numerator, final int denominator)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static NumberFormat getDefaultNumberFormat(final Locale locale)"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "protected static char parseNextCharacter(final String source, final ParsePosition pos)"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static Locale[] getAvailableLocales()"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static String formatFraction(Fraction f)"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance()"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getImproperInstance(final Locale locale)"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance()"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "public static FractionFormat getProperInstance(final Locale locale)"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "protected static NumberFormat getDefaultNumberFormat()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "public static FractionField getInstance()"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "public static BigFractionField getInstance()"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "public static Object[] flatten(Object[] array)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[] scaleArray(double[] f, double d)"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] scaleArray(Complex[] f, double d)"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static double[][] createRealImaginaryArray(final Complex[] dataC)"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "public static int exactLog2(final int n) throws MathIllegalArgumentException"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "public static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "static final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "public static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "public static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "protected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "static final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "public static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "public static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "static final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "public static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "public static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "public static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "public static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "public static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "public static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "public static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "public static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "static final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "static final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "public static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "static final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "public static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "public static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "protected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "public static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "static final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "public static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "public static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "public static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "public static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "public static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "public static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "public static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "public static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "public static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "public static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "protected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "static final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "static final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "static final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "static final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "3",
                "int"
            ],
            [
                "3",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "3",
                "int"
            ],
            [
                "3",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "3",
                "int"
            ],
            [
                "3",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "m",
                "",
                "RealFieldElement[][]"
            ],
            [
                "threshold",
                "",
                "double"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final Vector3D u)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final Rotation r)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final Vector3D u)"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "revert",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> revert()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order, RotationConvention convention) throws CardanEulerSingularityException"
            ],
            [
                "getQ0",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ0()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final FieldRotation<T> r)"
            ],
            [
                "compose",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> compose(final FieldRotation<T> r, final RotationConvention convention)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toRotation",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public Rotation toRotation()"
            ],
            [
                "getAngles",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[] getAngles(final RotationOrder order) throws CardanEulerSingularityException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getQ2",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ2()"
            ],
            [
                "getAngle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getAngle()"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis(final RotationConvention convention)"
            ],
            [
                "getAxis",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> getAxis()"
            ],
            [
                "getMatrix",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T[][] getMatrix()"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyTo(final Rotation r)"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldVector3D<T> applyTo(final FieldVector3D<T> u)"
            ],
            [
                "getQ1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ1()"
            ],
            [
                "getQ3",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public T getQ3()"
            ],
            [
                "composeInverse",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> composeInverse(final Rotation r, final RotationConvention convention)"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "public FieldRotation<T> applyInverseTo(final FieldRotation<T> r)"
            ],
            [
                "equals",
                "",
                "T[][]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "T[][]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "T[][]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "T[][]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "T[][]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "length",
                "",
                "T[][]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]