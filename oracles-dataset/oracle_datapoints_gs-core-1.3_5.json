[
    {
        "id": 3098,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.ui.graphicGraph.stylesheet",
        "className": "Selector",
        "javadocTag": "@param identifier The element name.",
        "methodJavadoc": "    /**\n\t * New selector for a given type of element. This constructor allows to\n\t * specify either an identifier or a class to restrict this selector. If the\n\t * identifier is given, the class will never be used (as identifiers are\n\t * finer than classes). If the identifier is null the class will be used.\n\t * The identifier allow to select only one element by its name. The class\n\t * allows to select several elements.\n\t * \n\t * @param type\n\t *            The element type of this selector.\n\t * @param identifier\n\t *            The element name.\n\t * @param clazz\n\t *            The element class.\n\t */",
        "methodSourceCode": "public Selector(Type type, String identifier, String clazz){\n    this.type = type;\n    setId(identifier);\n    setClass(clazz);\n}",
        "classJavadoc": "/**\n * A selector is the part of a CSS rule that defines to which element a style\n * applies in the graph.\n * \n * @author Antoine Dutot\n * @author Yoann Pign\ufffd\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.ui.graphicGraph.stylesheet;\n\n/**\n * A selector is the part of a CSS rule that defines to which element a style\n * applies in the graph.\n * \n * @author Antoine Dutot\n * @author Yoann Pign\ufffd\n */\npublic class Selector {\n\t/**\n\t * Types of elements.\n\t */\n\tpublic static enum Type {\n\t\tANY, GRAPH, NODE, EDGE, SPRITE\n\t};\n\n\t/**\n\t * The kind of element this matcher applies to.\n\t */\n\tpublic Type type;\n\n\t/**\n\t * If the selector specify an identifier.\n\t */\n\tpublic String id;\n\n\t/**\n\t * If the selector specify a class.\n\t */\n\tpublic String clazz;\n\n\t/**\n\t * If the selector also specify a pseudo class.\n\t */\n\tpublic String pseudoClass;\n\n\t/**\n\t * New selector for a given type of element.\n\t * \n\t * @param type\n\t *            The element type of this selector.\n\t */\n\tpublic Selector(Type type) {\n\t\tthis.type = type;\n\t}\n\n\t/**\n\t * New selector for a given type of element. This constructor allows to\n\t * specify either an identifier or a class to restrict this selector. If the\n\t * identifier is given, the class will never be used (as identifiers are\n\t * finer than classes). If the identifier is null the class will be used.\n\t * The identifier allow to select only one element by its name. The class\n\t * allows to select several elements.\n\t * \n\t * @param type\n\t *            The element type of this selector.\n\t * @param identifier\n\t *            The element name.\n\t * @param clazz\n\t *            The element class.\n\t */\n\tpublic Selector(Type type, String identifier, String clazz) {\n\t\tthis.type = type;\n\t\tsetId(identifier);\n\t\tsetClass(clazz);\n\t}\n\n\t/**\n\t * Utility constructor that assign the correct type to the selector from a\n\t * string. The type must be \"node\", \"edge\", \"graph\", or \"sprite\".\n\t * \n\t * @param type\n\t *            Either \"node\", \"edge\", \"graph\" or \"sprite\".\n\t */\n\tpublic Selector(String type) {\n\t\tif (type.equals(\"node\"))\n\t\t\tthis.type = Type.NODE;\n\t\telse if (type.equals(\"edge\"))\n\t\t\tthis.type = Type.EDGE;\n\t\telse if (type.equals(\"graph\"))\n\t\t\tthis.type = Type.GRAPH;\n\t\telse if (type.equals(\"sprite\"))\n\t\t\tthis.type = Type.SPRITE;\n\t\telse\n\t\t\tthrow new RuntimeException(\"invalid matcher type '\" + type + \"'\");\n\t}\n\n\t/**\n\t * New selector, copy of another.\n\t * \n\t * @param other\n\t *            The other selector.\n\t */\n\tpublic Selector(Selector other) {\n\t\tthis.type = other.type;\n\t\tsetId(other.id);\n\t\tsetClass(other.clazz);\n\t}\n\n\t/**\n\t * Specify the identifier of the unique element this selector applies to.\n\t * \n\t * @param id\n\t *            A string that identifies an element of the graph.\n\t */\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t/**\n\t * Specify the class of the elements this selector applies to.\n\t * \n\t * @param clazz\n\t *            A string that matches all elements of a given class.\n\t */\n\tpublic void setClass(String clazz) {\n\t\tthis.clazz = clazz;\n\t}\n\n\t/**\n\t * Specify the pseudo-class of the elements this selector applies to.\n\t * \n\t * @param pseudoClass\n\t *            A string that matches all elements of a given pseudo-class.\n\t */\n\tpublic void setPseudoClass(String pseudoClass) {\n\t\tthis.pseudoClass = pseudoClass;\n\t}\n\n\t/**\n\t * The kind of elements this selector applies to.\n\t * \n\t * @return An element type.\n\t */\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\t/**\n\t * The identifier of the element this selector uniquely applies to. This can\n\t * be null if this selector is general.\n\t * \n\t * @return The identifier or null if the selector is general.\n\t */\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * The class of elements this selector applies to. This can be null if this\n\t * selector is general.\n\t * \n\t * @return A class name or null if the selector is general.\n\t */\n\tpublic String getClazz() {\n\t\treturn clazz;\n\t}\n\n\t/**\n\t * The pseudo-class of elements this selector applies to. This can be null.\n\t * \n\t * @return A pseudo-class name or null.\n\t */\n\tpublic String getPseudoClass() {\n\t\treturn pseudoClass;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"%s%s%s%s\", type.toString(),\n\t\t\t\tid != null ? String.format(\"#%s\", id) : \"\",\n\t\t\t\tclazz != null ? String.format(\".%s\", clazz) : \"\",\n\t\t\t\tpseudoClass != null ? String.format(\":%s\", pseudoClass) : \"\");\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "type",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector.Type"
            ],
            [
                "identifier",
                "java.lang",
                "String"
            ],
            [
                "clazz",
                "java.lang",
                "String"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClazz",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * The class of elements this selector applies to. This can be null if this\n * selector is general.\n *\n * @return A class name or null if the selector is general.\n */\npublic String getClazz() {\n    return clazz;\n}"
            ],
            [
                "getId",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * The identifier of the element this selector uniquely applies to. This can\n * be null if this selector is general.\n *\n * @return The identifier or null if the selector is general.\n */\npublic String getId() {\n    return id;\n}"
            ],
            [
                "getPseudoClass",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * The pseudo-class of elements this selector applies to. This can be null.\n *\n * @return A pseudo-class name or null.\n */\npublic String getPseudoClass() {\n    return pseudoClass;\n}"
            ],
            [
                "toString",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "@Override\npublic String toString() {\n    return String.format(\"%s%s%s%s\", type.toString(), id != null ? String.format(\"#%s\", id) : \"\", clazz != null ? String.format(\".%s\", clazz) : \"\", pseudoClass != null ? String.format(\":%s\", pseudoClass) : \"\");\n}"
            ],
            [
                "getType",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * The kind of elements this selector applies to.\n *\n * @return An element type.\n */\npublic Type getType() {\n    return type;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "clone",
                "java.lang",
                "Enum",
                "protected final Object clone() throws CloneNotSupportedException"
            ],
            [
                "name",
                "java.lang",
                "Enum",
                "public final String name()"
            ],
            [
                "ordinal",
                "java.lang",
                "Enum",
                "public final int ordinal()"
            ],
            [
                "toString",
                "java.lang",
                "Enum",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Enum",
                "public final boolean equals(Object arg0)"
            ],
            [
                "getDeclaringClass",
                "java.lang",
                "Enum",
                "public final Class<E> getDeclaringClass()"
            ],
            [
                "hashCode",
                "java.lang",
                "Enum",
                "public final int hashCode()"
            ],
            [
                "compareTo",
                "java.lang",
                "Enum",
                "public final int compareTo(E arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "Enum",
                "public final Optional<Enum.EnumDesc<E>> describeConstable()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "type",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * The kind of element this matcher applies to.\n */\npublic Type type;"
            ],
            [
                "id",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * If the selector specify an identifier.\n */\npublic String id;"
            ],
            [
                "clazz",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * If the selector specify a class.\n */\npublic String clazz;"
            ],
            [
                "pseudoClass",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Selector",
                "/**\n * If the selector also specify a pseudo class.\n */\npublic String pseudoClass;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3113,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.ui.graphicGraph",
        "className": "GraphicNode",
        "javadocTag": "@return The value.",
        "methodJavadoc": "    /**\n\t * Try to convert the object to a double.\n\t * \n\t * @param value\n\t *            The object to convert.\n\t * @return The value.\n\t */",
        "methodSourceCode": "protected double numberAttribute(Object value){\n    if (value instanceof Number) {\n        return ((Number) value).doubleValue();\n    } else if (value instanceof String) {\n        try {\n            return Double.parseDouble((String) value);\n        } catch (NumberFormatException e) {\n        }\n    } else if (value instanceof CharSequence) {\n        try {\n            return Double.parseDouble(((CharSequence) value).toString());\n        } catch (NumberFormatException e) {\n        }\n    }\n    return 0;\n}",
        "classJavadoc": "/**\n * Graphical node.\n * \n * <p>\n * A graphic node defines a position (x,y,z), a string label, and a style from\n * the style sheet.\n * </p>\n * \n * @see GraphicGraph\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.ui.graphicGraph;\n\nimport org.graphstream.graph.Edge;\nimport org.graphstream.graph.Graph;\nimport org.graphstream.graph.Node;\nimport org.graphstream.stream.SourceBase.ElementType;\nimport org.graphstream.ui.geom.Point3;\nimport org.graphstream.ui.graphicGraph.stylesheet.Selector;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static org.graphstream.ui.graphicGraph.GraphPosLengthUtils.nodePosition;\n\n/**\n * Graphical node.\n * \n * <p>\n * A graphic node defines a position (x,y,z), a string label, and a style from\n * the style sheet.\n * </p>\n * \n * @see GraphicGraph\n */\npublic class GraphicNode extends GraphicElement implements Node {\n\t/**\n\t * The position of the node. In graph units.\n\t */\n\tpublic double x, y, z;\n\n\tpublic boolean positionned = false;\n\n\t/**\n\t * New graphic node.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param attributes\n\t *            The node attribute set (can be null).\n\t */\n\tpublic GraphicNode(GraphicGraph graph, String id,\n\t\t\tHashMap<String, Object> attributes) {\n\t\tsuper(id, graph);\n\n\t\tif (attributes != null)\n\t\t\taddAttributes(attributes);\n\t}\n\n\t@Override\n\tpublic Selector.Type getSelectorType() {\n\t\treturn Selector.Type.NODE;\n\t}\n\n\t@Override\n\tpublic double getX() {\n\t\treturn x;\n\t}\n\n\t@Override\n\tpublic double getY() {\n\t\treturn y;\n\t}\n\n\t@Override\n\tpublic double getZ() {\n\t\treturn z;\n\t}\n\n\tprotected Point3 getPosition() {\n\t\treturn new Point3(x, y, z);\n\t}\n\n\tprotected void moveFromEvent(double x, double y, double z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\tif (!positionned) {\n\t\t\tpositionned = true;\n\t\t}\n\n\t\tmygraph.graphChanged = true;\n\t\tmygraph.boundsChanged = true;\n\t}\n\n\t@Override\n\tpublic void move(double x, double y, double z) {\n\t\tmoveFromEvent(x, y, z);\n\n\t\tif (mygraph.feedbackXYZ)\n\t\t\tsetAttribute(\"xyz\", x, y, z);\n\t}\n\n\t@Override\n\tprotected void attributeChanged(AttributeChangeEvent event,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsuper.attributeChanged(event, attribute, oldValue, newValue);\n\t\tchar c = attribute.charAt(0);\n\n\t\tif (attribute.length() > 2 && c == 'u' && attribute.charAt(1) == 'i'\n\t\t\t\t&& attribute.startsWith(\"ui.sprite.\")) {\n\t\t\tmygraph.spriteAttribute(event, this, attribute, newValue);\n\t\t} else if ((event == AttributeChangeEvent.ADD || event == AttributeChangeEvent.CHANGE)) {\n\t\t\tif (attribute.length() == 1) {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase 'x':\n\t\t\t\t\tmoveFromEvent(numberAttribute(newValue), y, z);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\tmoveFromEvent(x, numberAttribute(newValue), z);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\tmoveFromEvent(x, y, numberAttribute(newValue));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (c == 'x'\n\t\t\t\t\t&& attribute.length() > 1\n\t\t\t\t\t&& attribute.charAt(1) == 'y'\n\t\t\t\t\t&& (attribute.length() == 2 || (attribute.length() == 3 && attribute\n\t\t\t\t\t\t\t.charAt(2) == 'z'))) {\n\n\t\t\t\tdouble pos[] = nodePosition(this);\n\t\t\t\tmoveFromEvent(pos[0], pos[1], pos[2]);\n\t\t\t}\n\t\t}\n\n\t\tmygraph.listeners.sendAttributeChangedEvent(getId(), ElementType.NODE,\n\t\t\t\tattribute, event, oldValue, newValue);\n\t}\n\n\t/**\n\t * Try to convert the object to a double.\n\t * \n\t * @param value\n\t *            The object to convert.\n\t * @return The value.\n\t */\n\tprotected double numberAttribute(Object value) {\n\t\tif (value instanceof Number) {\n\t\t\treturn ((Number) value).doubleValue();\n\t\t} else if (value instanceof String) {\n\t\t\ttry {\n\t\t\t\treturn Double.parseDouble((String) value);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t}\n\t\t} else if (value instanceof CharSequence) {\n\t\t\ttry {\n\t\t\t\treturn Double.parseDouble(((CharSequence) value).toString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t@Override\n\tprotected void removed() {\n\t\t// NOP\n\t}\n\n\t// Node interface.\n\n\t/**\n\t * Not implemented.\n\t */\n\tpublic Iterator<Node> getBreadthFirstIterator() {\n\t\tthrow new RuntimeException(\"not implemented !\");\n\t}\n\n\t/**\n\t * Not implemented.\n\t */\n\tpublic Iterator<Node> getBreadthFirstIterator(boolean directed) {\n\t\tthrow new RuntimeException(\"not implemented !\");\n\t}\n\n\t/**\n\t * Not implemented.\n\t */\n\tpublic Iterator<Node> getDepthFirstIterator() {\n\t\tthrow new RuntimeException(\"not implemented !\");\n\t}\n\n\t/**\n\t * Not implemented.\n\t */\n\tpublic Iterator<Node> getDepthFirstIterator(boolean directed) {\n\t\tthrow new RuntimeException(\"not implemented !\");\n\t}\n\n\tpublic int getDegree() {\n        List<GraphicEdge> edges = mygraph.connectivity.get(this);\n\n\t\tif (edges != null)\n\t\t\treturn edges.size();\n\n\t\treturn 0;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Edge> T getEdge(int i) {\n        List<GraphicEdge> edges = mygraph.connectivity.get(this);\n\n\t\tif (edges != null && i >= 0 && i < edges.size())\n\t\t\treturn (T) edges.get(i);\n\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Edge> T getEdgeBetween(String id) {\n\t\tif (hasEdgeToward(id))\n\t\t\treturn (T) getEdgeToward(id);\n\t\telse\n\t\t\treturn (T) getEdgeFrom(id);\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> T getEdgeFrom(String id) {\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Edge> Iterator<T> getEdgeIterator() {\n        List<GraphicEdge> edges = mygraph.connectivity.get(this);\n\n\t\tif (edges != null)\n\t\t\treturn (Iterator<T>) edges.iterator();\n\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic Iterator<Edge> iterator() {\n\t\treturn (Iterator<Edge>) getEdgeIterator();\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Iterable<T> getEachEdge() {\n\t\treturn (Iterable<T>) mygraph.connectivity.get(this);\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Collection<T> getEdgeSet() {\n\t\treturn (Collection<T>) Collections\n\t\t\t\t.unmodifiableCollection(mygraph.connectivity.get(this));\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> T getEdgeToward(String id) {\n        List<? extends Edge> edges = mygraph.connectivity.get(this);\n\n\t\tfor (Edge edge : edges) {\n\t\t\tif (edge.getOpposite(this).getId().equals(id))\n\t\t\t\treturn (T) edge;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Iterator<T> getEnteringEdgeIterator() {\n\t\treturn getEdgeIterator();\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Iterable<T> getEachEnteringEdge() {\n\t\treturn getEdgeSet();\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Collection<T> getEnteringEdgeSet() {\n\t\treturn (Collection<T>) Collections.unmodifiableCollection(getEdgeSet());\n\t}\n\n\tpublic Graph getGraph() {\n\t\treturn mygraph;\n\t}\n\n\tpublic String getGraphName() {\n\t\tthrow new RuntimeException(\"impossible with GraphicGraph\");\n\t}\n\n\tpublic String getHost() {\n\t\tthrow new RuntimeException(\"impossible with GraphicGraph\");\n\t}\n\n\tpublic int getInDegree() {\n\t\treturn getDegree();\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Iterator<T> getLeavingEdgeIterator() {\n\t\treturn getEdgeIterator();\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Iterable<T> getEachLeavingEdge() {\n\t\treturn getEdgeSet();\n\t}\n\n\t@SuppressWarnings(\"all\")\n\tpublic <T extends Edge> Collection<T> getLeavingEdgeSet() {\n\t\treturn (Collection<T>) Collections.unmodifiableCollection(getEdgeSet());\n\t}\n\n\tpublic Iterator<Node> getNeighborNodeIterator() {\n\t\treturn null;\n\t}\n\n\tpublic int getOutDegree() {\n\t\treturn getDegree();\n\t}\n\n\tpublic boolean hasEdgeBetween(String id) {\n\t\treturn (hasEdgeToward(id) || hasEdgeFrom(id));\n\t}\n\n\tpublic boolean hasEdgeFrom(String id) {\n\t\treturn false;\n\t}\n\n\tpublic boolean hasEdgeToward(String id) {\n\t\treturn false;\n\t}\n\n\tpublic boolean isDistributed() {\n\t\treturn false;\n\t}\n\n\tpublic void setGraph(Graph graph) {\n\t\tthrow new RuntimeException(\"impossible with GraphicGraph\");\n\t}\n\n\tpublic void setGraphName(String newHost) {\n\t\tthrow new RuntimeException(\"impossible with GraphicGraph\");\n\t}\n\n\tpublic void setHost(String newHost) {\n\t\tthrow new RuntimeException(\"impossible with GraphicGraph\");\n\t}\n\n\t// XXX stubs for the new methods\n\n\tpublic <T extends Edge> T getEdgeBetween(Node Node) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\tpublic <T extends Edge> T getEdgeBetween(int index) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\tpublic <T extends Edge> T getEdgeFrom(Node Node) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\tpublic <T extends Edge> T getEdgeFrom(int index) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\tpublic <T extends Edge> T getEdgeToward(Node Node) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\tpublic <T extends Edge> T getEdgeToward(int index) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\tpublic boolean hasEdgeBetween(Node node) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic boolean hasEdgeBetween(int index) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic boolean hasEdgeFrom(Node node) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic boolean hasEdgeFrom(int index) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic boolean hasEdgeToward(Node node) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic boolean hasEdgeToward(int index) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\tpublic <T extends Edge> T getEnteringEdge(int i) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\tpublic <T extends Edge> T getLeavingEdge(int i) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "value",
                "java.lang",
                "Object"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getAttribute",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public <T> T getAttribute(String arg0, Class<T> arg1)"
            ],
            [
                "getY",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@Override\npublic double getY() {\n    return y;\n}"
            ],
            [
                "getEdgeIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"unchecked\")\npublic <T extends Edge> Iterator<T> getEdgeIterator() {\n    List<GraphicEdge> edges = mygraph.connectivity.get(this);\n    if (edges != null)\n        return (Iterator<T>) edges.iterator();\n    return null;\n}"
            ],
            [
                "getComponent",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public Object getComponent()"
            ],
            [
                "hasEdgeFrom",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeFrom(String id) {\n    return false;\n}"
            ],
            [
                "getEdgeSet",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Collection<T> getEdgeSet() {\n    return (Collection<T>) Collections.unmodifiableCollection(mygraph.connectivity.get(this));\n}"
            ],
            [
                "getEachEnteringEdge",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Iterable<T> getEachEnteringEdge() {\n    return getEdgeSet();\n}"
            ],
            [
                "hasNumber",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public boolean hasNumber(String arg0)"
            ],
            [
                "getGraph",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public Graph getGraph() {\n    return mygraph;\n}"
            ],
            [
                "hasEdgeFrom",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeFrom(int index) {\n    // TODO Auto-generated method stub\n    return false;\n}"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public transient <T> T getFirstAttributeOf(String[] arg0)"
            ],
            [
                "getEdgeFrom",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public <T extends Edge> T getEdgeFrom(Node Node) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "getEnteringEdgeIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Iterator<T> getEnteringEdgeIterator() {\n    return getEdgeIterator();\n}"
            ],
            [
                "getNeighborNodeIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public Iterator<Node> getNeighborNodeIterator() {\n    return null;\n}"
            ],
            [
                "getEachEdge",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Iterable<T> getEachEdge() {\n    return (Iterable<T>) mygraph.connectivity.get(this);\n}"
            ],
            [
                "getIndex",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public int getIndex()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "hasHash",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public boolean hasHash(String arg0)"
            ],
            [
                "getEachAttributeKey",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public Iterable<String> getEachAttributeKey()"
            ],
            [
                "getEdgeBetween",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public <T extends Edge> T getEdgeBetween(int index) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "getLeavingEdge",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public <T extends Edge> T getLeavingEdge(int i) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "getAttributeKeySet",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public Collection<String> getAttributeKeySet()"
            ],
            [
                "getSelectorType",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@Override\npublic Selector.Type getSelectorType() {\n    return Selector.Type.NODE;\n}"
            ],
            [
                "getEnteringEdge",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public <T extends Edge> T getEnteringEdge(int i) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "getBreadthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getBreadthFirstIterator()"
            ],
            [
                "getHost",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public String getHost() {\n    throw new RuntimeException(\"impossible with GraphicGraph\");\n}"
            ],
            [
                "iterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic Iterator<Edge> iterator() {\n    return (Iterator<Edge>) getEdgeIterator();\n}"
            ],
            [
                "myGraph",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public GraphicGraph myGraph()"
            ],
            [
                "getDepthFirstIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "/**\n * Not implemented.\n */\npublic Iterator<Node> getDepthFirstIterator(boolean directed) {\n    throw new RuntimeException(\"not implemented !\");\n}"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)"
            ],
            [
                "hasEdgeBetween",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeBetween(int index) {\n    // TODO Auto-generated method stub\n    return false;\n}"
            ],
            [
                "isDistributed",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean isDistributed() {\n    return false;\n}"
            ],
            [
                "getVector",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public ArrayList<? extends Number> getVector(String arg0)"
            ],
            [
                "getStyle",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public StyleGroup getStyle()"
            ],
            [
                "hasLabel",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public boolean hasLabel(String arg0)"
            ],
            [
                "getEdgeToward",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public <T extends Edge> T getEdgeToward(Node Node) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "getOutDegree",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public int getOutDegree() {\n    return getDegree();\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract CharSequence getLabel(String arg0)"
            ],
            [
                "getEdgeToward",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> T getEdgeToward(String id) {\n    List<? extends Edge> edges = mygraph.connectivity.get(this);\n    for (Edge edge : edges) {\n        if (edge.getOpposite(this).getId().equals(id))\n            return (T) edge;\n    }\n    return null;\n}"
            ],
            [
                "getId",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public String getId()"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public boolean hasAttribute(String arg0, Class<?> arg1)"
            ],
            [
                "getGraphName",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public String getGraphName() {\n    throw new RuntimeException(\"impossible with GraphicGraph\");\n}"
            ],
            [
                "getInDegree",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public int getInDegree() {\n    return getDegree();\n}"
            ],
            [
                "getEdgeBetween",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"unchecked\")\npublic <T extends Edge> T getEdgeBetween(String id) {\n    if (hasEdgeToward(id))\n        return (T) getEdgeToward(id);\n    else\n        return (T) getEdgeFrom(id);\n}"
            ],
            [
                "getDegree",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public int getDegree() {\n    List<GraphicEdge> edges = mygraph.connectivity.get(this);\n    if (edges != null)\n        return edges.size();\n    return 0;\n}"
            ],
            [
                "getArray",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public Object[] getArray(String arg0)"
            ],
            [
                "hasArray",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public boolean hasArray(String arg0)"
            ],
            [
                "getEdgeFrom",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> T getEdgeFrom(String id) {\n    return null;\n}"
            ],
            [
                "getAttributeCount",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public int getAttributeCount()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public <T> T getAttribute(String arg0)"
            ],
            [
                "getEdgeBetween",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "// XXX stubs for the new methods\npublic <T extends Edge> T getEdgeBetween(Node Node) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "getLeavingEdgeSet",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Collection<T> getLeavingEdgeSet() {\n    return (Collection<T>) Collections.unmodifiableCollection(getEdgeSet());\n}"
            ],
            [
                "getLeavingEdgeIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Iterator<T> getLeavingEdgeIterator() {\n    return getEdgeIterator();\n}"
            ],
            [
                "getHash",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public HashMap<?, ?> getHash(String arg0)"
            ],
            [
                "hasVector",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public boolean hasVector(String arg0)"
            ],
            [
                "numberAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "/**\n * Try to convert the object to a double.\n *\n * @param value\n *            The object to convert.\n * @return The value.\n */\nprotected double numberAttribute(Object value) {\n    if (value instanceof Number) {\n        return ((Number) value).doubleValue();\n    } else if (value instanceof String) {\n        try {\n            return Double.parseDouble((String) value);\n        } catch (NumberFormatException e) {\n        }\n    } else if (value instanceof CharSequence) {\n        try {\n            return Double.parseDouble(((CharSequence) value).toString());\n        } catch (NumberFormatException e) {\n        }\n    }\n    return 0;\n}"
            ],
            [
                "getBreadthFirstIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "// Node interface.\n/**\n * Not implemented.\n */\npublic Iterator<Node> getBreadthFirstIterator() {\n    throw new RuntimeException(\"not implemented !\");\n}"
            ],
            [
                "getDepthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)"
            ],
            [
                "hasEdgeToward",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeToward(String id) {\n    return false;\n}"
            ],
            [
                "getZ",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@Override\npublic double getZ() {\n    return z;\n}"
            ],
            [
                "nullAttributesAreErrors",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "protected boolean nullAttributesAreErrors()"
            ],
            [
                "getAttributeKeyIterator",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public Iterator<String> getAttributeKeyIterator()"
            ],
            [
                "getEnteringEdgeSet",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Collection<T> getEnteringEdgeSet() {\n    return (Collection<T>) Collections.unmodifiableCollection(getEdgeSet());\n}"
            ],
            [
                "getLabel",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public String getLabel(String arg0)"
            ],
            [
                "getPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "protected Point3 getPosition() {\n    return new Point3(x, y, z);\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public String toString()"
            ],
            [
                "getDepthFirstIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "/**\n * Not implemented.\n */\npublic Iterator<Node> getDepthFirstIterator() {\n    throw new RuntimeException(\"not implemented !\");\n}"
            ],
            [
                "hasEdgeToward",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeToward(Node node) {\n    // TODO Auto-generated method stub\n    return false;\n}"
            ],
            [
                "getDepthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getDepthFirstIterator()"
            ],
            [
                "getEdge",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"unchecked\")\npublic <T extends Edge> T getEdge(int i) {\n    List<GraphicEdge> edges = mygraph.connectivity.get(this);\n    if (edges != null && i >= 0 && i < edges.size())\n        return (T) edges.get(i);\n    return null;\n}"
            ],
            [
                "getEachLeavingEdge",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@SuppressWarnings(\"all\")\npublic <T extends Edge> Iterable<T> getEachLeavingEdge() {\n    return getEdgeSet();\n}"
            ],
            [
                "getBreadthFirstIterator",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "/**\n * Not implemented.\n */\npublic Iterator<Node> getBreadthFirstIterator(boolean directed) {\n    throw new RuntimeException(\"not implemented !\");\n}"
            ],
            [
                "getEdgeToward",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public <T extends Edge> T getEdgeToward(int index) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "getX",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "@Override\npublic double getX() {\n    return x;\n}"
            ],
            [
                "hasEdgeBetween",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeBetween(Node node) {\n    // TODO Auto-generated method stub\n    return false;\n}"
            ],
            [
                "getNumber",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public double getNumber(String arg0)"
            ],
            [
                "hasEdgeToward",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeToward(int index) {\n    // TODO Auto-generated method stub\n    return false;\n}"
            ],
            [
                "getLabel",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public String getLabel()"
            ],
            [
                "hasEdgeBetween",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeBetween(String id) {\n    return (hasEdgeToward(id) || hasEdgeFrom(id));\n}"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "getNeighborNodeIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getNeighborNodeIterator()"
            ],
            [
                "getEdgeFrom",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public <T extends Edge> T getEdgeFrom(int index) {\n    // TODO Auto-generated method stub\n    return null;\n}"
            ],
            [
                "hasEdgeFrom",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean hasEdgeFrom(Node node) {\n    // TODO Auto-generated method stub\n    return false;\n}"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "public boolean hasAttribute(String arg0)"
            ],
            [
                "getBreadthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "x",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "/**\n * The position of the node. In graph units.\n */\npublic double x, y, z;"
            ],
            [
                "y",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "/**\n * The position of the node. In graph units.\n */\npublic double x, y, z;"
            ],
            [
                "z",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "/**\n * The position of the node. In graph units.\n */\npublic double x, y, z;"
            ],
            [
                "positionned",
                "org.graphstream.ui.graphicGraph",
                "GraphicNode",
                "public boolean positionned = false;"
            ],
            [
                "mygraph",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "protected GraphicGraph mygraph;"
            ],
            [
                "label",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public String label;"
            ],
            [
                "style",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public StyleGroup style;"
            ],
            [
                "component",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public Object component;"
            ],
            [
                "hidden",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "public boolean hidden;"
            ],
            [
                "id",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "protected String id;"
            ],
            [
                "attributes",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "protected HashMap<String, Object> attributes;"
            ],
            [
                "attributesBeingRemoved",
                "org.graphstream.graph.implementations",
                "AbstractElement",
                "protected ArrayList<String> attributesBeingRemoved;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3145,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.ui.graphicGraph",
        "className": "StyleGroup",
        "javadocTag": "@param element The element.",
        "methodJavadoc": "    /**\n\t * Pop an event for the given element. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element.\n\t * @param event\n\t *            The event.\n\t */",
        "methodSourceCode": "protected void popEventFor(Element element, String event){\n    if (elements.containsKey(element.getId())) {\n        ElementEvents evs = eventsFor.get(element);\n        if (evs != null) {\n            evs.popEvent(event);\n            if (evs.eventCount() == 0)\n                eventsFor.remove(element);\n        }\n        if (eventsFor.isEmpty())\n            eventsFor = null;\n    }\n}",
        "classJavadoc": "/**\n * A group of graph elements that share the same style.\n * \n * <p>\n * The purpose of a style group is to allow retrieving all elements with the\n * same style easily. Most of the time, with graphic engines, pushing the\n * graphic state (the style, colors, line width, textures, gradients) is a\n * costly operation. Doing it once for several elements can speed up things a\n * lot. This is the purpose of the style group.\n * </p>\n * \n * <p>\n * The action of drawing elements in group (first push style, then draw all\n * elements) are called bulk drawing. All elements that can be drawn at once\n * this way are called bulk elements.\n * </p>\n * \n * <p>\n * In a style group it is not always possible do draw elements in a such a\n * \"bulk\" operation. If the style contains \"dynamic values\" for example, that is\n * value that depend on the value of an attribute stored on the element, or if\n * the element is modified by an event (clicked, selected), the element will not\n * be drawn the same as others.\n * </p>\n * \n * <p>\n * The style group provides iterators on each of these categories of elements :\n * <ul>\n * <li>{@link #elements()} allows to browse all elements contained in the group\n * without exception.</li>\n * <li>{@link #dynamicElements()} allows to browse the subset of elements having\n * a attribute that modify their style.</li>\n * <li>{@link #elementsEvents()} allows to browse the subset of elements\n * modified by an event.</li>\n * <li>{@link #bulkElements()} allows to browse all remaining elements that have\n * no dynamic attribute or event.</li>\n * </ul>\n * The calling the three last iterators would yield the same elements as calling\n * the first one. When drawing you can optimise the drawing by first pushing the\n * graphic state and then drawing at once all bulk elements. If the dynamic and\n * event subsets are not empty you then must draw such elements modifying the\n * graphic state for each one.\n * </p>\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.ui.graphicGraph;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.graphstream.graph.Element;\nimport org.graphstream.ui.graphicGraph.GraphicElement.SwingElementRenderer;\nimport org.graphstream.ui.graphicGraph.stylesheet.Rule;\nimport org.graphstream.ui.graphicGraph.stylesheet.Selector;\nimport org.graphstream.ui.graphicGraph.stylesheet.Style;\n\n/**\n * A group of graph elements that share the same style.\n * \n * <p>\n * The purpose of a style group is to allow retrieving all elements with the\n * same style easily. Most of the time, with graphic engines, pushing the\n * graphic state (the style, colors, line width, textures, gradients) is a\n * costly operation. Doing it once for several elements can speed up things a\n * lot. This is the purpose of the style group.\n * </p>\n * \n * <p>\n * The action of drawing elements in group (first push style, then draw all\n * elements) are called bulk drawing. All elements that can be drawn at once\n * this way are called bulk elements.\n * </p>\n * \n * <p>\n * In a style group it is not always possible do draw elements in a such a\n * \"bulk\" operation. If the style contains \"dynamic values\" for example, that is\n * value that depend on the value of an attribute stored on the element, or if\n * the element is modified by an event (clicked, selected), the element will not\n * be drawn the same as others.\n * </p>\n * \n * <p>\n * The style group provides iterators on each of these categories of elements :\n * <ul>\n * <li>{@link #elements()} allows to browse all elements contained in the group\n * without exception.</li>\n * <li>{@link #dynamicElements()} allows to browse the subset of elements having\n * a attribute that modify their style.</li>\n * <li>{@link #elementsEvents()} allows to browse the subset of elements\n * modified by an event.</li>\n * <li>{@link #bulkElements()} allows to browse all remaining elements that have\n * no dynamic attribute or event.</li>\n * </ul>\n * The calling the three last iterators would yield the same elements as calling\n * the first one. When drawing you can optimise the drawing by first pushing the\n * graphic state and then drawing at once all bulk elements. If the dynamic and\n * event subsets are not empty you then must draw such elements modifying the\n * graphic state for each one.\n * </p>\n */\npublic class StyleGroup extends Style implements Iterable<Element> {\n\t// Attribute\n\n\t/**\n\t * The group unique identifier.\n\t */\n\tprotected String id;\n\n\t/**\n\t * The set of style rules.\n\t */\n\tprotected ArrayList<Rule> rules = new ArrayList<Rule>();\n\n\t/**\n\t * Graph elements of this group.\n\t */\n\tprotected HashMap<String, Element> elements = new HashMap<String, Element>();\n\n\t/**\n\t * The global events actually occurring.\n\t */\n\tprotected StyleGroupSet.EventSet eventSet;\n\n\t/**\n\t * Set of elements whose style is actually modified individually by an\n\t * event. Such elements must be rendered one by one, not in groups like\n\t * others.\n\t */\n\tprotected HashMap<Element, ElementEvents> eventsFor;\n\n\t/**\n\t * Set of elements that have some dynamic style values. Such elements must\n\t * be rendered one by one, not in groups, like others.\n\t */\n\tprotected HashSet<Element> dynamicOnes;\n\n\t/**\n\t * A set of events actually pushed only for this group.\n\t */\n\tprotected String[] curEvents;\n\n\t/**\n\t * The set of bulk elements.\n\t */\n\tprotected BulkElements bulkElements = new BulkElements();\n\n\t/**\n\t * Associated renderers.\n\t */\n\tpublic HashMap<String, SwingElementRenderer> renderers;\n\n\t// Construction\n\n\t/**\n\t * New style group for a first graph element and the set of style rules that\n\t * matches it. More graph elements can be added later.\n\t * \n\t * @param identifier\n\t *            The unique group identifier (see\n\t *            {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getStyleGroupIdFor(Element, ArrayList)}\n\t *            ).\n\t * @param rules\n\t *            The set of style rules for the style group (see\n\t *            {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getRulesFor(Element)}\n\t *            ).\n\t * @param firstElement\n\t *            The first element to construct the group.\n\t */\n\tpublic StyleGroup(String identifier, Collection<Rule> rules,\n\t\t\tElement firstElement, StyleGroupSet.EventSet eventSet) {\n\t\tthis.id = identifier;\n\t\tthis.rules.addAll(rules);\n\t\tthis.elements.put(firstElement.getId(), firstElement);\n\t\tthis.values = null; // To avoid consume memory since this style will not\n\t\t\t\t\t\t\t// store anything.\n\t\tthis.eventSet = eventSet;\n\n\t\tfor (Rule rule : rules)\n\t\t\trule.addGroup(identifier);\n\t}\n\n\t// Access\n\n\t/**\n\t * The group unique identifier.\n\t * \n\t * @return A style group identifier.\n\t */\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * Type of graph element concerned by this style (node, edge, sprite,\n\t * graph).\n\t * \n\t * @return The type of the style group elements.\n\t */\n\tpublic Selector.Type getType() {\n\t\treturn rules.get(0).selector.type;\n\t}\n\n\t/**\n\t * True if at least one of the style properties is dynamic (set according to\n\t * an attribute of the element to draw). Such elements cannot therefore be\n\t * drawn in a group operation, but one by one.\n\t * \n\t * @return True if one property is dynamic.\n\t */\n\tpublic boolean hasDynamicElements() {\n\t\treturn (dynamicOnes != null && dynamicOnes.size() > 0);\n\t}\n\n\t/**\n\t * If true this group contains some elements that are actually changed by an\n\t * event. Such elements cannot therefore be drawn in a group operation, but\n\t * one by one.\n\t * \n\t * @return True if the group contains some elements changed by an event.\n\t */\n\tpublic boolean hasEventElements() {\n\t\treturn (eventsFor != null && eventsFor.size() > 0);\n\t}\n\n\t/**\n\t * True if the given element actually has active events.\n\t * \n\t * @param element\n\t *            The element to test.\n\t * @return True if the element has actually active events.\n\t */\n\tpublic boolean elementHasEvents(Element element) {\n\t\treturn (eventsFor != null && eventsFor.containsKey(element));\n\t}\n\n\t/**\n\t * True if the given element has dynamic style values provided by specific\n\t * attributes.\n\t * \n\t * @param element\n\t *            The element to test.\n\t * @return True if the element has actually specific style attributes.\n\t */\n\tpublic boolean elementIsDynamic(Element element) {\n\t\treturn (dynamicOnes != null && dynamicOnes.contains(element));\n\t}\n\n\t/**\n\t * Get the value of a given property.\n\t * \n\t * This is a redefinition of the method in {@link Style} to consider the\n\t * fact a style group aggregates several style rules.\n\t * \n\t * @param property\n\t *            The style property the value is searched for.\n\t */\n\t@Override\n\tpublic Object getValue(String property, String... events) {\n\t\tint n = rules.size();\n\n\t\tif (events == null || events.length == 0) {\n\t\t\tif (curEvents != null && curEvents.length > 0) {\n\t\t\t\tevents = curEvents;\n\t\t\t} else if (eventSet.events != null && eventSet.events.length > 0) {\n\t\t\t\tevents = eventSet.events;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tStyle style = rules.get(i).getStyle();\n\n\t\t\tif (style.hasValue(property, events))\n\t\t\t\treturn style.getValue(property, events);\n\t\t}\n\n\t\treturn rules.get(0).getStyle().getValue(property, events);\n\t}\n\n\t/**\n\t * True if there are no elements in the group.\n\t * \n\t * @return True if the group is empty of elements.\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn elements.isEmpty();\n\t}\n\n\t/**\n\t * True if the group contains the element whose identifier is given.\n\t * \n\t * @param elementId\n\t *            The element to search.\n\t * @return true if the element is in the group.\n\t */\n\tpublic boolean contains(String elementId) {\n\t\treturn elements.containsKey(elementId);\n\t}\n\n\t/**\n\t * True if the group contains the element given.\n\t * \n\t * @param element\n\t *            The element to search.\n\t * @return true if the element is in the group.\n\t */\n\tpublic boolean contains(Element element) {\n\t\treturn elements.containsKey(element.getId());\n\t}\n\n\t/**\n\t * Return an element of the group, knowing its identifier.\n\t * \n\t * @param id\n\t *            The searched element identifier.\n\t * @return The element corresponding to the identifier or null if not found.\n\t */\n\tpublic Element getElement(String id) {\n\t\treturn elements.get(id);\n\t}\n\n\t/**\n\t * The number of elements of the group.\n\t * \n\t * @return The element count.\n\t */\n\tpublic int getElementCount() {\n\t\treturn elements.size();\n\t}\n\n\t/**\n\t * Iterator on the set of graph elements of this group.\n\t * \n\t * @return The elements iterator.\n\t */\n\tpublic Iterator<? extends Element> getElementIterator() {\n\t\treturn elements.values().iterator();\n\t}\n\n\t/**\n\t * Iterable set of elements. This the complete set of elements contained in\n\t * this group without regard to the fact they are modified by an event or\n\t * are dynamic. If you plan to respect events or dynamic elements, you must\n\t * check the elements are not modified by events using\n\t * {@link #elementHasEvents(Element)} and are not dynamic by using\n\t * {@link #elementIsDynamic(Element)} and then draw modified elements using\n\t * {@link #elementsEvents()} and {@link #dynamicElements()}. But the easiest\n\t * way of drawing is to use first {@link #bulkElements()} for all non\n\t * dynamic non event elements, then the {@link #dynamicElements()} and\n\t * {@link #elementsEvents()} to draw all dynamic and event elements.\n\t * \n\t * @return All the elements in no particular order.\n\t */\n\tpublic Iterable<? extends Element> elements() {\n\t\treturn elements.values();\n\t}\n\n\t/**\n\t * Iterable set of elements that can be drawn in a bulk operation, that is\n\t * the subset of all elements that are not dynamic or modified by an event.\n\t * \n\t * @return The iterable set of bulk elements.\n\t */\n\tpublic Iterable<? extends Element> bulkElements() {\n\t\treturn bulkElements;\n\t}\n\n\t/**\n\t * Subset of elements that are actually modified by one or more events. The\n\t * {@link ElementEvents} class contains the element and an array of events\n\t * that can be pushed on the style group set.\n\t * \n\t * @return The subset of elements modified by one or more events.\n\t */\n\tpublic Iterable<ElementEvents> elementsEvents() {\n\t\treturn eventsFor.values();\n\t}\n\n\t/**\n\t * Subset of elements that have dynamic style values and therefore must be\n\t * rendered one by one, not in groups like others. Even though elements\n\t * style can specify some dynamics, the elements must individually have\n\t * attributes that specify the dynamic value. If the elements do not have\n\t * these attributes they can be rendered in bulk operations.\n\t * \n\t * @return The subset of dynamic elements of the group.\n\t */\n\tpublic Iterable<Element> dynamicElements() {\n\t\treturn dynamicOnes;\n\t}\n\n\tpublic Iterator<Element> iterator() {\n\t\treturn elements.values().iterator();\n\t}\n\n\t/**\n\t * The associated renderers.\n\t * \n\t * @return A renderer or null if not found.\n\t */\n\tpublic SwingElementRenderer getRenderer(String id) {\n\t\tif (renderers != null)\n\t\t\treturn renderers.get(id);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set of events for a given element or null if the element has not\n\t * currently occurring events.\n\t * \n\t * @return A set of events or null if none occurring at that time.\n\t */\n\tpublic ElementEvents getEventsFor(Element element) {\n\t\tif (eventsFor != null)\n\t\t\treturn eventsFor.get(element);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Test if an element is pushed as dynamic.\n\t */\n\tpublic boolean isElementDynamic(Element element) {\n\t\tif (dynamicOnes != null)\n\t\t\treturn dynamicOnes.contains(element);\n\n\t\treturn false;\n\t}\n\n\t// Command\n\n\t/**\n\t * Add a new graph element to the group.\n\t * \n\t * @param element\n\t *            The new graph element to add.\n\t */\n\tpublic void addElement(Element element) {\n\t\telements.put(element.getId(), element);\n\t}\n\n\t/**\n\t * Remove a graph element from the group.\n\t * \n\t * @param element\n\t *            The element to remove.\n\t * @return The removed element, or null if the element was not found.\n\t */\n\tpublic Element removeElement(Element element) {\n\t\tif (eventsFor != null && eventsFor.containsKey(element))\n\t\t\teventsFor.remove(element); // Remove an eventual remaining event.\n\n\t\tif (dynamicOnes != null && dynamicOnes.contains(element))\n\t\t\tdynamicOnes.remove(element); // Remove an eventual remaining dynamic\n\t\t\t\t\t\t\t\t\t\t\t// information.\n\n\t\treturn elements.remove(element.getId());\n\t}\n\n\t/**\n\t * Push an event specifically for the given element. Events are stacked in\n\t * order. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element to modify with an event.\n\t * @param event\n\t *            The event to push.\n\t */\n\tprotected void pushEventFor(Element element, String event) {\n\t\tif (elements.containsKey(element.getId())) {\n\t\t\tif (eventsFor == null)\n\t\t\t\teventsFor = new HashMap<Element, ElementEvents>();\n\n\t\t\tElementEvents evs = eventsFor.get(element);\n\n\t\t\tif (evs == null) {\n\t\t\t\tevs = new ElementEvents(element, this, event);\n\t\t\t\teventsFor.put(element, evs);\n\t\t\t} else {\n\t\t\t\tevs.pushEvent(event);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Pop an event for the given element. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element.\n\t * @param event\n\t *            The event.\n\t */\n\tprotected void popEventFor(Element element, String event) {\n\t\tif (elements.containsKey(element.getId())) {\n\t\t\tElementEvents evs = eventsFor.get(element);\n\n\t\t\tif (evs != null) {\n\t\t\t\tevs.popEvent(event);\n\n\t\t\t\tif (evs.eventCount() == 0)\n\t\t\t\t\teventsFor.remove(element);\n\t\t\t}\n\n\t\t\tif (eventsFor.isEmpty())\n\t\t\t\teventsFor = null;\n\t\t}\n\t}\n\n\t/**\n\t * Before drawing an element that has events, use this method to activate\n\t * the events, the style values will be modified accordingly. Events for\n\t * this element must have been registered via\n\t * {@link #pushEventFor(Element, String)}. After rendering the\n\t * {@link #deactivateEvents()} MUST be called.\n\t * \n\t * @param element\n\t *            The element to push events for.\n\t */\n\tpublic void activateEventsFor(Element element) {\n\t\tElementEvents evs = eventsFor.get(element);\n\n\t\tif (evs != null && curEvents == null)\n\t\t\tcurEvents = evs.events();\n\t}\n\n\t/**\n\t * De-activate any events activated for an element. This method MUST be\n\t * called if {@link #activateEventsFor(Element)} has been called.\n\t */\n\tpublic void deactivateEvents() {\n\t\tcurEvents = null;\n\t}\n\n\t/**\n\t * Indicate the element has dynamic values and thus cannot be drawn in bulk\n\t * operations. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element.\n\t */\n\tprotected void pushElementAsDynamic(Element element) {\n\t\tif (dynamicOnes == null)\n\t\t\tdynamicOnes = new HashSet<Element>();\n\n\t\tdynamicOnes.add(element);\n\t}\n\n\t/**\n\t * Indicate the element has no more dynamic values and can be drawn in bulk\n\t * operations. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element.\n\t */\n\tprotected void popElementAsDynamic(Element element) {\n\t\tdynamicOnes.remove(element);\n\n\t\tif (dynamicOnes.isEmpty())\n\t\t\tdynamicOnes = null;\n\t}\n\n\t/**\n\t * Remove all graph elements of this group, and remove this group from the\n\t * group list of each style rule.\n\t */\n\tpublic void release() {\n\t\tfor (Rule rule : rules)\n\t\t\trule.removeGroup(id);\n\n\t\telements.clear();\n\t}\n\n\t/**\n\t * Redefinition of the {@link Style} to forbid changing the values.\n\t */\n\t@Override\n\tpublic void setValue(String property, Object value) {\n\t\tthrow new RuntimeException(\n\t\t\t\t\"you cannot change the values of a style group.\");\n\t}\n\n\t/**\n\t * Add a renderer to this group.\n\t * \n\t * @param id\n\t *            The renderer identifier.\n\t * @param renderer\n\t *            The renderer.\n\t */\n\tpublic void addRenderer(String id, SwingElementRenderer renderer) {\n\t\tif (renderers == null)\n\t\t\trenderers = new HashMap<String, SwingElementRenderer>();\n\n\t\trenderers.put(id, renderer);\n\t}\n\n\t/**\n\t * Remove a renderer.\n\t * \n\t * @param id\n\t *            The renderer identifier.\n\t * @return The removed renderer or null if not found.\n\t */\n\tpublic SwingElementRenderer removeRenderer(String id) {\n\t\treturn renderers.remove(id);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(-1);\n\t}\n\n\t@Override\n\tpublic String toString(int level) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tString prefix = \"\";\n\t\tString sprefix = \"    \";\n\n\t\tfor (int i = 0; i < level; i++)\n\t\t\tprefix += sprefix;\n\n\t\tbuilder.append(String.format(\"%s%s%n\", prefix, id));\n\t\tbuilder.append(String.format(\"%s%sContains : \", prefix, sprefix));\n\n\t\tfor (Element element : elements.values()) {\n\t\t\tbuilder.append(String.format(\"%s \", element.getId()));\n\t\t}\n\n\t\tbuilder.append(String.format(\"%n%s%sStyle : \", prefix, sprefix));\n\n\t\tfor (Rule rule : rules) {\n\t\t\tbuilder.append(String.format(\"%s \", rule.selector.toString()));\n\t\t}\n\n\t\tbuilder.append(String.format(\"%n\"));\n\n\t\treturn builder.toString();\n\t}\n\n\t// Nested classes\n\n\t/**\n\t * Description of an element that is actually modified by one or more events\n\t * occurring on it.\n\t */\n\tpublic static class ElementEvents {\n\t\t// Attribute\n\n\t\t/**\n\t\t * Set of events on the element.\n\t\t */\n\t\tprotected String events[];\n\n\t\t/**\n\t\t * The element.\n\t\t */\n\t\tprotected Element element;\n\n\t\t/**\n\t\t * The group the element pertains to.\n\t\t */\n\t\tprotected StyleGroup group;\n\n\t\t// Construction\n\n\t\tprotected ElementEvents(Element element, StyleGroup group, String event) {\n\t\t\tthis.element = element;\n\t\t\tthis.group = group;\n\t\t\tthis.events = new String[1];\n\n\t\t\tevents[0] = event;\n\t\t}\n\n\t\t// Access\n\n\t\t/**\n\t\t * The element on which the events are occurring.\n\t\t * \n\t\t * @return an element.\n\t\t */\n\t\tpublic Element getElement() {\n\t\t\treturn element;\n\t\t}\n\n\t\t/**\n\t\t * Number of events actually affecting the element.\n\t\t * \n\t\t * @return The number of events affecting the element.\n\t\t */\n\t\tpublic int eventCount() {\n\t\t\tif (events == null)\n\t\t\t\treturn 0;\n\n\t\t\treturn events.length;\n\t\t}\n\n\t\t/**\n\t\t * The set of events actually occurring on the element.\n\t\t * \n\t\t * @return A set of strings.\n\t\t */\n\t\tpublic String[] events() {\n\t\t\treturn events;\n\t\t}\n\n\t\t// Command\n\n\t\tpublic void activate() {\n\t\t\tgroup.activateEventsFor(element);\n\t\t}\n\n\t\tpublic void deactivate() {\n\t\t\tgroup.deactivateEvents();\n\t\t}\n\n\t\tprotected void pushEvent(String event) {\n\t\t\tint n = events.length + 1;\n\t\t\tString e[] = new String[n];\n\t\t\tboolean found = false;\n\n\t\t\tfor (int i = 0; i < events.length; i++) {\n\t\t\t\tif (!events[i].equals(event))\n\t\t\t\t\te[i] = events[i];\n\t\t\t\telse\n\t\t\t\t\tfound = true;\n\t\t\t}\n\n\t\t\te[events.length] = event;\n\n\t\t\tif (!found)\n\t\t\t\tevents = e;\n\t\t}\n\n\t\tprotected void popEvent(String event) {\n\t\t\tif (events.length > 1) {\n\t\t\t\tString e[] = new String[events.length - 1];\n\t\t\t\tboolean found = false;\n\n\t\t\t\tfor (int i = 0, j = 0; i < events.length; i++) {\n\t\t\t\t\tif (!events[i].equals(event)) {\n\t\t\t\t\t\tif (j < e.length) {\n\t\t\t\t\t\t\te[j++] = events[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (found)\n\t\t\t\t\tevents = e;\n\t\t\t} else {\n\t\t\t\tif (events[0].equals(event)) {\n\t\t\t\t\tevents = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\tbuilder.append(String.format(\"%s events {\", element.getId()));\n\t\t\tfor (String event : events)\n\t\t\t\tbuilder.append(String.format(\" %s\", event));\n\t\t\tbuilder.append(\" }\");\n\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Virtual set on the elements that have not dynamic style value or event.\n\t */\n\tprotected class BulkElements implements Iterable<Element> {\n\t\tpublic Iterator<Element> iterator() {\n\t\t\treturn new BulkIterator(elements.values().iterator());\n\t\t}\n\t}\n\n\t/**\n\t * Iterator on the set of elements that have no event or dynamic style\n\t * values.\n\t */\n\tprotected class BulkIterator implements Iterator<Element> {\n\t\t/**\n\t\t * Iterator on the set of all elements.\n\t\t */\n\t\tprotected Iterator<Element> iterator;\n\n\t\t/**\n\t\t * The next element without event or dynamic style.value.\n\t\t */\n\t\tElement next;\n\n\t\t/**\n\t\t * New bulk iterator positioned on the first element with no event or\n\t\t * dynamic style attribute.\n\t\t * \n\t\t * @param iterator\n\t\t *            Iterator on the set of all elements.\n\t\t */\n\t\tpublic BulkIterator(Iterator<Element> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t\tboolean loop = true;\n\n\t\t\twhile (loop && iterator.hasNext()) {\n\t\t\t\tnext = iterator.next();\n\n\t\t\t\tif (!elementHasEvents(next) && !elementIsDynamic(next))\n\t\t\t\t\tloop = false;\n\t\t\t\telse\n\t\t\t\t\tnext = null;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\treturn (next != null);\n\t\t}\n\n\t\tpublic Element next() {\n\t\t\tElement e = next;\n\t\t\tboolean loop = true;\n\n\t\t\tnext = null;\n\n\t\t\twhile (loop && iterator.hasNext()) {\n\t\t\t\tnext = iterator.next();\n\n\t\t\t\tif (!elementIsDynamic(next) && !elementHasEvents(next))\n\t\t\t\t\tloop = false;\n\t\t\t\telse\n\t\t\t\t\tnext = null;\n\t\t\t}\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"this iterator does not allows removing elements\");\n\t\t}\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "element",
                "org.graphstream.graph",
                "Element"
            ],
            [
                "event",
                "java.lang",
                "String"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getType",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Type of graph element concerned by this style (node, edge, sprite,\n * graph).\n *\n * @return The type of the style group elements.\n */\npublic Selector.Type getType() {\n    return rules.get(0).selector.type;\n}"
            ],
            [
                "dynamicElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Subset of elements that have dynamic style values and therefore must be\n * rendered one by one, not in groups like others. Even though elements\n * style can specify some dynamics, the elements must individually have\n * attributes that specify the dynamic value. If the elements do not have\n * these attributes they can be rendered in bulk operations.\n *\n * @return The subset of dynamic elements of the group.\n */\npublic Iterable<Element> dynamicElements() {\n    return dynamicOnes;\n}"
            ],
            [
                "getTextVisibility",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getTextVisibility()"
            ],
            [
                "bulkElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Iterable set of elements that can be drawn in a bulk operation, that is\n * the subset of all elements that are not dynamic or modified by an event.\n *\n * @return The iterable set of bulk elements.\n */\npublic Iterable<? extends Element> bulkElements() {\n    return bulkElements;\n}"
            ],
            [
                "getTextBackgroundMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextBackgroundMode getTextBackgroundMode()"
            ],
            [
                "elements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Iterable set of elements. This the complete set of elements contained in\n * this group without regard to the fact they are modified by an event or\n * are dynamic. If you plan to respect events or dynamic elements, you must\n * check the elements are not modified by events using\n * {@link #elementHasEvents(Element)} and are not dynamic by using\n * {@link #elementIsDynamic(Element)} and then draw modified elements using\n * {@link #elementsEvents()} and {@link #dynamicElements()}. But the easiest\n * way of drawing is to use first {@link #bulkElements()} for all non\n * dynamic non event elements, then the {@link #dynamicElements()} and\n * {@link #elementsEvents()} to draw all dynamic and event elements.\n *\n * @return All the elements in no particular order.\n */\npublic Iterable<? extends Element> elements() {\n    return elements.values();\n}"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "getTextColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getTextColor()"
            ],
            [
                "getValueForEvent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected Object getValueForEvent(String arg0, String arg1)"
            ],
            [
                "getFillColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getFillColor(int arg0)"
            ],
            [
                "getRenderer",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The associated renderers.\n *\n * @return A renderer or null if not found.\n */\npublic SwingElementRenderer getRenderer(String id) {\n    if (renderers != null)\n        return renderers.get(id);\n    return null;\n}"
            ],
            [
                "elementIsDynamic",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the given element has dynamic style values provided by specific\n * attributes.\n *\n * @param element\n *            The element to test.\n * @return True if the element has actually specific style attributes.\n */\npublic boolean elementIsDynamic(Element element) {\n    return (dynamicOnes != null && dynamicOnes.contains(element));\n}"
            ],
            [
                "toString",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "@Override\npublic String toString() {\n    return toString(-1);\n}"
            ],
            [
                "getStrokeColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getStrokeColor(int arg0)"
            ],
            [
                "getTextBackgroundColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getTextBackgroundColor()"
            ],
            [
                "getSizeMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.SizeMode getSizeMode()"
            ],
            [
                "getShapePoints",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getShapePoints()"
            ],
            [
                "getShadowColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getShadowColorCount()"
            ],
            [
                "getTextSize",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Value getTextSize()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getSize",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getSize()"
            ],
            [
                "getTextMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextMode getTextMode()"
            ],
            [
                "getShadowWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Value getShadowWidth()"
            ],
            [
                "contains",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the group contains the element whose identifier is given.\n *\n * @param elementId\n *            The element to search.\n * @return true if the element is in the group.\n */\npublic boolean contains(String elementId) {\n    return elements.containsKey(elementId);\n}"
            ],
            [
                "getValue",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Get the value of a given property.\n *\n * This is a redefinition of the method in {@link Style} to consider the\n * fact a style group aggregates several style rules.\n *\n * @param property\n *            The style property the value is searched for.\n */\n@Override\npublic Object getValue(String property, String... events) {\n    int n = rules.size();\n    if (events == null || events.length == 0) {\n        if (curEvents != null && curEvents.length > 0) {\n            events = curEvents;\n        } else if (eventSet.events != null && eventSet.events.length > 0) {\n            events = eventSet.events;\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        Style style = rules.get(i).getStyle();\n        if (style.hasValue(property, events))\n            return style.getValue(property, events);\n    }\n    return rules.get(0).getStyle().getValue(property, events);\n}"
            ],
            [
                "getSpriteOrientation",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.SpriteOrientation getSpriteOrientation()"
            ],
            [
                "getTextStyle",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextStyle getTextStyle()"
            ],
            [
                "elementHasEvents",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the given element actually has active events.\n *\n * @param element\n *            The element to test.\n * @return True if the element has actually active events.\n */\npublic boolean elementHasEvents(Element element) {\n    return (eventsFor != null && eventsFor.containsKey(element));\n}"
            ],
            [
                "getShape",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.Shape getShape()"
            ],
            [
                "getTextOffset",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getTextOffset()"
            ],
            [
                "getVisibilityMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.VisibilityMode getVisibilityMode()"
            ],
            [
                "hasEventElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * If true this group contains some elements that are actually changed by an\n * event. Such elements cannot therefore be drawn in a group operation, but\n * one by one.\n *\n * @return True if the group contains some elements changed by an event.\n */\npublic boolean hasEventElements() {\n    return (eventsFor != null && eventsFor.size() > 0);\n}"
            ],
            [
                "contains",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the group contains the element given.\n *\n * @param element\n *            The element to search.\n * @return true if the element is in the group.\n */\npublic boolean contains(Element element) {\n    return elements.containsKey(element.getId());\n}"
            ],
            [
                "getCanvasColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getCanvasColor()"
            ],
            [
                "getShadowColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getShadowColor(int arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "@Override\npublic String toString(int level) {\n    StringBuilder builder = new StringBuilder();\n    String prefix = \"\";\n    String sprefix = \"    \";\n    for (int i = 0; i < level; i++) prefix += sprefix;\n    builder.append(String.format(\"%s%s%n\", prefix, id));\n    builder.append(String.format(\"%s%sContains : \", prefix, sprefix));\n    for (Element element : elements.values()) {\n        builder.append(String.format(\"%s \", element.getId()));\n    }\n    builder.append(String.format(\"%n%s%sStyle : \", prefix, sprefix));\n    for (Rule rule : rules) {\n        builder.append(String.format(\"%s \", rule.selector.toString()));\n    }\n    builder.append(String.format(\"%n\"));\n    return builder.toString();\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "elementsEvents",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Subset of elements that are actually modified by one or more events. The\n * {@link ElementEvents} class contains the element and an array of events\n * that can be pushed on the style group set.\n *\n * @return The subset of elements modified by one or more events.\n */\npublic Iterable<ElementEvents> elementsEvents() {\n    return eventsFor.values();\n}"
            ],
            [
                "getFillColors",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getFillColors()"
            ],
            [
                "getTextPadding",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getTextPadding()"
            ],
            [
                "getElementIterator",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Iterator on the set of graph elements of this group.\n *\n * @return The elements iterator.\n */\npublic Iterator<? extends Element> getElementIterator() {\n    return elements.values().iterator();\n}"
            ],
            [
                "getIcon",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getIcon()"
            ],
            [
                "getIconMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.IconMode getIconMode()"
            ],
            [
                "getShadowMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.ShadowMode getShadowMode()"
            ],
            [
                "getTextBackgroundColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getTextBackgroundColor(int arg0)"
            ],
            [
                "getArrowSize",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getArrowSize()"
            ],
            [
                "getTextAlignment",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextAlignment getTextAlignment()"
            ],
            [
                "getStrokeMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.StrokeMode getStrokeMode()"
            ],
            [
                "getTextFont",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getTextFont()"
            ],
            [
                "getStrokeColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getStrokeColor()"
            ],
            [
                "removeRenderer",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Remove a renderer.\n *\n * @param id\n *            The renderer identifier.\n * @return The removed renderer or null if not found.\n */\npublic SwingElementRenderer removeRenderer(String id) {\n    return renderers.remove(id);\n}"
            ],
            [
                "getShadowOffset",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getShadowOffset()"
            ],
            [
                "getTextVisibilityMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextVisibilityMode getTextVisibilityMode()"
            ],
            [
                "getParent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Rule getParent()"
            ],
            [
                "getFillColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getFillColorCount()"
            ],
            [
                "getCanvasColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getCanvasColor(int arg0)"
            ],
            [
                "getArrowImage",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getArrowImage()"
            ],
            [
                "getElementCount",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The number of elements of the group.\n *\n * @return The element count.\n */\npublic int getElementCount() {\n    return elements.size();\n}"
            ],
            [
                "isElementDynamic",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Test if an element is pushed as dynamic.\n */\npublic boolean isElementDynamic(Element element) {\n    if (dynamicOnes != null)\n        return dynamicOnes.contains(element);\n    return false;\n}"
            ],
            [
                "getStrokeColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getStrokeColorCount()"
            ],
            [
                "getId",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "// Access\n/**\n * The group unique identifier.\n *\n * @return A style group identifier.\n */\npublic String getId() {\n    return id;\n}"
            ],
            [
                "getPadding",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getPadding()"
            ],
            [
                "getFillImage",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getFillImage()"
            ],
            [
                "getZIndex",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Integer getZIndex()"
            ],
            [
                "getCanvasColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getCanvasColorCount()"
            ],
            [
                "getArrowShape",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.ArrowShape getArrowShape()"
            ],
            [
                "iterator",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "public Iterator<Element> iterator() {\n    return elements.values().iterator();\n}"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "getShadowColors",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getShadowColors()"
            ],
            [
                "getJComponent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.JComponents getJComponent()"
            ],
            [
                "isEmpty",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if there are no elements in the group.\n *\n * @return True if the group is empty of elements.\n */\npublic boolean isEmpty() {\n    return elements.isEmpty();\n}"
            ],
            [
                "getStrokeWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Value getStrokeWidth()"
            ],
            [
                "getTextColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getTextColorCount()"
            ],
            [
                "getVisibility",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getVisibility()"
            ],
            [
                "getFillMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.FillMode getFillMode()"
            ],
            [
                "removeElement",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Remove a graph element from the group.\n *\n * @param element\n *            The element to remove.\n * @return The removed element, or null if the element was not found.\n */\npublic Element removeElement(Element element) {\n    if (eventsFor != null && eventsFor.containsKey(element))\n        // Remove an eventual remaining event.\n        eventsFor.remove(element);\n    if (dynamicOnes != null && dynamicOnes.contains(element))\n        // Remove an eventual remaining dynamic\n        dynamicOnes.remove(element);\n    // information.\n    return elements.remove(element.getId());\n}"
            ],
            [
                "getElement",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Return an element of the group, knowing its identifier.\n *\n * @param id\n *            The searched element identifier.\n * @return The element corresponding to the identifier or null if not found.\n */\npublic Element getElement(String id) {\n    return elements.get(id);\n}"
            ],
            [
                "hasValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public transient boolean hasValue(String arg0, String[] arg1)"
            ],
            [
                "getTextColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getTextColor(int arg0)"
            ],
            [
                "getEventsFor",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Set of events for a given element or null if the element has not\n * currently occurring events.\n *\n * @return A set of events or null if none occurring at that time.\n */\npublic ElementEvents getEventsFor(Element element) {\n    if (eventsFor != null)\n        return eventsFor.get(element);\n    return null;\n}"
            ],
            [
                "hasDynamicElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if at least one of the style properties is dynamic (set according to\n * an attribute of the element to draw). Such elements cannot therefore be\n * drawn in a group operation, but one by one.\n *\n * @return True if one property is dynamic.\n */\npublic boolean hasDynamicElements() {\n    return (dynamicOnes != null && dynamicOnes.size() > 0);\n}"
            ],
            [
                "getNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract double getNumber(String arg0)"
            ],
            [
                "hasLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasLabel(String arg0)"
            ],
            [
                "getAttributeKeyIterator",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterator<String> getAttributeKeyIterator()"
            ],
            [
                "hasArray",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasArray(String arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0, Class<T> arg1)"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0)"
            ],
            [
                "getAttributeKeySet",
                "org.graphstream.graph",
                "Element",
                "public abstract Collection<String> getAttributeKeySet()"
            ],
            [
                "getHash",
                "org.graphstream.graph",
                "Element",
                "public abstract HashMap<?, ?> getHash(String arg0)"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(String[] arg0)"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0, Class<?> arg1)"
            ],
            [
                "getIndex",
                "org.graphstream.graph",
                "Element",
                "public abstract int getIndex()"
            ],
            [
                "hasHash",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasHash(String arg0)"
            ],
            [
                "getEachAttributeKey",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterable<String> getEachAttributeKey()"
            ],
            [
                "getVector",
                "org.graphstream.graph",
                "Element",
                "public abstract ArrayList<? extends Number> getVector(String arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0)"
            ],
            [
                "hasVector",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasVector(String arg0)"
            ],
            [
                "getAttributeCount",
                "org.graphstream.graph",
                "Element",
                "public abstract int getAttributeCount()"
            ],
            [
                "getLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract CharSequence getLabel(String arg0)"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)"
            ],
            [
                "getArray",
                "org.graphstream.graph",
                "Element",
                "public abstract Object[] getArray(String arg0)"
            ],
            [
                "hasNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasNumber(String arg0)"
            ],
            [
                "getId",
                "org.graphstream.graph",
                "Element",
                "public abstract String getId()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "id",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "// Attribute\n/**\n * The group unique identifier.\n */\nprotected String id;"
            ],
            [
                "rules",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The set of style rules.\n */\nprotected ArrayList<Rule> rules = new ArrayList<Rule>();"
            ],
            [
                "elements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Graph elements of this group.\n */\nprotected HashMap<String, Element> elements = new HashMap<String, Element>();"
            ],
            [
                "eventSet",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The global events actually occurring.\n */\nprotected StyleGroupSet.EventSet eventSet;"
            ],
            [
                "eventsFor",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Set of elements whose style is actually modified individually by an\n * event. Such elements must be rendered one by one, not in groups like\n * others.\n */\nprotected HashMap<Element, ElementEvents> eventsFor;"
            ],
            [
                "dynamicOnes",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Set of elements that have some dynamic style values. Such elements must\n * be rendered one by one, not in groups, like others.\n */\nprotected HashSet<Element> dynamicOnes;"
            ],
            [
                "curEvents",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * A set of events actually pushed only for this group.\n */\nprotected String[] curEvents;"
            ],
            [
                "bulkElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The set of bulk elements.\n */\nprotected BulkElements bulkElements = new BulkElements();"
            ],
            [
                "renderers",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Associated renderers.\n */\npublic HashMap<String, SwingElementRenderer> renderers;"
            ],
            [
                "parent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected Rule parent;"
            ],
            [
                "values",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected HashMap<String, Object> values;"
            ],
            [
                "alternates",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected HashMap<String, Rule> alternates;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3150,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.ui.graphicGraph",
        "className": "StyleGroup",
        "javadocTag": "@param id The renderer identifier.",
        "methodJavadoc": "    /**\n\t * Add a renderer to this group.\n\t * \n\t * @param id\n\t *            The renderer identifier.\n\t * @param renderer\n\t *            The renderer.\n\t */",
        "methodSourceCode": "public void addRenderer(String id, SwingElementRenderer renderer){\n    if (renderers == null)\n        renderers = new HashMap<String, SwingElementRenderer>();\n    renderers.put(id, renderer);\n}",
        "classJavadoc": "/**\n * A group of graph elements that share the same style.\n * \n * <p>\n * The purpose of a style group is to allow retrieving all elements with the\n * same style easily. Most of the time, with graphic engines, pushing the\n * graphic state (the style, colors, line width, textures, gradients) is a\n * costly operation. Doing it once for several elements can speed up things a\n * lot. This is the purpose of the style group.\n * </p>\n * \n * <p>\n * The action of drawing elements in group (first push style, then draw all\n * elements) are called bulk drawing. All elements that can be drawn at once\n * this way are called bulk elements.\n * </p>\n * \n * <p>\n * In a style group it is not always possible do draw elements in a such a\n * \"bulk\" operation. If the style contains \"dynamic values\" for example, that is\n * value that depend on the value of an attribute stored on the element, or if\n * the element is modified by an event (clicked, selected), the element will not\n * be drawn the same as others.\n * </p>\n * \n * <p>\n * The style group provides iterators on each of these categories of elements :\n * <ul>\n * <li>{@link #elements()} allows to browse all elements contained in the group\n * without exception.</li>\n * <li>{@link #dynamicElements()} allows to browse the subset of elements having\n * a attribute that modify their style.</li>\n * <li>{@link #elementsEvents()} allows to browse the subset of elements\n * modified by an event.</li>\n * <li>{@link #bulkElements()} allows to browse all remaining elements that have\n * no dynamic attribute or event.</li>\n * </ul>\n * The calling the three last iterators would yield the same elements as calling\n * the first one. When drawing you can optimise the drawing by first pushing the\n * graphic state and then drawing at once all bulk elements. If the dynamic and\n * event subsets are not empty you then must draw such elements modifying the\n * graphic state for each one.\n * </p>\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.ui.graphicGraph;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.graphstream.graph.Element;\nimport org.graphstream.ui.graphicGraph.GraphicElement.SwingElementRenderer;\nimport org.graphstream.ui.graphicGraph.stylesheet.Rule;\nimport org.graphstream.ui.graphicGraph.stylesheet.Selector;\nimport org.graphstream.ui.graphicGraph.stylesheet.Style;\n\n/**\n * A group of graph elements that share the same style.\n * \n * <p>\n * The purpose of a style group is to allow retrieving all elements with the\n * same style easily. Most of the time, with graphic engines, pushing the\n * graphic state (the style, colors, line width, textures, gradients) is a\n * costly operation. Doing it once for several elements can speed up things a\n * lot. This is the purpose of the style group.\n * </p>\n * \n * <p>\n * The action of drawing elements in group (first push style, then draw all\n * elements) are called bulk drawing. All elements that can be drawn at once\n * this way are called bulk elements.\n * </p>\n * \n * <p>\n * In a style group it is not always possible do draw elements in a such a\n * \"bulk\" operation. If the style contains \"dynamic values\" for example, that is\n * value that depend on the value of an attribute stored on the element, or if\n * the element is modified by an event (clicked, selected), the element will not\n * be drawn the same as others.\n * </p>\n * \n * <p>\n * The style group provides iterators on each of these categories of elements :\n * <ul>\n * <li>{@link #elements()} allows to browse all elements contained in the group\n * without exception.</li>\n * <li>{@link #dynamicElements()} allows to browse the subset of elements having\n * a attribute that modify their style.</li>\n * <li>{@link #elementsEvents()} allows to browse the subset of elements\n * modified by an event.</li>\n * <li>{@link #bulkElements()} allows to browse all remaining elements that have\n * no dynamic attribute or event.</li>\n * </ul>\n * The calling the three last iterators would yield the same elements as calling\n * the first one. When drawing you can optimise the drawing by first pushing the\n * graphic state and then drawing at once all bulk elements. If the dynamic and\n * event subsets are not empty you then must draw such elements modifying the\n * graphic state for each one.\n * </p>\n */\npublic class StyleGroup extends Style implements Iterable<Element> {\n\t// Attribute\n\n\t/**\n\t * The group unique identifier.\n\t */\n\tprotected String id;\n\n\t/**\n\t * The set of style rules.\n\t */\n\tprotected ArrayList<Rule> rules = new ArrayList<Rule>();\n\n\t/**\n\t * Graph elements of this group.\n\t */\n\tprotected HashMap<String, Element> elements = new HashMap<String, Element>();\n\n\t/**\n\t * The global events actually occurring.\n\t */\n\tprotected StyleGroupSet.EventSet eventSet;\n\n\t/**\n\t * Set of elements whose style is actually modified individually by an\n\t * event. Such elements must be rendered one by one, not in groups like\n\t * others.\n\t */\n\tprotected HashMap<Element, ElementEvents> eventsFor;\n\n\t/**\n\t * Set of elements that have some dynamic style values. Such elements must\n\t * be rendered one by one, not in groups, like others.\n\t */\n\tprotected HashSet<Element> dynamicOnes;\n\n\t/**\n\t * A set of events actually pushed only for this group.\n\t */\n\tprotected String[] curEvents;\n\n\t/**\n\t * The set of bulk elements.\n\t */\n\tprotected BulkElements bulkElements = new BulkElements();\n\n\t/**\n\t * Associated renderers.\n\t */\n\tpublic HashMap<String, SwingElementRenderer> renderers;\n\n\t// Construction\n\n\t/**\n\t * New style group for a first graph element and the set of style rules that\n\t * matches it. More graph elements can be added later.\n\t * \n\t * @param identifier\n\t *            The unique group identifier (see\n\t *            {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getStyleGroupIdFor(Element, ArrayList)}\n\t *            ).\n\t * @param rules\n\t *            The set of style rules for the style group (see\n\t *            {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getRulesFor(Element)}\n\t *            ).\n\t * @param firstElement\n\t *            The first element to construct the group.\n\t */\n\tpublic StyleGroup(String identifier, Collection<Rule> rules,\n\t\t\tElement firstElement, StyleGroupSet.EventSet eventSet) {\n\t\tthis.id = identifier;\n\t\tthis.rules.addAll(rules);\n\t\tthis.elements.put(firstElement.getId(), firstElement);\n\t\tthis.values = null; // To avoid consume memory since this style will not\n\t\t\t\t\t\t\t// store anything.\n\t\tthis.eventSet = eventSet;\n\n\t\tfor (Rule rule : rules)\n\t\t\trule.addGroup(identifier);\n\t}\n\n\t// Access\n\n\t/**\n\t * The group unique identifier.\n\t * \n\t * @return A style group identifier.\n\t */\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * Type of graph element concerned by this style (node, edge, sprite,\n\t * graph).\n\t * \n\t * @return The type of the style group elements.\n\t */\n\tpublic Selector.Type getType() {\n\t\treturn rules.get(0).selector.type;\n\t}\n\n\t/**\n\t * True if at least one of the style properties is dynamic (set according to\n\t * an attribute of the element to draw). Such elements cannot therefore be\n\t * drawn in a group operation, but one by one.\n\t * \n\t * @return True if one property is dynamic.\n\t */\n\tpublic boolean hasDynamicElements() {\n\t\treturn (dynamicOnes != null && dynamicOnes.size() > 0);\n\t}\n\n\t/**\n\t * If true this group contains some elements that are actually changed by an\n\t * event. Such elements cannot therefore be drawn in a group operation, but\n\t * one by one.\n\t * \n\t * @return True if the group contains some elements changed by an event.\n\t */\n\tpublic boolean hasEventElements() {\n\t\treturn (eventsFor != null && eventsFor.size() > 0);\n\t}\n\n\t/**\n\t * True if the given element actually has active events.\n\t * \n\t * @param element\n\t *            The element to test.\n\t * @return True if the element has actually active events.\n\t */\n\tpublic boolean elementHasEvents(Element element) {\n\t\treturn (eventsFor != null && eventsFor.containsKey(element));\n\t}\n\n\t/**\n\t * True if the given element has dynamic style values provided by specific\n\t * attributes.\n\t * \n\t * @param element\n\t *            The element to test.\n\t * @return True if the element has actually specific style attributes.\n\t */\n\tpublic boolean elementIsDynamic(Element element) {\n\t\treturn (dynamicOnes != null && dynamicOnes.contains(element));\n\t}\n\n\t/**\n\t * Get the value of a given property.\n\t * \n\t * This is a redefinition of the method in {@link Style} to consider the\n\t * fact a style group aggregates several style rules.\n\t * \n\t * @param property\n\t *            The style property the value is searched for.\n\t */\n\t@Override\n\tpublic Object getValue(String property, String... events) {\n\t\tint n = rules.size();\n\n\t\tif (events == null || events.length == 0) {\n\t\t\tif (curEvents != null && curEvents.length > 0) {\n\t\t\t\tevents = curEvents;\n\t\t\t} else if (eventSet.events != null && eventSet.events.length > 0) {\n\t\t\t\tevents = eventSet.events;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tStyle style = rules.get(i).getStyle();\n\n\t\t\tif (style.hasValue(property, events))\n\t\t\t\treturn style.getValue(property, events);\n\t\t}\n\n\t\treturn rules.get(0).getStyle().getValue(property, events);\n\t}\n\n\t/**\n\t * True if there are no elements in the group.\n\t * \n\t * @return True if the group is empty of elements.\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn elements.isEmpty();\n\t}\n\n\t/**\n\t * True if the group contains the element whose identifier is given.\n\t * \n\t * @param elementId\n\t *            The element to search.\n\t * @return true if the element is in the group.\n\t */\n\tpublic boolean contains(String elementId) {\n\t\treturn elements.containsKey(elementId);\n\t}\n\n\t/**\n\t * True if the group contains the element given.\n\t * \n\t * @param element\n\t *            The element to search.\n\t * @return true if the element is in the group.\n\t */\n\tpublic boolean contains(Element element) {\n\t\treturn elements.containsKey(element.getId());\n\t}\n\n\t/**\n\t * Return an element of the group, knowing its identifier.\n\t * \n\t * @param id\n\t *            The searched element identifier.\n\t * @return The element corresponding to the identifier or null if not found.\n\t */\n\tpublic Element getElement(String id) {\n\t\treturn elements.get(id);\n\t}\n\n\t/**\n\t * The number of elements of the group.\n\t * \n\t * @return The element count.\n\t */\n\tpublic int getElementCount() {\n\t\treturn elements.size();\n\t}\n\n\t/**\n\t * Iterator on the set of graph elements of this group.\n\t * \n\t * @return The elements iterator.\n\t */\n\tpublic Iterator<? extends Element> getElementIterator() {\n\t\treturn elements.values().iterator();\n\t}\n\n\t/**\n\t * Iterable set of elements. This the complete set of elements contained in\n\t * this group without regard to the fact they are modified by an event or\n\t * are dynamic. If you plan to respect events or dynamic elements, you must\n\t * check the elements are not modified by events using\n\t * {@link #elementHasEvents(Element)} and are not dynamic by using\n\t * {@link #elementIsDynamic(Element)} and then draw modified elements using\n\t * {@link #elementsEvents()} and {@link #dynamicElements()}. But the easiest\n\t * way of drawing is to use first {@link #bulkElements()} for all non\n\t * dynamic non event elements, then the {@link #dynamicElements()} and\n\t * {@link #elementsEvents()} to draw all dynamic and event elements.\n\t * \n\t * @return All the elements in no particular order.\n\t */\n\tpublic Iterable<? extends Element> elements() {\n\t\treturn elements.values();\n\t}\n\n\t/**\n\t * Iterable set of elements that can be drawn in a bulk operation, that is\n\t * the subset of all elements that are not dynamic or modified by an event.\n\t * \n\t * @return The iterable set of bulk elements.\n\t */\n\tpublic Iterable<? extends Element> bulkElements() {\n\t\treturn bulkElements;\n\t}\n\n\t/**\n\t * Subset of elements that are actually modified by one or more events. The\n\t * {@link ElementEvents} class contains the element and an array of events\n\t * that can be pushed on the style group set.\n\t * \n\t * @return The subset of elements modified by one or more events.\n\t */\n\tpublic Iterable<ElementEvents> elementsEvents() {\n\t\treturn eventsFor.values();\n\t}\n\n\t/**\n\t * Subset of elements that have dynamic style values and therefore must be\n\t * rendered one by one, not in groups like others. Even though elements\n\t * style can specify some dynamics, the elements must individually have\n\t * attributes that specify the dynamic value. If the elements do not have\n\t * these attributes they can be rendered in bulk operations.\n\t * \n\t * @return The subset of dynamic elements of the group.\n\t */\n\tpublic Iterable<Element> dynamicElements() {\n\t\treturn dynamicOnes;\n\t}\n\n\tpublic Iterator<Element> iterator() {\n\t\treturn elements.values().iterator();\n\t}\n\n\t/**\n\t * The associated renderers.\n\t * \n\t * @return A renderer or null if not found.\n\t */\n\tpublic SwingElementRenderer getRenderer(String id) {\n\t\tif (renderers != null)\n\t\t\treturn renderers.get(id);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set of events for a given element or null if the element has not\n\t * currently occurring events.\n\t * \n\t * @return A set of events or null if none occurring at that time.\n\t */\n\tpublic ElementEvents getEventsFor(Element element) {\n\t\tif (eventsFor != null)\n\t\t\treturn eventsFor.get(element);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Test if an element is pushed as dynamic.\n\t */\n\tpublic boolean isElementDynamic(Element element) {\n\t\tif (dynamicOnes != null)\n\t\t\treturn dynamicOnes.contains(element);\n\n\t\treturn false;\n\t}\n\n\t// Command\n\n\t/**\n\t * Add a new graph element to the group.\n\t * \n\t * @param element\n\t *            The new graph element to add.\n\t */\n\tpublic void addElement(Element element) {\n\t\telements.put(element.getId(), element);\n\t}\n\n\t/**\n\t * Remove a graph element from the group.\n\t * \n\t * @param element\n\t *            The element to remove.\n\t * @return The removed element, or null if the element was not found.\n\t */\n\tpublic Element removeElement(Element element) {\n\t\tif (eventsFor != null && eventsFor.containsKey(element))\n\t\t\teventsFor.remove(element); // Remove an eventual remaining event.\n\n\t\tif (dynamicOnes != null && dynamicOnes.contains(element))\n\t\t\tdynamicOnes.remove(element); // Remove an eventual remaining dynamic\n\t\t\t\t\t\t\t\t\t\t\t// information.\n\n\t\treturn elements.remove(element.getId());\n\t}\n\n\t/**\n\t * Push an event specifically for the given element. Events are stacked in\n\t * order. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element to modify with an event.\n\t * @param event\n\t *            The event to push.\n\t */\n\tprotected void pushEventFor(Element element, String event) {\n\t\tif (elements.containsKey(element.getId())) {\n\t\t\tif (eventsFor == null)\n\t\t\t\teventsFor = new HashMap<Element, ElementEvents>();\n\n\t\t\tElementEvents evs = eventsFor.get(element);\n\n\t\t\tif (evs == null) {\n\t\t\t\tevs = new ElementEvents(element, this, event);\n\t\t\t\teventsFor.put(element, evs);\n\t\t\t} else {\n\t\t\t\tevs.pushEvent(event);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Pop an event for the given element. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element.\n\t * @param event\n\t *            The event.\n\t */\n\tprotected void popEventFor(Element element, String event) {\n\t\tif (elements.containsKey(element.getId())) {\n\t\t\tElementEvents evs = eventsFor.get(element);\n\n\t\t\tif (evs != null) {\n\t\t\t\tevs.popEvent(event);\n\n\t\t\t\tif (evs.eventCount() == 0)\n\t\t\t\t\teventsFor.remove(element);\n\t\t\t}\n\n\t\t\tif (eventsFor.isEmpty())\n\t\t\t\teventsFor = null;\n\t\t}\n\t}\n\n\t/**\n\t * Before drawing an element that has events, use this method to activate\n\t * the events, the style values will be modified accordingly. Events for\n\t * this element must have been registered via\n\t * {@link #pushEventFor(Element, String)}. After rendering the\n\t * {@link #deactivateEvents()} MUST be called.\n\t * \n\t * @param element\n\t *            The element to push events for.\n\t */\n\tpublic void activateEventsFor(Element element) {\n\t\tElementEvents evs = eventsFor.get(element);\n\n\t\tif (evs != null && curEvents == null)\n\t\t\tcurEvents = evs.events();\n\t}\n\n\t/**\n\t * De-activate any events activated for an element. This method MUST be\n\t * called if {@link #activateEventsFor(Element)} has been called.\n\t */\n\tpublic void deactivateEvents() {\n\t\tcurEvents = null;\n\t}\n\n\t/**\n\t * Indicate the element has dynamic values and thus cannot be drawn in bulk\n\t * operations. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element.\n\t */\n\tprotected void pushElementAsDynamic(Element element) {\n\t\tif (dynamicOnes == null)\n\t\t\tdynamicOnes = new HashSet<Element>();\n\n\t\tdynamicOnes.add(element);\n\t}\n\n\t/**\n\t * Indicate the element has no more dynamic values and can be drawn in bulk\n\t * operations. Called by the GraphicElement.\n\t * \n\t * @param element\n\t *            The element.\n\t */\n\tprotected void popElementAsDynamic(Element element) {\n\t\tdynamicOnes.remove(element);\n\n\t\tif (dynamicOnes.isEmpty())\n\t\t\tdynamicOnes = null;\n\t}\n\n\t/**\n\t * Remove all graph elements of this group, and remove this group from the\n\t * group list of each style rule.\n\t */\n\tpublic void release() {\n\t\tfor (Rule rule : rules)\n\t\t\trule.removeGroup(id);\n\n\t\telements.clear();\n\t}\n\n\t/**\n\t * Redefinition of the {@link Style} to forbid changing the values.\n\t */\n\t@Override\n\tpublic void setValue(String property, Object value) {\n\t\tthrow new RuntimeException(\n\t\t\t\t\"you cannot change the values of a style group.\");\n\t}\n\n\t/**\n\t * Add a renderer to this group.\n\t * \n\t * @param id\n\t *            The renderer identifier.\n\t * @param renderer\n\t *            The renderer.\n\t */\n\tpublic void addRenderer(String id, SwingElementRenderer renderer) {\n\t\tif (renderers == null)\n\t\t\trenderers = new HashMap<String, SwingElementRenderer>();\n\n\t\trenderers.put(id, renderer);\n\t}\n\n\t/**\n\t * Remove a renderer.\n\t * \n\t * @param id\n\t *            The renderer identifier.\n\t * @return The removed renderer or null if not found.\n\t */\n\tpublic SwingElementRenderer removeRenderer(String id) {\n\t\treturn renderers.remove(id);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(-1);\n\t}\n\n\t@Override\n\tpublic String toString(int level) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tString prefix = \"\";\n\t\tString sprefix = \"    \";\n\n\t\tfor (int i = 0; i < level; i++)\n\t\t\tprefix += sprefix;\n\n\t\tbuilder.append(String.format(\"%s%s%n\", prefix, id));\n\t\tbuilder.append(String.format(\"%s%sContains : \", prefix, sprefix));\n\n\t\tfor (Element element : elements.values()) {\n\t\t\tbuilder.append(String.format(\"%s \", element.getId()));\n\t\t}\n\n\t\tbuilder.append(String.format(\"%n%s%sStyle : \", prefix, sprefix));\n\n\t\tfor (Rule rule : rules) {\n\t\t\tbuilder.append(String.format(\"%s \", rule.selector.toString()));\n\t\t}\n\n\t\tbuilder.append(String.format(\"%n\"));\n\n\t\treturn builder.toString();\n\t}\n\n\t// Nested classes\n\n\t/**\n\t * Description of an element that is actually modified by one or more events\n\t * occurring on it.\n\t */\n\tpublic static class ElementEvents {\n\t\t// Attribute\n\n\t\t/**\n\t\t * Set of events on the element.\n\t\t */\n\t\tprotected String events[];\n\n\t\t/**\n\t\t * The element.\n\t\t */\n\t\tprotected Element element;\n\n\t\t/**\n\t\t * The group the element pertains to.\n\t\t */\n\t\tprotected StyleGroup group;\n\n\t\t// Construction\n\n\t\tprotected ElementEvents(Element element, StyleGroup group, String event) {\n\t\t\tthis.element = element;\n\t\t\tthis.group = group;\n\t\t\tthis.events = new String[1];\n\n\t\t\tevents[0] = event;\n\t\t}\n\n\t\t// Access\n\n\t\t/**\n\t\t * The element on which the events are occurring.\n\t\t * \n\t\t * @return an element.\n\t\t */\n\t\tpublic Element getElement() {\n\t\t\treturn element;\n\t\t}\n\n\t\t/**\n\t\t * Number of events actually affecting the element.\n\t\t * \n\t\t * @return The number of events affecting the element.\n\t\t */\n\t\tpublic int eventCount() {\n\t\t\tif (events == null)\n\t\t\t\treturn 0;\n\n\t\t\treturn events.length;\n\t\t}\n\n\t\t/**\n\t\t * The set of events actually occurring on the element.\n\t\t * \n\t\t * @return A set of strings.\n\t\t */\n\t\tpublic String[] events() {\n\t\t\treturn events;\n\t\t}\n\n\t\t// Command\n\n\t\tpublic void activate() {\n\t\t\tgroup.activateEventsFor(element);\n\t\t}\n\n\t\tpublic void deactivate() {\n\t\t\tgroup.deactivateEvents();\n\t\t}\n\n\t\tprotected void pushEvent(String event) {\n\t\t\tint n = events.length + 1;\n\t\t\tString e[] = new String[n];\n\t\t\tboolean found = false;\n\n\t\t\tfor (int i = 0; i < events.length; i++) {\n\t\t\t\tif (!events[i].equals(event))\n\t\t\t\t\te[i] = events[i];\n\t\t\t\telse\n\t\t\t\t\tfound = true;\n\t\t\t}\n\n\t\t\te[events.length] = event;\n\n\t\t\tif (!found)\n\t\t\t\tevents = e;\n\t\t}\n\n\t\tprotected void popEvent(String event) {\n\t\t\tif (events.length > 1) {\n\t\t\t\tString e[] = new String[events.length - 1];\n\t\t\t\tboolean found = false;\n\n\t\t\t\tfor (int i = 0, j = 0; i < events.length; i++) {\n\t\t\t\t\tif (!events[i].equals(event)) {\n\t\t\t\t\t\tif (j < e.length) {\n\t\t\t\t\t\t\te[j++] = events[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (found)\n\t\t\t\t\tevents = e;\n\t\t\t} else {\n\t\t\t\tif (events[0].equals(event)) {\n\t\t\t\t\tevents = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\tbuilder.append(String.format(\"%s events {\", element.getId()));\n\t\t\tfor (String event : events)\n\t\t\t\tbuilder.append(String.format(\" %s\", event));\n\t\t\tbuilder.append(\" }\");\n\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Virtual set on the elements that have not dynamic style value or event.\n\t */\n\tprotected class BulkElements implements Iterable<Element> {\n\t\tpublic Iterator<Element> iterator() {\n\t\t\treturn new BulkIterator(elements.values().iterator());\n\t\t}\n\t}\n\n\t/**\n\t * Iterator on the set of elements that have no event or dynamic style\n\t * values.\n\t */\n\tprotected class BulkIterator implements Iterator<Element> {\n\t\t/**\n\t\t * Iterator on the set of all elements.\n\t\t */\n\t\tprotected Iterator<Element> iterator;\n\n\t\t/**\n\t\t * The next element without event or dynamic style.value.\n\t\t */\n\t\tElement next;\n\n\t\t/**\n\t\t * New bulk iterator positioned on the first element with no event or\n\t\t * dynamic style attribute.\n\t\t * \n\t\t * @param iterator\n\t\t *            Iterator on the set of all elements.\n\t\t */\n\t\tpublic BulkIterator(Iterator<Element> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t\tboolean loop = true;\n\n\t\t\twhile (loop && iterator.hasNext()) {\n\t\t\t\tnext = iterator.next();\n\n\t\t\t\tif (!elementHasEvents(next) && !elementIsDynamic(next))\n\t\t\t\t\tloop = false;\n\t\t\t\telse\n\t\t\t\t\tnext = null;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\treturn (next != null);\n\t\t}\n\n\t\tpublic Element next() {\n\t\t\tElement e = next;\n\t\t\tboolean loop = true;\n\n\t\t\tnext = null;\n\n\t\t\twhile (loop && iterator.hasNext()) {\n\t\t\t\tnext = iterator.next();\n\n\t\t\t\tif (!elementIsDynamic(next) && !elementHasEvents(next))\n\t\t\t\t\tloop = false;\n\t\t\t\telse\n\t\t\t\t\tnext = null;\n\t\t\t}\n\n\t\t\treturn e;\n\t\t}\n\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"this iterator does not allows removing elements\");\n\t\t}\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "id",
                "java.lang",
                "String"
            ],
            [
                "renderer",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement.SwingElementRenderer"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getTextColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getTextColor(int arg0)"
            ],
            [
                "getEventsFor",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Set of events for a given element or null if the element has not\n * currently occurring events.\n *\n * @return A set of events or null if none occurring at that time.\n */\npublic ElementEvents getEventsFor(Element element) {\n    if (eventsFor != null)\n        return eventsFor.get(element);\n    return null;\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getTextPadding",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getTextPadding()"
            ],
            [
                "bulkElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Iterable set of elements that can be drawn in a bulk operation, that is\n * the subset of all elements that are not dynamic or modified by an event.\n *\n * @return The iterable set of bulk elements.\n */\npublic Iterable<? extends Element> bulkElements() {\n    return bulkElements;\n}"
            ],
            [
                "getFillImage",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getFillImage()"
            ],
            [
                "getStrokeWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Value getStrokeWidth()"
            ],
            [
                "elementsEvents",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Subset of elements that are actually modified by one or more events. The\n * {@link ElementEvents} class contains the element and an array of events\n * that can be pushed on the style group set.\n *\n * @return The subset of elements modified by one or more events.\n */\npublic Iterable<ElementEvents> elementsEvents() {\n    return eventsFor.values();\n}"
            ],
            [
                "getId",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "// Access\n/**\n * The group unique identifier.\n *\n * @return A style group identifier.\n */\npublic String getId() {\n    return id;\n}"
            ],
            [
                "getVisibilityMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.VisibilityMode getVisibilityMode()"
            ],
            [
                "getTextSize",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Value getTextSize()"
            ],
            [
                "getShadowOffset",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getShadowOffset()"
            ],
            [
                "getFillMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.FillMode getFillMode()"
            ],
            [
                "getValueForEvent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected Object getValueForEvent(String arg0, String arg1)"
            ],
            [
                "getTextVisibility",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getTextVisibility()"
            ],
            [
                "getCanvasColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getCanvasColor(int arg0)"
            ],
            [
                "getZIndex",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Integer getZIndex()"
            ],
            [
                "contains",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the group contains the element whose identifier is given.\n *\n * @param elementId\n *            The element to search.\n * @return true if the element is in the group.\n */\npublic boolean contains(String elementId) {\n    return elements.containsKey(elementId);\n}"
            ],
            [
                "getArrowSize",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getArrowSize()"
            ],
            [
                "getParent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Rule getParent()"
            ],
            [
                "getShadowColors",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getShadowColors()"
            ],
            [
                "removeRenderer",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Remove a renderer.\n *\n * @param id\n *            The renderer identifier.\n * @return The removed renderer or null if not found.\n */\npublic SwingElementRenderer removeRenderer(String id) {\n    return renderers.remove(id);\n}"
            ],
            [
                "getElement",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Return an element of the group, knowing its identifier.\n *\n * @param id\n *            The searched element identifier.\n * @return The element corresponding to the identifier or null if not found.\n */\npublic Element getElement(String id) {\n    return elements.get(id);\n}"
            ],
            [
                "getPadding",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getPadding()"
            ],
            [
                "hasEventElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * If true this group contains some elements that are actually changed by an\n * event. Such elements cannot therefore be drawn in a group operation, but\n * one by one.\n *\n * @return True if the group contains some elements changed by an event.\n */\npublic boolean hasEventElements() {\n    return (eventsFor != null && eventsFor.size() > 0);\n}"
            ],
            [
                "getSizeMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.SizeMode getSizeMode()"
            ],
            [
                "contains",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the group contains the element given.\n *\n * @param element\n *            The element to search.\n * @return true if the element is in the group.\n */\npublic boolean contains(Element element) {\n    return elements.containsKey(element.getId());\n}"
            ],
            [
                "getTextBackgroundColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getTextBackgroundColor()"
            ],
            [
                "getFillColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getFillColor(int arg0)"
            ],
            [
                "getStrokeColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getStrokeColorCount()"
            ],
            [
                "isElementDynamic",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Test if an element is pushed as dynamic.\n */\npublic boolean isElementDynamic(Element element) {\n    if (dynamicOnes != null)\n        return dynamicOnes.contains(element);\n    return false;\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getElementCount",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The number of elements of the group.\n *\n * @return The element count.\n */\npublic int getElementCount() {\n    return elements.size();\n}"
            ],
            [
                "getShapePoints",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getShapePoints()"
            ],
            [
                "getStrokeColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getStrokeColor(int arg0)"
            ],
            [
                "getRenderer",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The associated renderers.\n *\n * @return A renderer or null if not found.\n */\npublic SwingElementRenderer getRenderer(String id) {\n    if (renderers != null)\n        return renderers.get(id);\n    return null;\n}"
            ],
            [
                "getJComponent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.JComponents getJComponent()"
            ],
            [
                "getCanvasColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getCanvasColorCount()"
            ],
            [
                "getArrowImage",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getArrowImage()"
            ],
            [
                "getTextBackgroundColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getTextBackgroundColor(int arg0)"
            ],
            [
                "getIconMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.IconMode getIconMode()"
            ],
            [
                "getTextColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getTextColorCount()"
            ],
            [
                "getTextAlignment",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextAlignment getTextAlignment()"
            ],
            [
                "getIcon",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getIcon()"
            ],
            [
                "getStrokeMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.StrokeMode getStrokeMode()"
            ],
            [
                "getVisibility",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getVisibility()"
            ],
            [
                "getFillColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getFillColorCount()"
            ],
            [
                "getShadowColorCount",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public int getShadowColorCount()"
            ],
            [
                "getFillColors",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getFillColors()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hasValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public transient boolean hasValue(String arg0, String[] arg1)"
            ],
            [
                "iterator",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "public Iterator<Element> iterator() {\n    return elements.values().iterator();\n}"
            ],
            [
                "getShape",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.Shape getShape()"
            ],
            [
                "getTextStyle",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextStyle getTextStyle()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getShadowMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.ShadowMode getShadowMode()"
            ],
            [
                "toString",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "@Override\npublic String toString(int level) {\n    StringBuilder builder = new StringBuilder();\n    String prefix = \"\";\n    String sprefix = \"    \";\n    for (int i = 0; i < level; i++) prefix += sprefix;\n    builder.append(String.format(\"%s%s%n\", prefix, id));\n    builder.append(String.format(\"%s%sContains : \", prefix, sprefix));\n    for (Element element : elements.values()) {\n        builder.append(String.format(\"%s \", element.getId()));\n    }\n    builder.append(String.format(\"%n%s%sStyle : \", prefix, sprefix));\n    for (Rule rule : rules) {\n        builder.append(String.format(\"%s \", rule.selector.toString()));\n    }\n    builder.append(String.format(\"%n\"));\n    return builder.toString();\n}"
            ],
            [
                "getArrowShape",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.ArrowShape getArrowShape()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "elementHasEvents",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the given element actually has active events.\n *\n * @param element\n *            The element to test.\n * @return True if the element has actually active events.\n */\npublic boolean elementHasEvents(Element element) {\n    return (eventsFor != null && eventsFor.containsKey(element));\n}"
            ],
            [
                "removeElement",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Remove a graph element from the group.\n *\n * @param element\n *            The element to remove.\n * @return The removed element, or null if the element was not found.\n */\npublic Element removeElement(Element element) {\n    if (eventsFor != null && eventsFor.containsKey(element))\n        // Remove an eventual remaining event.\n        eventsFor.remove(element);\n    if (dynamicOnes != null && dynamicOnes.contains(element))\n        // Remove an eventual remaining dynamic\n        dynamicOnes.remove(element);\n    // information.\n    return elements.remove(element.getId());\n}"
            ],
            [
                "getCanvasColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getCanvasColor()"
            ],
            [
                "getTextFont",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public String getTextFont()"
            ],
            [
                "getShadowColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Color getShadowColor(int arg0)"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "dynamicElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Subset of elements that have dynamic style values and therefore must be\n * rendered one by one, not in groups like others. Even though elements\n * style can specify some dynamics, the elements must individually have\n * attributes that specify the dynamic value. If the elements do not have\n * these attributes they can be rendered in bulk operations.\n *\n * @return The subset of dynamic elements of the group.\n */\npublic Iterable<Element> dynamicElements() {\n    return dynamicOnes;\n}"
            ],
            [
                "toString",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "@Override\npublic String toString() {\n    return toString(-1);\n}"
            ],
            [
                "getTextBackgroundMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextBackgroundMode getTextBackgroundMode()"
            ],
            [
                "getType",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Type of graph element concerned by this style (node, edge, sprite,\n * graph).\n *\n * @return The type of the style group elements.\n */\npublic Selector.Type getType() {\n    return rules.get(0).selector.type;\n}"
            ],
            [
                "getShadowWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Value getShadowWidth()"
            ],
            [
                "elementIsDynamic",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if the given element has dynamic style values provided by specific\n * attributes.\n *\n * @param element\n *            The element to test.\n * @return True if the element has actually specific style attributes.\n */\npublic boolean elementIsDynamic(Element element) {\n    return (dynamicOnes != null && dynamicOnes.contains(element));\n}"
            ],
            [
                "getValue",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Get the value of a given property.\n *\n * This is a redefinition of the method in {@link Style} to consider the\n * fact a style group aggregates several style rules.\n *\n * @param property\n *            The style property the value is searched for.\n */\n@Override\npublic Object getValue(String property, String... events) {\n    int n = rules.size();\n    if (events == null || events.length == 0) {\n        if (curEvents != null && curEvents.length > 0) {\n            events = curEvents;\n        } else if (eventSet.events != null && eventSet.events.length > 0) {\n            events = eventSet.events;\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        Style style = rules.get(i).getStyle();\n        if (style.hasValue(property, events))\n            return style.getValue(property, events);\n    }\n    return rules.get(0).getStyle().getValue(property, events);\n}"
            ],
            [
                "elements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Iterable set of elements. This the complete set of elements contained in\n * this group without regard to the fact they are modified by an event or\n * are dynamic. If you plan to respect events or dynamic elements, you must\n * check the elements are not modified by events using\n * {@link #elementHasEvents(Element)} and are not dynamic by using\n * {@link #elementIsDynamic(Element)} and then draw modified elements using\n * {@link #elementsEvents()} and {@link #dynamicElements()}. But the easiest\n * way of drawing is to use first {@link #bulkElements()} for all non\n * dynamic non event elements, then the {@link #dynamicElements()} and\n * {@link #elementsEvents()} to draw all dynamic and event elements.\n *\n * @return All the elements in no particular order.\n */\npublic Iterable<? extends Element> elements() {\n    return elements.values();\n}"
            ],
            [
                "getSpriteOrientation",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.SpriteOrientation getSpriteOrientation()"
            ],
            [
                "getTextColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getTextColor()"
            ],
            [
                "getTextMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextMode getTextMode()"
            ],
            [
                "isEmpty",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if there are no elements in the group.\n *\n * @return True if the group is empty of elements.\n */\npublic boolean isEmpty() {\n    return elements.isEmpty();\n}"
            ],
            [
                "getSize",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getSize()"
            ],
            [
                "getTextOffset",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Values getTextOffset()"
            ],
            [
                "hasDynamicElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * True if at least one of the style properties is dynamic (set according to\n * an attribute of the element to draw). Such elements cannot therefore be\n * drawn in a group operation, but one by one.\n *\n * @return True if one property is dynamic.\n */\npublic boolean hasDynamicElements() {\n    return (dynamicOnes != null && dynamicOnes.size() > 0);\n}"
            ],
            [
                "getStrokeColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public Colors getStrokeColor()"
            ],
            [
                "getElementIterator",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Iterator on the set of graph elements of this group.\n *\n * @return The elements iterator.\n */\npublic Iterator<? extends Element> getElementIterator() {\n    return elements.values().iterator();\n}"
            ],
            [
                "getTextVisibilityMode",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "public StyleConstants.TextVisibilityMode getTextVisibilityMode()"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "id",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "// Attribute\n/**\n * The group unique identifier.\n */\nprotected String id;"
            ],
            [
                "rules",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The set of style rules.\n */\nprotected ArrayList<Rule> rules = new ArrayList<Rule>();"
            ],
            [
                "elements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Graph elements of this group.\n */\nprotected HashMap<String, Element> elements = new HashMap<String, Element>();"
            ],
            [
                "eventSet",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The global events actually occurring.\n */\nprotected StyleGroupSet.EventSet eventSet;"
            ],
            [
                "eventsFor",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Set of elements whose style is actually modified individually by an\n * event. Such elements must be rendered one by one, not in groups like\n * others.\n */\nprotected HashMap<Element, ElementEvents> eventsFor;"
            ],
            [
                "dynamicOnes",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Set of elements that have some dynamic style values. Such elements must\n * be rendered one by one, not in groups, like others.\n */\nprotected HashSet<Element> dynamicOnes;"
            ],
            [
                "curEvents",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * A set of events actually pushed only for this group.\n */\nprotected String[] curEvents;"
            ],
            [
                "bulkElements",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * The set of bulk elements.\n */\nprotected BulkElements bulkElements = new BulkElements();"
            ],
            [
                "renderers",
                "org.graphstream.ui.graphicGraph",
                "StyleGroup",
                "/**\n * Associated renderers.\n */\npublic HashMap<String, SwingElementRenderer> renderers;"
            ],
            [
                "parent",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected Rule parent;"
            ],
            [
                "values",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected HashMap<String, Object> values;"
            ],
            [
                "alternates",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "Style",
                "protected HashMap<String, Rule> alternates;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3170,
        "oracle": "graph.getNode(id) == null;",
        "oracleType": "EXCEPT_POST",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.ui.graphicGraph",
        "className": "GraphPosLengthUtils",
        "javadocTag": "@throws RuntimeException If the node with the given identifier does not exist.",
        "methodJavadoc": "    /**\n\t * Like {@link #nodePointPosition(Graph,String)}, but instead of returning a\n\t * newly allocated array, fill up the array given as parameter. This array\n\t * must have at least three cells.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t * @throws RuntimeException\n\t *             If the node with the given identifier does not exist.\n\t */",
        "methodSourceCode": "public static void nodePosition(Graph graph, String id, Point3 pos){\n    Node node = graph.getNode(id);\n    if (node != null)\n        nodePosition(node, pos);\n    throw new RuntimeException(\"node '\" + id + \"' does not exist\");\n}",
        "classJavadoc": "/**\n * Lots of small often used measuring algorithms on graphs.\n * \n * <p>\n * Use this class with a static import.\n * </p>\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.ui.graphicGraph;\n\nimport org.graphstream.graph.Edge;\nimport org.graphstream.graph.Graph;\nimport org.graphstream.graph.Node;\nimport org.graphstream.ui.geom.Point2;\nimport org.graphstream.ui.geom.Point3;\nimport org.graphstream.ui.geom.Vector2;\nimport org.graphstream.ui.geom.Vector3;\n\nimport java.util.logging.Logger;\n\n/**\n * Lots of small often used measuring algorithms on graphs.\n * \n * <p>\n * Use this class with a static import.\n * </p>\n */\npublic class GraphPosLengthUtils {\n\n    /**\n     * class level logger\n     */\n    private static final Logger logger = Logger.getLogger(GraphPosLengthUtils.class.getSimpleName());\n\n\t/**\n\t * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n\t * \"xyz\").\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @return A newly allocated array of three floats containing the (x,y,z)\n\t *         position of the node, or null if the node is not part of the\n\t *         graph.\n\t */\n\tpublic static double[] nodePosition(Graph graph, String id) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\treturn nodePosition(node);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n\t * \"xyz\").\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @return A newly allocated point containing the (x,y,z)\n\t *         position of the node, or null if the node is not part of the\n\t *         graph.\n\t */\n\tpublic static Point3 nodePointPosition(Graph graph, String id) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\treturn nodePointPosition(node);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String)} but use an existing node as\n\t * argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @return A newly allocated array of three floats containing the (x,y,z)\n\t *         position of the node.\n\t */\n\tpublic static double[] nodePosition(Node node) {\n\t\tdouble xyz[] = new double[3];\n\n\t\tnodePosition(node, xyz);\n\n\t\treturn xyz;\n\t}\n\n\t/**\n\t * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n\t * argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @return A newly allocated point containing the (x,y,z)\n\t *         position of the node.\n\t */\n\tpublic static Point3 nodePointPosition(Node node) {\n\t\tPoint3 pos = new Point3();\n\n\t\tnodePosition(node, pos);\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String)}, but instead of returning a\n\t * newly allocated array, fill up the array given as parameter. This array\n\t * must have at least three cells.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param xyz\n\t *            An array of at least three cells.\n\t * @throws RuntimeException\n\t *             If the node with the given identifier does not exist.\n\t */\n\tpublic static void nodePosition(Graph graph, String id, double xyz[]) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\tnodePosition(node, xyz);\n\n\t\tthrow new RuntimeException(\"node '\" + id + \"' does not exist\");\n\t}\n\t\n\t/**\n\t * Like {@link #nodePointPosition(Graph,String)}, but instead of returning a\n\t * newly allocated array, fill up the array given as parameter. This array\n\t * must have at least three cells.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t * @throws RuntimeException\n\t *             If the node with the given identifier does not exist.\n\t */\n\tpublic static void nodePosition(Graph graph, String id, Point3 pos) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\tnodePosition(node, pos);\n\n\t\tthrow new RuntimeException(\"node '\" + id + \"' does not exist\");\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String,double[])} but use an existing node\n\t * as argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @param xyz\n\t *            An array of at least three cells.\n\t */\n\tpublic static void nodePosition(Node node, double xyz[]) {\n\t\tif (xyz.length < 3)\n\t\t\treturn;\n\n\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n\t\t\tObject o = node.getAttribute(\"xyz\");\n\n\t\t\tif (o == null)\n\t\t\t\to = node.getAttribute(\"xy\");\n\n\t\t\tif (o != null) {\n\t\t\t\tpositionFromObject(o, xyz);\n\t\t\t}\n\t\t\t\n\t\t} else if (node.hasAttribute(\"x\")) {\n\t\t\txyz[0] = (double) node.getNumber(\"x\");\n\n\t\t\tif (node.hasAttribute(\"y\"))\n\t\t\t\txyz[1] = (double) node.getNumber(\"y\");\n\n\t\t\tif (node.hasAttribute(\"z\"))\n\t\t\t\txyz[2] = (double) node.getNumber(\"z\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Like {@link #nodePosition(Graph,String,Point3)} but use an existing node\n\t * as argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t */\n\tpublic static void nodePosition(Node node, Point3 pos) {\n\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n\t\t\tObject o = node.getAttribute(\"xyz\");\n\n\t\t\tif (o == null)\n\t\t\t\to = node.getAttribute(\"xy\");\n\n\t\t\tif (o != null) {\n\t\t\t\tpositionFromObject(o, pos);\n\t\t\t}\n\t\t} else if (node.hasAttribute(\"x\")) {\n\t\t\tpos.x = (double) node.getNumber(\"x\");\n\n\t\t\tif (node.hasAttribute(\"y\"))\n\t\t\t\tpos.y = (double) node.getNumber(\"y\");\n\n\t\t\tif (node.hasAttribute(\"z\"))\n\t\t\t\tpos.z = (double) node.getNumber(\"z\");\n\t\t}\n\n//\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n//\t\t\tObject o = node.getAttribute(\"xyz\");\n//\n//\t\t\tif (o == null)\n//\t\t\t\to = node.getAttribute(\"xy\");\n//\n//\t\t\tif (o != null && o instanceof Object[]) {\n//\t\t\t\tObject oo[] = (Object[]) o;\n//\n//\t\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n//\t\t\t\t\tpos.x = ((Number) oo[0]).doubleValue();\n//\n//\t\t\t\t\tif (oo.length > 1)\n//\t\t\t\t\t\tpos.y = ((Number) oo[1]).doubleValue();\n//\t\t\t\t\tif (oo.length > 2)\n//\t\t\t\t\t\tpos.z = ((Number) oo[2]).doubleValue();\n//\t\t\t\t}\n//\t\t\t}\n//\t\t} else if (node.hasAttribute(\"x\")) {\n//\t\t\tpos.x = (double) node.getNumber(\"x\");\n//\n//\t\t\tif (node.hasAttribute(\"y\"))\n//\t\t\t\tpos.y = (double) node.getNumber(\"y\");\n//\n//\t\t\tif (node.hasAttribute(\"z\"))\n//\t\t\t\tpos.z = (double) node.getNumber(\"z\");\n//\t\t}\n\t}\n\t\n\t/**\n\t * Try to convert an object to a position. The object can be an array of \n\t * numbers, an array of base numeric types or their object counterparts.\n\t * @param o The object to try to convert.\n\t * @param xyz The result.\n\t */\n\tpublic static void positionFromObject(Object o, double xyz[]) {\n\t\tif(o instanceof Object[]) {\n\t\t\tObject oo[] = (Object[]) o;\n\n\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n\t\t\t\txyz[0] = ((Number) oo[0]).doubleValue();\n\t\t\t\tif (oo.length > 1) xyz[1] = ((Number) oo[1]).doubleValue();\n\t\t\t\tif (oo.length > 2) xyz[2] = ((Number) oo[2]).doubleValue();\n\t\t\t}\n\t\t} else if(o instanceof Double[]) {\n\t\t\tDouble oo[] = (Double[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Float[]) {\n\t\t\tFloat oo[] = (Float[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Integer[]) {\n\t\t\tInteger oo[] = (Integer[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof double[]) {\n\t\t\tdouble oo[] = (double[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof float[]) {\n\t\t\tfloat oo[] = (float[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof int[]) {\n\t\t\tint oo[] = (int[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Number[]) {\n\t\t\tNumber oo[] = (Number[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0].doubleValue();\n\t\t\tif(oo.length > 1) xyz[1] = oo[1].doubleValue();\n\t\t\tif(oo.length > 2) xyz[2] = oo[2].doubleValue();\n\t\t} else if(o instanceof Point3) {\n\t\t\tPoint3 oo = (Point3) o;\n\t\t\txyz[0] = oo.x;\n\t\t\txyz[1] = oo.y;\n\t\t\txyz[2] = oo.z;\n\t\t} else if(o instanceof Vector3) {\n\t\t\tVector3 oo = (Vector3) o;\n\t\t\txyz[0] = oo.data[0];\n\t\t\txyz[1] = oo.data[1];\n\t\t\txyz[2] = oo.data[2];\n\t\t} else if(o instanceof Point2) {\n\t\t\tPoint2 oo = (Point2) o;\n\t\t\txyz[0] = oo.x;\n\t\t\txyz[1] = oo.y;\n\t\t\txyz[2] = 0;\n\t\t} else if(o instanceof Vector2) {\n\t\t\tVector2 oo = (Vector2) o;\n\t\t\txyz[0] = oo.data[0];\n\t\t\txyz[1] = oo.data[1];\n\t\t\txyz[2] = 0;\n\t\t} else {\n\t\t\tlogger.warning(String.format(\"Do not know how to handle xyz attribute %s.\", o.getClass().getName()));\n\t\t}\n\t}\n\t\n\t/**\n\t * Try to convert an object to a position. The object can be an array of \n\t * numbers, an array of base numeric types or their object counterparts.\n\t * @param o The object to try to convert.\n\t * @param pos The result.\n\t */\n\tpublic static void positionFromObject(Object o, Point3 pos) {\n\t\tif(o instanceof Object[]) {\n\t\t\tObject oo[] = (Object[]) o;\n\n\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n\t\t\t\tpos.x = ((Number) oo[0]).doubleValue();\n\t\t\t\tif (oo.length > 1) pos.y = ((Number) oo[1]).doubleValue();\n\t\t\t\tif (oo.length > 2) pos.z = ((Number) oo[2]).doubleValue();\n\t\t\t}\n\t\t} else if(o instanceof Double[]) {\n\t\t\tDouble oo[] = (Double[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Float[]) {\n\t\t\tFloat oo[] = (Float[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Integer[]) {\n\t\t\tInteger oo[] = (Integer[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof double[]) {\n\t\t\tdouble oo[] = (double[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof float[]) {\n\t\t\tfloat oo[] = (float[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof int[]) {\n\t\t\tint oo[] = (int[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Number[]) {\n\t\t\tNumber oo[] = (Number[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0].doubleValue();\n\t\t\tif(oo.length > 1) pos.y = oo[1].doubleValue();\n\t\t\tif(oo.length > 2) pos.z = oo[2].doubleValue();\n\t\t} else if(o instanceof Point3) {\n\t\t\tPoint3 oo = (Point3) o;\n\t\t\tpos.x = oo.x;\n\t\t\tpos.y = oo.y;\n\t\t\tpos.z = oo.z;\n\t\t} else if(o instanceof Vector3) {\n\t\t\tVector3 oo = (Vector3) o;\n\t\t\tpos.x = oo.data[0];\n\t\t\tpos.y = oo.data[1];\n\t\t\tpos.z = oo.data[2];\n\t\t} else if(o instanceof Point2) {\n\t\t\tPoint2 oo = (Point2) o;\n\t\t\tpos.x = oo.x;\n\t\t\tpos.y = oo.y;\n\t\t\tpos.z = 0;\n\t\t} else if(o instanceof Vector2) {\n\t\t\tVector2 oo = (Vector2) o;\n\t\t\tpos.x = oo.data[0];\n\t\t\tpos.y = oo.data[1];\n\t\t\tpos.z = 0;\n\t\t} else {\n            logger.warning(String.format(\"Do not know how to handle xyz attribute %s%n\", o.getClass().getName()));\n\t\t}\n\t}\n\n\t/**\n\t * Compute the edge length of the given edge according to its two nodes\n\t * positions.\n\t * \n\t * @param id\n\t *            The identifier of the edge.\n\t * @return The edge length or -1 if the nodes of the edge have no positions.\n\t * @throws RuntimeException\n\t *             If the edge cannot be found.\n\t */\n\tpublic static double edgeLength(Graph graph, String id) {\n\t\tEdge edge = graph.getEdge(id);\n\n\t\tif (edge != null)\n\t\t\treturn edgeLength(edge);\n\n\t\tthrow new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n\t}\n\n\t/**\n\t * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n\t * argument.\n\t * \n\t * @param edge\n\t * @return The edge length or -1 if the nodes of the edge have no positions.\n\t */\n\tpublic static double edgeLength(Edge edge) {\n\t\tdouble xyz0[] = nodePosition(edge.getNode0());\n\t\tdouble xyz1[] = nodePosition(edge.getNode1());\n\n\t\tif (xyz0 == null || xyz1 == null)\n\t\t\treturn -1;\n\n\t\txyz0[0] = xyz1[0] - xyz0[0];\n\t\txyz0[1] = xyz1[1] - xyz0[1];\n\t\txyz0[2] = xyz1[2] - xyz0[2];\n\n\t\treturn Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1]\n\t\t\t\t+ xyz0[2] * xyz0[2]);\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "graph",
                "org.graphstream.graph",
                "Graph"
            ],
            [
                "id",
                "java.lang",
                "String"
            ],
            [
                "pos",
                "org.graphstream.ui.geom",
                "Point3"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getNode(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "display",
                "org.graphstream.graph",
                "Graph",
                "public abstract Viewer display(boolean arg0)"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, String arg1, String arg2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException"
            ],
            [
                "nodeFactory",
                "org.graphstream.graph",
                "Graph",
                "public abstract NodeFactory<? extends Node> nodeFactory()"
            ],
            [
                "display",
                "org.graphstream.graph",
                "Graph",
                "public abstract Viewer display()"
            ],
            [
                "elementSinks",
                "org.graphstream.graph",
                "Graph",
                "public abstract Iterable<ElementSink> elementSinks()"
            ],
            [
                "edgeFactory",
                "org.graphstream.graph",
                "Graph",
                "public abstract EdgeFactory<? extends Edge> edgeFactory()"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, Node arg1, Node arg2, boolean arg3) throws IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "getNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getNode(String arg0)"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(Edge arg0)"
            ],
            [
                "removeNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeNode(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "removeNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeNode(Node arg0)"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(String arg0) throws ElementNotFoundException"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "removeNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeNode(String arg0) throws ElementNotFoundException"
            ],
            [
                "nullAttributesAreErrors",
                "org.graphstream.graph",
                "Graph",
                "public abstract boolean nullAttributesAreErrors()"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(Node arg0, Node arg1) throws ElementNotFoundException"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(int arg0, int arg1) throws IndexOutOfBoundsException, ElementNotFoundException"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, int arg1, int arg2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "getEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getEdge(String arg0)"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, Node arg1, Node arg2) throws IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "attributeSinks",
                "org.graphstream.graph",
                "Graph",
                "public abstract Iterable<AttributeSink> attributeSinks()"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(String arg0, String arg1) throws ElementNotFoundException"
            ],
            [
                "isAutoCreationEnabled",
                "org.graphstream.graph",
                "Graph",
                "public abstract boolean isAutoCreationEnabled()"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, int arg1, int arg2, boolean arg3) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "isStrict",
                "org.graphstream.graph",
                "Graph",
                "public abstract boolean isStrict()"
            ],
            [
                "addNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addNode(String arg0) throws IdAlreadyInUseException"
            ],
            [
                "getEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getEdge(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, String arg1, String arg2, boolean arg3) throws IdAlreadyInUseException, ElementNotFoundException"
            ],
            [
                "getStep",
                "org.graphstream.graph",
                "Graph",
                "public abstract double getStep()"
            ],
            [
                "getVector",
                "org.graphstream.graph",
                "Element",
                "public abstract ArrayList<? extends Number> getVector(String arg0)"
            ],
            [
                "getLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract CharSequence getLabel(String arg0)"
            ],
            [
                "getEachAttributeKey",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterable<String> getEachAttributeKey()"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)"
            ],
            [
                "getId",
                "org.graphstream.graph",
                "Element",
                "public abstract String getId()"
            ],
            [
                "hasHash",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasHash(String arg0)"
            ],
            [
                "getAttributeCount",
                "org.graphstream.graph",
                "Element",
                "public abstract int getAttributeCount()"
            ],
            [
                "getAttributeKeySet",
                "org.graphstream.graph",
                "Element",
                "public abstract Collection<String> getAttributeKeySet()"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(String[] arg0)"
            ],
            [
                "getArray",
                "org.graphstream.graph",
                "Element",
                "public abstract Object[] getArray(String arg0)"
            ],
            [
                "hasArray",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasArray(String arg0)"
            ],
            [
                "getHash",
                "org.graphstream.graph",
                "Element",
                "public abstract HashMap<?, ?> getHash(String arg0)"
            ],
            [
                "getNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract double getNumber(String arg0)"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0, Class<?> arg1)"
            ],
            [
                "getIndex",
                "org.graphstream.graph",
                "Element",
                "public abstract int getIndex()"
            ],
            [
                "hasNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasNumber(String arg0)"
            ],
            [
                "hasVector",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasVector(String arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0)"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0, Class<T> arg1)"
            ],
            [
                "hasLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasLabel(String arg0)"
            ],
            [
                "getAttributeKeyIterator",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterator<String> getAttributeKeyIterator()"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "getNodeSet",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Collection<T> getNodeSet()"
            ],
            [
                "getEdgeSet",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Collection<T> getEdgeSet()"
            ],
            [
                "getEachEdge",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterable<? extends T> getEachEdge()"
            ],
            [
                "getEdgeCount",
                "org.graphstream.graph",
                "Structure",
                "public abstract int getEdgeCount()"
            ],
            [
                "getEdgeIterator",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterator<T> getEdgeIterator()"
            ],
            [
                "getNodeCount",
                "org.graphstream.graph",
                "Structure",
                "public abstract int getNodeCount()"
            ],
            [
                "getNodeIterator",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterator<T> getNodeIterator()"
            ],
            [
                "getEachNode",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterable<? extends T> getEachNode()"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ],
            [
                "equals",
                "org.graphstream.ui.geom",
                "Point3",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "org.graphstream.ui.geom",
                "Point3",
                "public int hashCode()"
            ],
            [
                "isZero",
                "org.graphstream.ui.geom",
                "Point3",
                "public boolean isZero()"
            ],
            [
                "distance",
                "org.graphstream.ui.geom",
                "Point3",
                "public double distance(double arg0, double arg1, double arg2)"
            ],
            [
                "toString",
                "org.graphstream.ui.geom",
                "Point3",
                "public String toString()"
            ],
            [
                "distance",
                "org.graphstream.ui.geom",
                "Point3",
                "public double distance(Point3 arg0)"
            ],
            [
                "interpolate",
                "org.graphstream.ui.geom",
                "Point3",
                "public Point3 interpolate(Point3 arg0, double arg1)"
            ],
            [
                "hashCode",
                "org.graphstream.ui.geom",
                "Point2",
                "public int hashCode()"
            ],
            [
                "distance",
                "org.graphstream.ui.geom",
                "Point2",
                "public double distance(Point2 arg0)"
            ],
            [
                "toString",
                "org.graphstream.ui.geom",
                "Point2",
                "public String toString()"
            ],
            [
                "equals",
                "org.graphstream.ui.geom",
                "Point2",
                "public boolean equals(Object arg0)"
            ],
            [
                "isZero",
                "org.graphstream.ui.geom",
                "Point2",
                "public boolean isZero()"
            ],
            [
                "interpolate",
                "org.graphstream.ui.geom",
                "Point2",
                "public Point2 interpolate(Point2 arg0, double arg1)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "z",
                "org.graphstream.ui.geom",
                "Point3",
                "public double z;"
            ],
            [
                "x",
                "org.graphstream.ui.geom",
                "Point2",
                "public double x;"
            ],
            [
                "y",
                "org.graphstream.ui.geom",
                "Point2",
                "public double y;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3174,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.ui.graphicGraph",
        "className": "GraphPosLengthUtils",
        "javadocTag": "@param pos A point that will receive the node position.",
        "methodJavadoc": "    /**\n\t * Like {@link #nodePosition(Graph,String,Point3)} but use an existing node\n\t * as argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t */",
        "methodSourceCode": "public static void nodePosition(Node node, Point3 pos){\n    if (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n        Object o = node.getAttribute(\"xyz\");\n        if (o == null)\n            o = node.getAttribute(\"xy\");\n        if (o != null) {\n            positionFromObject(o, pos);\n        }\n    } else if (node.hasAttribute(\"x\")) {\n        pos.x = (double) node.getNumber(\"x\");\n        if (node.hasAttribute(\"y\"))\n            pos.y = (double) node.getNumber(\"y\");\n        if (node.hasAttribute(\"z\"))\n            pos.z = (double) node.getNumber(\"z\");\n    }\n    //\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n    //\t\t\tObject o = node.getAttribute(\"xyz\");\n    //\n    //\t\t\tif (o == null)\n    //\t\t\t\to = node.getAttribute(\"xy\");\n    //\n    //\t\t\tif (o != null && o instanceof Object[]) {\n    //\t\t\t\tObject oo[] = (Object[]) o;\n    //\n    //\t\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n    //\t\t\t\t\tpos.x = ((Number) oo[0]).doubleValue();\n    //\n    //\t\t\t\t\tif (oo.length > 1)\n    //\t\t\t\t\t\tpos.y = ((Number) oo[1]).doubleValue();\n    //\t\t\t\t\tif (oo.length > 2)\n    //\t\t\t\t\t\tpos.z = ((Number) oo[2]).doubleValue();\n    //\t\t\t\t}\n    //\t\t\t}\n    //\t\t} else if (node.hasAttribute(\"x\")) {\n    //\t\t\tpos.x = (double) node.getNumber(\"x\");\n    //\n    //\t\t\tif (node.hasAttribute(\"y\"))\n    //\t\t\t\tpos.y = (double) node.getNumber(\"y\");\n    //\n    //\t\t\tif (node.hasAttribute(\"z\"))\n    //\t\t\t\tpos.z = (double) node.getNumber(\"z\");\n    //\t\t}\n}",
        "classJavadoc": "/**\n * Lots of small often used measuring algorithms on graphs.\n * \n * <p>\n * Use this class with a static import.\n * </p>\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.ui.graphicGraph;\n\nimport org.graphstream.graph.Edge;\nimport org.graphstream.graph.Graph;\nimport org.graphstream.graph.Node;\nimport org.graphstream.ui.geom.Point2;\nimport org.graphstream.ui.geom.Point3;\nimport org.graphstream.ui.geom.Vector2;\nimport org.graphstream.ui.geom.Vector3;\n\nimport java.util.logging.Logger;\n\n/**\n * Lots of small often used measuring algorithms on graphs.\n * \n * <p>\n * Use this class with a static import.\n * </p>\n */\npublic class GraphPosLengthUtils {\n\n    /**\n     * class level logger\n     */\n    private static final Logger logger = Logger.getLogger(GraphPosLengthUtils.class.getSimpleName());\n\n\t/**\n\t * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n\t * \"xyz\").\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @return A newly allocated array of three floats containing the (x,y,z)\n\t *         position of the node, or null if the node is not part of the\n\t *         graph.\n\t */\n\tpublic static double[] nodePosition(Graph graph, String id) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\treturn nodePosition(node);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n\t * \"xyz\").\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @return A newly allocated point containing the (x,y,z)\n\t *         position of the node, or null if the node is not part of the\n\t *         graph.\n\t */\n\tpublic static Point3 nodePointPosition(Graph graph, String id) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\treturn nodePointPosition(node);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String)} but use an existing node as\n\t * argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @return A newly allocated array of three floats containing the (x,y,z)\n\t *         position of the node.\n\t */\n\tpublic static double[] nodePosition(Node node) {\n\t\tdouble xyz[] = new double[3];\n\n\t\tnodePosition(node, xyz);\n\n\t\treturn xyz;\n\t}\n\n\t/**\n\t * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n\t * argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @return A newly allocated point containing the (x,y,z)\n\t *         position of the node.\n\t */\n\tpublic static Point3 nodePointPosition(Node node) {\n\t\tPoint3 pos = new Point3();\n\n\t\tnodePosition(node, pos);\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String)}, but instead of returning a\n\t * newly allocated array, fill up the array given as parameter. This array\n\t * must have at least three cells.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param xyz\n\t *            An array of at least three cells.\n\t * @throws RuntimeException\n\t *             If the node with the given identifier does not exist.\n\t */\n\tpublic static void nodePosition(Graph graph, String id, double xyz[]) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\tnodePosition(node, xyz);\n\n\t\tthrow new RuntimeException(\"node '\" + id + \"' does not exist\");\n\t}\n\t\n\t/**\n\t * Like {@link #nodePointPosition(Graph,String)}, but instead of returning a\n\t * newly allocated array, fill up the array given as parameter. This array\n\t * must have at least three cells.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t * @throws RuntimeException\n\t *             If the node with the given identifier does not exist.\n\t */\n\tpublic static void nodePosition(Graph graph, String id, Point3 pos) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\tnodePosition(node, pos);\n\n\t\tthrow new RuntimeException(\"node '\" + id + \"' does not exist\");\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String,double[])} but use an existing node\n\t * as argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @param xyz\n\t *            An array of at least three cells.\n\t */\n\tpublic static void nodePosition(Node node, double xyz[]) {\n\t\tif (xyz.length < 3)\n\t\t\treturn;\n\n\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n\t\t\tObject o = node.getAttribute(\"xyz\");\n\n\t\t\tif (o == null)\n\t\t\t\to = node.getAttribute(\"xy\");\n\n\t\t\tif (o != null) {\n\t\t\t\tpositionFromObject(o, xyz);\n\t\t\t}\n\t\t\t\n\t\t} else if (node.hasAttribute(\"x\")) {\n\t\t\txyz[0] = (double) node.getNumber(\"x\");\n\n\t\t\tif (node.hasAttribute(\"y\"))\n\t\t\t\txyz[1] = (double) node.getNumber(\"y\");\n\n\t\t\tif (node.hasAttribute(\"z\"))\n\t\t\t\txyz[2] = (double) node.getNumber(\"z\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Like {@link #nodePosition(Graph,String,Point3)} but use an existing node\n\t * as argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t */\n\tpublic static void nodePosition(Node node, Point3 pos) {\n\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n\t\t\tObject o = node.getAttribute(\"xyz\");\n\n\t\t\tif (o == null)\n\t\t\t\to = node.getAttribute(\"xy\");\n\n\t\t\tif (o != null) {\n\t\t\t\tpositionFromObject(o, pos);\n\t\t\t}\n\t\t} else if (node.hasAttribute(\"x\")) {\n\t\t\tpos.x = (double) node.getNumber(\"x\");\n\n\t\t\tif (node.hasAttribute(\"y\"))\n\t\t\t\tpos.y = (double) node.getNumber(\"y\");\n\n\t\t\tif (node.hasAttribute(\"z\"))\n\t\t\t\tpos.z = (double) node.getNumber(\"z\");\n\t\t}\n\n//\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n//\t\t\tObject o = node.getAttribute(\"xyz\");\n//\n//\t\t\tif (o == null)\n//\t\t\t\to = node.getAttribute(\"xy\");\n//\n//\t\t\tif (o != null && o instanceof Object[]) {\n//\t\t\t\tObject oo[] = (Object[]) o;\n//\n//\t\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n//\t\t\t\t\tpos.x = ((Number) oo[0]).doubleValue();\n//\n//\t\t\t\t\tif (oo.length > 1)\n//\t\t\t\t\t\tpos.y = ((Number) oo[1]).doubleValue();\n//\t\t\t\t\tif (oo.length > 2)\n//\t\t\t\t\t\tpos.z = ((Number) oo[2]).doubleValue();\n//\t\t\t\t}\n//\t\t\t}\n//\t\t} else if (node.hasAttribute(\"x\")) {\n//\t\t\tpos.x = (double) node.getNumber(\"x\");\n//\n//\t\t\tif (node.hasAttribute(\"y\"))\n//\t\t\t\tpos.y = (double) node.getNumber(\"y\");\n//\n//\t\t\tif (node.hasAttribute(\"z\"))\n//\t\t\t\tpos.z = (double) node.getNumber(\"z\");\n//\t\t}\n\t}\n\t\n\t/**\n\t * Try to convert an object to a position. The object can be an array of \n\t * numbers, an array of base numeric types or their object counterparts.\n\t * @param o The object to try to convert.\n\t * @param xyz The result.\n\t */\n\tpublic static void positionFromObject(Object o, double xyz[]) {\n\t\tif(o instanceof Object[]) {\n\t\t\tObject oo[] = (Object[]) o;\n\n\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n\t\t\t\txyz[0] = ((Number) oo[0]).doubleValue();\n\t\t\t\tif (oo.length > 1) xyz[1] = ((Number) oo[1]).doubleValue();\n\t\t\t\tif (oo.length > 2) xyz[2] = ((Number) oo[2]).doubleValue();\n\t\t\t}\n\t\t} else if(o instanceof Double[]) {\n\t\t\tDouble oo[] = (Double[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Float[]) {\n\t\t\tFloat oo[] = (Float[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Integer[]) {\n\t\t\tInteger oo[] = (Integer[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof double[]) {\n\t\t\tdouble oo[] = (double[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof float[]) {\n\t\t\tfloat oo[] = (float[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof int[]) {\n\t\t\tint oo[] = (int[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Number[]) {\n\t\t\tNumber oo[] = (Number[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0].doubleValue();\n\t\t\tif(oo.length > 1) xyz[1] = oo[1].doubleValue();\n\t\t\tif(oo.length > 2) xyz[2] = oo[2].doubleValue();\n\t\t} else if(o instanceof Point3) {\n\t\t\tPoint3 oo = (Point3) o;\n\t\t\txyz[0] = oo.x;\n\t\t\txyz[1] = oo.y;\n\t\t\txyz[2] = oo.z;\n\t\t} else if(o instanceof Vector3) {\n\t\t\tVector3 oo = (Vector3) o;\n\t\t\txyz[0] = oo.data[0];\n\t\t\txyz[1] = oo.data[1];\n\t\t\txyz[2] = oo.data[2];\n\t\t} else if(o instanceof Point2) {\n\t\t\tPoint2 oo = (Point2) o;\n\t\t\txyz[0] = oo.x;\n\t\t\txyz[1] = oo.y;\n\t\t\txyz[2] = 0;\n\t\t} else if(o instanceof Vector2) {\n\t\t\tVector2 oo = (Vector2) o;\n\t\t\txyz[0] = oo.data[0];\n\t\t\txyz[1] = oo.data[1];\n\t\t\txyz[2] = 0;\n\t\t} else {\n\t\t\tlogger.warning(String.format(\"Do not know how to handle xyz attribute %s.\", o.getClass().getName()));\n\t\t}\n\t}\n\t\n\t/**\n\t * Try to convert an object to a position. The object can be an array of \n\t * numbers, an array of base numeric types or their object counterparts.\n\t * @param o The object to try to convert.\n\t * @param pos The result.\n\t */\n\tpublic static void positionFromObject(Object o, Point3 pos) {\n\t\tif(o instanceof Object[]) {\n\t\t\tObject oo[] = (Object[]) o;\n\n\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n\t\t\t\tpos.x = ((Number) oo[0]).doubleValue();\n\t\t\t\tif (oo.length > 1) pos.y = ((Number) oo[1]).doubleValue();\n\t\t\t\tif (oo.length > 2) pos.z = ((Number) oo[2]).doubleValue();\n\t\t\t}\n\t\t} else if(o instanceof Double[]) {\n\t\t\tDouble oo[] = (Double[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Float[]) {\n\t\t\tFloat oo[] = (Float[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Integer[]) {\n\t\t\tInteger oo[] = (Integer[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof double[]) {\n\t\t\tdouble oo[] = (double[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof float[]) {\n\t\t\tfloat oo[] = (float[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof int[]) {\n\t\t\tint oo[] = (int[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Number[]) {\n\t\t\tNumber oo[] = (Number[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0].doubleValue();\n\t\t\tif(oo.length > 1) pos.y = oo[1].doubleValue();\n\t\t\tif(oo.length > 2) pos.z = oo[2].doubleValue();\n\t\t} else if(o instanceof Point3) {\n\t\t\tPoint3 oo = (Point3) o;\n\t\t\tpos.x = oo.x;\n\t\t\tpos.y = oo.y;\n\t\t\tpos.z = oo.z;\n\t\t} else if(o instanceof Vector3) {\n\t\t\tVector3 oo = (Vector3) o;\n\t\t\tpos.x = oo.data[0];\n\t\t\tpos.y = oo.data[1];\n\t\t\tpos.z = oo.data[2];\n\t\t} else if(o instanceof Point2) {\n\t\t\tPoint2 oo = (Point2) o;\n\t\t\tpos.x = oo.x;\n\t\t\tpos.y = oo.y;\n\t\t\tpos.z = 0;\n\t\t} else if(o instanceof Vector2) {\n\t\t\tVector2 oo = (Vector2) o;\n\t\t\tpos.x = oo.data[0];\n\t\t\tpos.y = oo.data[1];\n\t\t\tpos.z = 0;\n\t\t} else {\n            logger.warning(String.format(\"Do not know how to handle xyz attribute %s%n\", o.getClass().getName()));\n\t\t}\n\t}\n\n\t/**\n\t * Compute the edge length of the given edge according to its two nodes\n\t * positions.\n\t * \n\t * @param id\n\t *            The identifier of the edge.\n\t * @return The edge length or -1 if the nodes of the edge have no positions.\n\t * @throws RuntimeException\n\t *             If the edge cannot be found.\n\t */\n\tpublic static double edgeLength(Graph graph, String id) {\n\t\tEdge edge = graph.getEdge(id);\n\n\t\tif (edge != null)\n\t\t\treturn edgeLength(edge);\n\n\t\tthrow new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n\t}\n\n\t/**\n\t * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n\t * argument.\n\t * \n\t * @param edge\n\t * @return The edge length or -1 if the nodes of the edge have no positions.\n\t */\n\tpublic static double edgeLength(Edge edge) {\n\t\tdouble xyz0[] = nodePosition(edge.getNode0());\n\t\tdouble xyz1[] = nodePosition(edge.getNode1());\n\n\t\tif (xyz0 == null || xyz1 == null)\n\t\t\treturn -1;\n\n\t\txyz0[0] = xyz1[0] - xyz0[0];\n\t\txyz0[1] = xyz1[1] - xyz0[1];\n\t\txyz0[2] = xyz1[2] - xyz0[2];\n\n\t\treturn Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1]\n\t\t\t\t+ xyz0[2] * xyz0[2]);\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "3",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "node",
                "org.graphstream.graph",
                "Node"
            ],
            [
                "pos",
                "org.graphstream.ui.geom",
                "Point3"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "hasEdgeBetween",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeBetween(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "getEdgeSet",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Collection<T> getEdgeSet()"
            ],
            [
                "getGraph",
                "org.graphstream.graph",
                "Node",
                "public abstract Graph getGraph()"
            ],
            [
                "getLeavingEdgeIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getLeavingEdgeIterator()"
            ],
            [
                "getEdgeToward",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeToward(String arg0)"
            ],
            [
                "hasEdgeBetween",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeBetween(Node arg0)"
            ],
            [
                "getEachLeavingEdge",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterable<T> getEachLeavingEdge()"
            ],
            [
                "getLeavingEdgeSet",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Collection<T> getLeavingEdgeSet()"
            ],
            [
                "hasEdgeToward",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeToward(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "getLeavingEdge",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getLeavingEdge(int arg0)"
            ],
            [
                "getBreadthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getBreadthFirstIterator()"
            ],
            [
                "getOutDegree",
                "org.graphstream.graph",
                "Node",
                "public abstract int getOutDegree()"
            ],
            [
                "getEnteringEdgeSet",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Collection<T> getEnteringEdgeSet()"
            ],
            [
                "getDegree",
                "org.graphstream.graph",
                "Node",
                "public abstract int getDegree()"
            ],
            [
                "getEnteringEdgeIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getEnteringEdgeIterator()"
            ],
            [
                "getEdgeToward",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeToward(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "toString",
                "org.graphstream.graph",
                "Node",
                "public abstract String toString()"
            ],
            [
                "getNeighborNodeIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getNeighborNodeIterator()"
            ],
            [
                "getEdgeBetween",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeBetween(Node arg0)"
            ],
            [
                "hasEdgeFrom",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeFrom(Node arg0)"
            ],
            [
                "getEachEdge",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterable<T> getEachEdge()"
            ],
            [
                "getEdgeFrom",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeFrom(Node arg0)"
            ],
            [
                "getEachEnteringEdge",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterable<T> getEachEnteringEdge()"
            ],
            [
                "getEnteringEdge",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEnteringEdge(int arg0)"
            ],
            [
                "hasEdgeFrom",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeFrom(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "hasEdgeFrom",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeFrom(String arg0)"
            ],
            [
                "getEdgeToward",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeToward(Node arg0)"
            ],
            [
                "getEdge",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdge(int arg0)"
            ],
            [
                "hasEdgeBetween",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeBetween(String arg0)"
            ],
            [
                "getEdgeBetween",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeBetween(String arg0)"
            ],
            [
                "getEdgeFrom",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeFrom(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "getEdgeFrom",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeFrom(String arg0)"
            ],
            [
                "getEdgeBetween",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> T getEdgeBetween(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "getInDegree",
                "org.graphstream.graph",
                "Node",
                "public abstract int getInDegree()"
            ],
            [
                "getDepthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getDepthFirstIterator()"
            ],
            [
                "getDepthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getDepthFirstIterator(boolean arg0)"
            ],
            [
                "getEdgeIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getEdgeIterator()"
            ],
            [
                "getBreadthFirstIterator",
                "org.graphstream.graph",
                "Node",
                "public abstract <T> Iterator<T> getBreadthFirstIterator(boolean arg0)"
            ],
            [
                "hasEdgeToward",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeToward(String arg0)"
            ],
            [
                "hasEdgeToward",
                "org.graphstream.graph",
                "Node",
                "public abstract boolean hasEdgeToward(Node arg0)"
            ],
            [
                "getArray",
                "org.graphstream.graph",
                "Element",
                "public abstract Object[] getArray(String arg0)"
            ],
            [
                "getIndex",
                "org.graphstream.graph",
                "Element",
                "public abstract int getIndex()"
            ],
            [
                "getHash",
                "org.graphstream.graph",
                "Element",
                "public abstract HashMap<?, ?> getHash(String arg0)"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0, Class<?> arg1)"
            ],
            [
                "hasLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasLabel(String arg0)"
            ],
            [
                "hasArray",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasArray(String arg0)"
            ],
            [
                "hasNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasNumber(String arg0)"
            ],
            [
                "getAttributeKeySet",
                "org.graphstream.graph",
                "Element",
                "public abstract Collection<String> getAttributeKeySet()"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(String[] arg0)"
            ],
            [
                "getVector",
                "org.graphstream.graph",
                "Element",
                "public abstract ArrayList<? extends Number> getVector(String arg0)"
            ],
            [
                "getAttributeCount",
                "org.graphstream.graph",
                "Element",
                "public abstract int getAttributeCount()"
            ],
            [
                "hasHash",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasHash(String arg0)"
            ],
            [
                "getId",
                "org.graphstream.graph",
                "Element",
                "public abstract String getId()"
            ],
            [
                "hasVector",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasVector(String arg0)"
            ],
            [
                "getNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract double getNumber(String arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0, Class<T> arg1)"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0)"
            ],
            [
                "getAttributeKeyIterator",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterator<String> getAttributeKeyIterator()"
            ],
            [
                "getEachAttributeKey",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterable<String> getEachAttributeKey()"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0)"
            ],
            [
                "getLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract CharSequence getLabel(String arg0)"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "equals",
                "org.graphstream.ui.geom",
                "Point3",
                "public boolean equals(Object arg0)"
            ],
            [
                "interpolate",
                "org.graphstream.ui.geom",
                "Point3",
                "public Point3 interpolate(Point3 arg0, double arg1)"
            ],
            [
                "isZero",
                "org.graphstream.ui.geom",
                "Point3",
                "public boolean isZero()"
            ],
            [
                "hashCode",
                "org.graphstream.ui.geom",
                "Point3",
                "public int hashCode()"
            ],
            [
                "distance",
                "org.graphstream.ui.geom",
                "Point3",
                "public double distance(double arg0, double arg1, double arg2)"
            ],
            [
                "toString",
                "org.graphstream.ui.geom",
                "Point3",
                "public String toString()"
            ],
            [
                "distance",
                "org.graphstream.ui.geom",
                "Point3",
                "public double distance(Point3 arg0)"
            ],
            [
                "hashCode",
                "org.graphstream.ui.geom",
                "Point2",
                "public int hashCode()"
            ],
            [
                "interpolate",
                "org.graphstream.ui.geom",
                "Point2",
                "public Point2 interpolate(Point2 arg0, double arg1)"
            ],
            [
                "toString",
                "org.graphstream.ui.geom",
                "Point2",
                "public String toString()"
            ],
            [
                "distance",
                "org.graphstream.ui.geom",
                "Point2",
                "public double distance(Point2 arg0)"
            ],
            [
                "isZero",
                "org.graphstream.ui.geom",
                "Point2",
                "public boolean isZero()"
            ],
            [
                "equals",
                "org.graphstream.ui.geom",
                "Point2",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "z",
                "org.graphstream.ui.geom",
                "Point3",
                "public double z;"
            ],
            [
                "x",
                "org.graphstream.ui.geom",
                "Point2",
                "public double x;"
            ],
            [
                "y",
                "org.graphstream.ui.geom",
                "Point2",
                "public double y;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3181,
        "oracle": "graph.getEdge(id) == null;",
        "oracleType": "EXCEPT_POST",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.ui.graphicGraph",
        "className": "GraphPosLengthUtils",
        "javadocTag": "@throws RuntimeException If the edge cannot be found.",
        "methodJavadoc": "    /**\n\t * Compute the edge length of the given edge according to its two nodes\n\t * positions.\n\t * \n\t * @param id\n\t *            The identifier of the edge.\n\t * @return The edge length or -1 if the nodes of the edge have no positions.\n\t * @throws RuntimeException\n\t *             If the edge cannot be found.\n\t */",
        "methodSourceCode": "public static double edgeLength(Graph graph, String id){\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}",
        "classJavadoc": "/**\n * Lots of small often used measuring algorithms on graphs.\n * \n * <p>\n * Use this class with a static import.\n * </p>\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.ui.graphicGraph;\n\nimport org.graphstream.graph.Edge;\nimport org.graphstream.graph.Graph;\nimport org.graphstream.graph.Node;\nimport org.graphstream.ui.geom.Point2;\nimport org.graphstream.ui.geom.Point3;\nimport org.graphstream.ui.geom.Vector2;\nimport org.graphstream.ui.geom.Vector3;\n\nimport java.util.logging.Logger;\n\n/**\n * Lots of small often used measuring algorithms on graphs.\n * \n * <p>\n * Use this class with a static import.\n * </p>\n */\npublic class GraphPosLengthUtils {\n\n    /**\n     * class level logger\n     */\n    private static final Logger logger = Logger.getLogger(GraphPosLengthUtils.class.getSimpleName());\n\n\t/**\n\t * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n\t * \"xyz\").\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @return A newly allocated array of three floats containing the (x,y,z)\n\t *         position of the node, or null if the node is not part of the\n\t *         graph.\n\t */\n\tpublic static double[] nodePosition(Graph graph, String id) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\treturn nodePosition(node);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n\t * \"xyz\").\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @return A newly allocated point containing the (x,y,z)\n\t *         position of the node, or null if the node is not part of the\n\t *         graph.\n\t */\n\tpublic static Point3 nodePointPosition(Graph graph, String id) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\treturn nodePointPosition(node);\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String)} but use an existing node as\n\t * argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @return A newly allocated array of three floats containing the (x,y,z)\n\t *         position of the node.\n\t */\n\tpublic static double[] nodePosition(Node node) {\n\t\tdouble xyz[] = new double[3];\n\n\t\tnodePosition(node, xyz);\n\n\t\treturn xyz;\n\t}\n\n\t/**\n\t * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n\t * argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @return A newly allocated point containing the (x,y,z)\n\t *         position of the node.\n\t */\n\tpublic static Point3 nodePointPosition(Node node) {\n\t\tPoint3 pos = new Point3();\n\n\t\tnodePosition(node, pos);\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String)}, but instead of returning a\n\t * newly allocated array, fill up the array given as parameter. This array\n\t * must have at least three cells.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param xyz\n\t *            An array of at least three cells.\n\t * @throws RuntimeException\n\t *             If the node with the given identifier does not exist.\n\t */\n\tpublic static void nodePosition(Graph graph, String id, double xyz[]) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\tnodePosition(node, xyz);\n\n\t\tthrow new RuntimeException(\"node '\" + id + \"' does not exist\");\n\t}\n\t\n\t/**\n\t * Like {@link #nodePointPosition(Graph,String)}, but instead of returning a\n\t * newly allocated array, fill up the array given as parameter. This array\n\t * must have at least three cells.\n\t * \n\t * @param id\n\t *            The node identifier.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t * @throws RuntimeException\n\t *             If the node with the given identifier does not exist.\n\t */\n\tpublic static void nodePosition(Graph graph, String id, Point3 pos) {\n\t\tNode node = graph.getNode(id);\n\n\t\tif (node != null)\n\t\t\tnodePosition(node, pos);\n\n\t\tthrow new RuntimeException(\"node '\" + id + \"' does not exist\");\n\t}\n\n\t/**\n\t * Like {@link #nodePosition(Graph,String,double[])} but use an existing node\n\t * as argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @param xyz\n\t *            An array of at least three cells.\n\t */\n\tpublic static void nodePosition(Node node, double xyz[]) {\n\t\tif (xyz.length < 3)\n\t\t\treturn;\n\n\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n\t\t\tObject o = node.getAttribute(\"xyz\");\n\n\t\t\tif (o == null)\n\t\t\t\to = node.getAttribute(\"xy\");\n\n\t\t\tif (o != null) {\n\t\t\t\tpositionFromObject(o, xyz);\n\t\t\t}\n\t\t\t\n\t\t} else if (node.hasAttribute(\"x\")) {\n\t\t\txyz[0] = (double) node.getNumber(\"x\");\n\n\t\t\tif (node.hasAttribute(\"y\"))\n\t\t\t\txyz[1] = (double) node.getNumber(\"y\");\n\n\t\t\tif (node.hasAttribute(\"z\"))\n\t\t\t\txyz[2] = (double) node.getNumber(\"z\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Like {@link #nodePosition(Graph,String,Point3)} but use an existing node\n\t * as argument.\n\t * \n\t * @param node\n\t *            The node to consider.\n\t * @param pos\n\t *            A point that will receive the node position.\n\t */\n\tpublic static void nodePosition(Node node, Point3 pos) {\n\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n\t\t\tObject o = node.getAttribute(\"xyz\");\n\n\t\t\tif (o == null)\n\t\t\t\to = node.getAttribute(\"xy\");\n\n\t\t\tif (o != null) {\n\t\t\t\tpositionFromObject(o, pos);\n\t\t\t}\n\t\t} else if (node.hasAttribute(\"x\")) {\n\t\t\tpos.x = (double) node.getNumber(\"x\");\n\n\t\t\tif (node.hasAttribute(\"y\"))\n\t\t\t\tpos.y = (double) node.getNumber(\"y\");\n\n\t\t\tif (node.hasAttribute(\"z\"))\n\t\t\t\tpos.z = (double) node.getNumber(\"z\");\n\t\t}\n\n//\t\tif (node.hasAttribute(\"xyz\") || node.hasAttribute(\"xy\")) {\n//\t\t\tObject o = node.getAttribute(\"xyz\");\n//\n//\t\t\tif (o == null)\n//\t\t\t\to = node.getAttribute(\"xy\");\n//\n//\t\t\tif (o != null && o instanceof Object[]) {\n//\t\t\t\tObject oo[] = (Object[]) o;\n//\n//\t\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n//\t\t\t\t\tpos.x = ((Number) oo[0]).doubleValue();\n//\n//\t\t\t\t\tif (oo.length > 1)\n//\t\t\t\t\t\tpos.y = ((Number) oo[1]).doubleValue();\n//\t\t\t\t\tif (oo.length > 2)\n//\t\t\t\t\t\tpos.z = ((Number) oo[2]).doubleValue();\n//\t\t\t\t}\n//\t\t\t}\n//\t\t} else if (node.hasAttribute(\"x\")) {\n//\t\t\tpos.x = (double) node.getNumber(\"x\");\n//\n//\t\t\tif (node.hasAttribute(\"y\"))\n//\t\t\t\tpos.y = (double) node.getNumber(\"y\");\n//\n//\t\t\tif (node.hasAttribute(\"z\"))\n//\t\t\t\tpos.z = (double) node.getNumber(\"z\");\n//\t\t}\n\t}\n\t\n\t/**\n\t * Try to convert an object to a position. The object can be an array of \n\t * numbers, an array of base numeric types or their object counterparts.\n\t * @param o The object to try to convert.\n\t * @param xyz The result.\n\t */\n\tpublic static void positionFromObject(Object o, double xyz[]) {\n\t\tif(o instanceof Object[]) {\n\t\t\tObject oo[] = (Object[]) o;\n\n\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n\t\t\t\txyz[0] = ((Number) oo[0]).doubleValue();\n\t\t\t\tif (oo.length > 1) xyz[1] = ((Number) oo[1]).doubleValue();\n\t\t\t\tif (oo.length > 2) xyz[2] = ((Number) oo[2]).doubleValue();\n\t\t\t}\n\t\t} else if(o instanceof Double[]) {\n\t\t\tDouble oo[] = (Double[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Float[]) {\n\t\t\tFloat oo[] = (Float[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Integer[]) {\n\t\t\tInteger oo[] = (Integer[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof double[]) {\n\t\t\tdouble oo[] = (double[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof float[]) {\n\t\t\tfloat oo[] = (float[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof int[]) {\n\t\t\tint oo[] = (int[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0];\n\t\t\tif(oo.length > 1) xyz[1] = oo[1];\n\t\t\tif(oo.length > 2) xyz[2] = oo[2];\n\t\t} else if(o instanceof Number[]) {\n\t\t\tNumber oo[] = (Number[]) o;\n\t\t\tif(oo.length > 0) xyz[0] = oo[0].doubleValue();\n\t\t\tif(oo.length > 1) xyz[1] = oo[1].doubleValue();\n\t\t\tif(oo.length > 2) xyz[2] = oo[2].doubleValue();\n\t\t} else if(o instanceof Point3) {\n\t\t\tPoint3 oo = (Point3) o;\n\t\t\txyz[0] = oo.x;\n\t\t\txyz[1] = oo.y;\n\t\t\txyz[2] = oo.z;\n\t\t} else if(o instanceof Vector3) {\n\t\t\tVector3 oo = (Vector3) o;\n\t\t\txyz[0] = oo.data[0];\n\t\t\txyz[1] = oo.data[1];\n\t\t\txyz[2] = oo.data[2];\n\t\t} else if(o instanceof Point2) {\n\t\t\tPoint2 oo = (Point2) o;\n\t\t\txyz[0] = oo.x;\n\t\t\txyz[1] = oo.y;\n\t\t\txyz[2] = 0;\n\t\t} else if(o instanceof Vector2) {\n\t\t\tVector2 oo = (Vector2) o;\n\t\t\txyz[0] = oo.data[0];\n\t\t\txyz[1] = oo.data[1];\n\t\t\txyz[2] = 0;\n\t\t} else {\n\t\t\tlogger.warning(String.format(\"Do not know how to handle xyz attribute %s.\", o.getClass().getName()));\n\t\t}\n\t}\n\t\n\t/**\n\t * Try to convert an object to a position. The object can be an array of \n\t * numbers, an array of base numeric types or their object counterparts.\n\t * @param o The object to try to convert.\n\t * @param pos The result.\n\t */\n\tpublic static void positionFromObject(Object o, Point3 pos) {\n\t\tif(o instanceof Object[]) {\n\t\t\tObject oo[] = (Object[]) o;\n\n\t\t\tif (oo.length > 0 && oo[0] instanceof Number) {\n\t\t\t\tpos.x = ((Number) oo[0]).doubleValue();\n\t\t\t\tif (oo.length > 1) pos.y = ((Number) oo[1]).doubleValue();\n\t\t\t\tif (oo.length > 2) pos.z = ((Number) oo[2]).doubleValue();\n\t\t\t}\n\t\t} else if(o instanceof Double[]) {\n\t\t\tDouble oo[] = (Double[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Float[]) {\n\t\t\tFloat oo[] = (Float[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Integer[]) {\n\t\t\tInteger oo[] = (Integer[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof double[]) {\n\t\t\tdouble oo[] = (double[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof float[]) {\n\t\t\tfloat oo[] = (float[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof int[]) {\n\t\t\tint oo[] = (int[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0];\n\t\t\tif(oo.length > 1) pos.y = oo[1];\n\t\t\tif(oo.length > 2) pos.z = oo[2];\n\t\t} else if(o instanceof Number[]) {\n\t\t\tNumber oo[] = (Number[]) o;\n\t\t\tif(oo.length > 0) pos.x = oo[0].doubleValue();\n\t\t\tif(oo.length > 1) pos.y = oo[1].doubleValue();\n\t\t\tif(oo.length > 2) pos.z = oo[2].doubleValue();\n\t\t} else if(o instanceof Point3) {\n\t\t\tPoint3 oo = (Point3) o;\n\t\t\tpos.x = oo.x;\n\t\t\tpos.y = oo.y;\n\t\t\tpos.z = oo.z;\n\t\t} else if(o instanceof Vector3) {\n\t\t\tVector3 oo = (Vector3) o;\n\t\t\tpos.x = oo.data[0];\n\t\t\tpos.y = oo.data[1];\n\t\t\tpos.z = oo.data[2];\n\t\t} else if(o instanceof Point2) {\n\t\t\tPoint2 oo = (Point2) o;\n\t\t\tpos.x = oo.x;\n\t\t\tpos.y = oo.y;\n\t\t\tpos.z = 0;\n\t\t} else if(o instanceof Vector2) {\n\t\t\tVector2 oo = (Vector2) o;\n\t\t\tpos.x = oo.data[0];\n\t\t\tpos.y = oo.data[1];\n\t\t\tpos.z = 0;\n\t\t} else {\n            logger.warning(String.format(\"Do not know how to handle xyz attribute %s%n\", o.getClass().getName()));\n\t\t}\n\t}\n\n\t/**\n\t * Compute the edge length of the given edge according to its two nodes\n\t * positions.\n\t * \n\t * @param id\n\t *            The identifier of the edge.\n\t * @return The edge length or -1 if the nodes of the edge have no positions.\n\t * @throws RuntimeException\n\t *             If the edge cannot be found.\n\t */\n\tpublic static double edgeLength(Graph graph, String id) {\n\t\tEdge edge = graph.getEdge(id);\n\n\t\tif (edge != null)\n\t\t\treturn edgeLength(edge);\n\n\t\tthrow new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n\t}\n\n\t/**\n\t * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n\t * argument.\n\t * \n\t * @param edge\n\t * @return The edge length or -1 if the nodes of the edge have no positions.\n\t */\n\tpublic static double edgeLength(Edge edge) {\n\t\tdouble xyz0[] = nodePosition(edge.getNode0());\n\t\tdouble xyz1[] = nodePosition(edge.getNode1());\n\n\t\tif (xyz0 == null || xyz1 == null)\n\t\t\treturn -1;\n\n\t\txyz0[0] = xyz1[0] - xyz0[0];\n\t\txyz0[1] = xyz1[1] - xyz0[1];\n\t\txyz0[2] = xyz1[2] - xyz0[2];\n\n\t\treturn Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1]\n\t\t\t\t+ xyz0[2] * xyz0[2]);\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "-1",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "graph",
                "org.graphstream.graph",
                "Graph"
            ],
            [
                "id",
                "java.lang",
                "String"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "removeNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeNode(Node arg0)"
            ],
            [
                "getNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getNode(String arg0)"
            ],
            [
                "removeNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeNode(String arg0) throws ElementNotFoundException"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, String arg1, String arg2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException"
            ],
            [
                "getEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getEdge(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(String arg0) throws ElementNotFoundException"
            ],
            [
                "edgeFactory",
                "org.graphstream.graph",
                "Graph",
                "public abstract EdgeFactory<? extends Edge> edgeFactory()"
            ],
            [
                "getStep",
                "org.graphstream.graph",
                "Graph",
                "public abstract double getStep()"
            ],
            [
                "removeNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeNode(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, String arg1, String arg2, boolean arg3) throws IdAlreadyInUseException, ElementNotFoundException"
            ],
            [
                "nullAttributesAreErrors",
                "org.graphstream.graph",
                "Graph",
                "public abstract boolean nullAttributesAreErrors()"
            ],
            [
                "elementSinks",
                "org.graphstream.graph",
                "Graph",
                "public abstract Iterable<ElementSink> elementSinks()"
            ],
            [
                "getNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getNode(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, Node arg1, Node arg2) throws IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "addNode",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addNode(String arg0) throws IdAlreadyInUseException"
            ],
            [
                "getEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T getEdge(String arg0)"
            ],
            [
                "isAutoCreationEnabled",
                "org.graphstream.graph",
                "Graph",
                "public abstract boolean isAutoCreationEnabled()"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(Edge arg0)"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(int arg0, int arg1) throws IndexOutOfBoundsException, ElementNotFoundException"
            ],
            [
                "isStrict",
                "org.graphstream.graph",
                "Graph",
                "public abstract boolean isStrict()"
            ],
            [
                "nodeFactory",
                "org.graphstream.graph",
                "Graph",
                "public abstract NodeFactory<? extends Node> nodeFactory()"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, int arg1, int arg2, boolean arg3) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(int arg0) throws IndexOutOfBoundsException"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, int arg1, int arg2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "display",
                "org.graphstream.graph",
                "Graph",
                "public abstract Viewer display()"
            ],
            [
                "addEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T addEdge(String arg0, Node arg1, Node arg2, boolean arg3) throws IdAlreadyInUseException, EdgeRejectedException"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(String arg0, String arg1) throws ElementNotFoundException"
            ],
            [
                "attributeSinks",
                "org.graphstream.graph",
                "Graph",
                "public abstract Iterable<AttributeSink> attributeSinks()"
            ],
            [
                "display",
                "org.graphstream.graph",
                "Graph",
                "public abstract Viewer display(boolean arg0)"
            ],
            [
                "removeEdge",
                "org.graphstream.graph",
                "Graph",
                "public abstract <T> T removeEdge(Node arg0, Node arg1) throws ElementNotFoundException"
            ],
            [
                "hasVector",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasVector(String arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0)"
            ],
            [
                "getLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract CharSequence getLabel(String arg0)"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0)"
            ],
            [
                "getAttributeKeyIterator",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterator<String> getAttributeKeyIterator()"
            ],
            [
                "getEachAttributeKey",
                "org.graphstream.graph",
                "Element",
                "public abstract Iterable<String> getEachAttributeKey()"
            ],
            [
                "getAttributeCount",
                "org.graphstream.graph",
                "Element",
                "public abstract int getAttributeCount()"
            ],
            [
                "hasAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasAttribute(String arg0, Class<?> arg1)"
            ],
            [
                "hasArray",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasArray(String arg0)"
            ],
            [
                "getNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract double getNumber(String arg0)"
            ],
            [
                "getAttribute",
                "org.graphstream.graph",
                "Element",
                "public abstract <T> T getAttribute(String arg0, Class<T> arg1)"
            ],
            [
                "getAttributeKeySet",
                "org.graphstream.graph",
                "Element",
                "public abstract Collection<String> getAttributeKeySet()"
            ],
            [
                "hasLabel",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasLabel(String arg0)"
            ],
            [
                "getIndex",
                "org.graphstream.graph",
                "Element",
                "public abstract int getIndex()"
            ],
            [
                "getVector",
                "org.graphstream.graph",
                "Element",
                "public abstract ArrayList<? extends Number> getVector(String arg0)"
            ],
            [
                "getArray",
                "org.graphstream.graph",
                "Element",
                "public abstract Object[] getArray(String arg0)"
            ],
            [
                "hasHash",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasHash(String arg0)"
            ],
            [
                "getId",
                "org.graphstream.graph",
                "Element",
                "public abstract String getId()"
            ],
            [
                "hasNumber",
                "org.graphstream.graph",
                "Element",
                "public abstract boolean hasNumber(String arg0)"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(String[] arg0)"
            ],
            [
                "getFirstAttributeOf",
                "org.graphstream.graph",
                "Element",
                "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)"
            ],
            [
                "getHash",
                "org.graphstream.graph",
                "Element",
                "public abstract HashMap<?, ?> getHash(String arg0)"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "getEdgeCount",
                "org.graphstream.graph",
                "Structure",
                "public abstract int getEdgeCount()"
            ],
            [
                "getEachEdge",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterable<? extends T> getEachEdge()"
            ],
            [
                "getEachNode",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterable<? extends T> getEachNode()"
            ],
            [
                "getNodeCount",
                "org.graphstream.graph",
                "Structure",
                "public abstract int getNodeCount()"
            ],
            [
                "getNodeIterator",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterator<T> getNodeIterator()"
            ],
            [
                "getNodeSet",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Collection<T> getNodeSet()"
            ],
            [
                "getEdgeIterator",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Iterator<T> getEdgeIterator()"
            ],
            [
                "getEdgeSet",
                "org.graphstream.graph",
                "Structure",
                "public abstract <T> Collection<T> getEdgeSet()"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]